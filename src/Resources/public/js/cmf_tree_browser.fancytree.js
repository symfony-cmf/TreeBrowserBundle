/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/jquery.cmf_tree.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../bower_components/fancytree/dist/skin-win8/ui.fancytree.css":
/*!**********************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/bower_components/fancytree/dist/skin-win8/ui.fancytree.css ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/bower_components/fancytree/dist/skin-win8/ui.fancytree.css?");

/***/ }),

/***/ "../../../bower_components/fancytree/dist/src/jquery.fancytree.dnd.js":
/*!***********************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/bower_components/fancytree/dist/src/jquery.fancytree.dnd.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*!\n * jquery.fancytree.dnd.js\n *\n * Drag-and-drop support (jQuery UI draggable/droppable).\n * (Extension module for jquery.fancytree.js: https://github.com/mar10/fancytree/)\n *\n * Copyright (c) 2008-2017, Martin Wendt (http://wwWendt.de)\n *\n * Released under the MIT license\n * https://github.com/mar10/fancytree/wiki/LicenseInfo\n *\n * @version 2.21.0\n * @date 2017-01-15T17:21:28Z\n */\n\n;(function ($, window, document, undefined) {\n\n\t\"use strict\";\n\n\t/* *****************************************************************************\n  * Private functions and variables\n  */\n\n\tvar didRegisterDnd = false,\n\t    classDropAccept = \"fancytree-drop-accept\",\n\t    classDropAfter = \"fancytree-drop-after\",\n\t    classDropBefore = \"fancytree-drop-before\",\n\t    classDropOver = \"fancytree-drop-over\",\n\t    classDropReject = \"fancytree-drop-reject\",\n\t    classDropTarget = \"fancytree-drop-target\";\n\n\t/* Convert number to string and prepend +/-; return empty string for 0.*/\n\tfunction offsetString(n) {\n\t\treturn n === 0 ? \"\" : n > 0 ? \"+\" + n : \"\" + n;\n\t}\n\n\t//--- Extend ui.draggable event handling --------------------------------------\n\n\tfunction _registerDnd() {\n\t\tif (didRegisterDnd) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Register proxy-functions for draggable.start/drag/stop\n\n\t\t$.ui.plugin.add(\"draggable\", \"connectToFancytree\", {\n\t\t\tstart: function start(event, ui) {\n\t\t\t\t// 'draggable' was renamed to 'ui-draggable' since jQueryUI 1.10\n\t\t\t\tvar draggable = $(this).data(\"ui-draggable\") || $(this).data(\"draggable\"),\n\t\t\t\t    sourceNode = ui.helper.data(\"ftSourceNode\") || null;\n\n\t\t\t\tif (sourceNode) {\n\t\t\t\t\t// Adjust helper offset, so cursor is slightly outside top/left corner\n\t\t\t\t\tdraggable.offset.click.top = -2;\n\t\t\t\t\tdraggable.offset.click.left = +16;\n\t\t\t\t\t// Trigger dragStart event\n\t\t\t\t\t// TODO: when called as connectTo..., the return value is ignored(?)\n\t\t\t\t\treturn sourceNode.tree.ext.dnd._onDragEvent(\"start\", sourceNode, null, event, ui, draggable);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdrag: function drag(event, ui) {\n\t\t\t\tvar ctx,\n\t\t\t\t    isHelper,\n\t\t\t\t    logObject,\n\n\t\t\t\t// 'draggable' was renamed to 'ui-draggable' since jQueryUI 1.10\n\t\t\t\tdraggable = $(this).data(\"ui-draggable\") || $(this).data(\"draggable\"),\n\t\t\t\t    sourceNode = ui.helper.data(\"ftSourceNode\") || null,\n\t\t\t\t    prevTargetNode = ui.helper.data(\"ftTargetNode\") || null,\n\t\t\t\t    targetNode = $.ui.fancytree.getNode(event.target),\n\t\t\t\t    dndOpts = sourceNode && sourceNode.tree.options.dnd;\n\n\t\t\t\t// logObject = sourceNode || prevTargetNode || $.ui.fancytree;\n\t\t\t\t// logObject.debug(\"Drag event:\", event, event.shiftKey);\n\t\t\t\tif (event.target && !targetNode) {\n\t\t\t\t\t// We got a drag event, but the targetNode could not be found\n\t\t\t\t\t// at the event location. This may happen,\n\t\t\t\t\t// 1. if the mouse jumped over the drag helper,\n\t\t\t\t\t// 2. or if a non-fancytree element is dragged\n\t\t\t\t\t// We ignore it:\n\t\t\t\t\tisHelper = $(event.target).closest(\"div.fancytree-drag-helper,#fancytree-drop-marker\").length > 0;\n\t\t\t\t\tif (isHelper) {\n\t\t\t\t\t\tlogObject = sourceNode || prevTargetNode || $.ui.fancytree;\n\t\t\t\t\t\tlogObject.debug(\"Drag event over helper: ignored.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tui.helper.data(\"ftTargetNode\", targetNode);\n\n\t\t\t\tif (dndOpts && dndOpts.updateHelper) {\n\t\t\t\t\tctx = sourceNode.tree._makeHookContext(sourceNode, event, {\n\t\t\t\t\t\totherNode: targetNode,\n\t\t\t\t\t\tui: ui,\n\t\t\t\t\t\tdraggable: draggable,\n\t\t\t\t\t\tdropMarker: $(\"#fancytree-drop-marker\")\n\t\t\t\t\t});\n\t\t\t\t\tdndOpts.updateHelper.call(sourceNode.tree, sourceNode, ctx);\n\t\t\t\t}\n\n\t\t\t\t// Leaving a tree node\n\t\t\t\tif (prevTargetNode && prevTargetNode !== targetNode) {\n\t\t\t\t\tprevTargetNode.tree.ext.dnd._onDragEvent(\"leave\", prevTargetNode, sourceNode, event, ui, draggable);\n\t\t\t\t}\n\t\t\t\tif (targetNode) {\n\t\t\t\t\tif (!targetNode.tree.options.dnd.dragDrop) {\n\t\t\t\t\t\t// not enabled as drop target\n\t\t\t\t\t} else if (targetNode === prevTargetNode) {\n\t\t\t\t\t\t// Moving over same node\n\t\t\t\t\t\ttargetNode.tree.ext.dnd._onDragEvent(\"over\", targetNode, sourceNode, event, ui, draggable);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Entering this node first time\n\t\t\t\t\t\ttargetNode.tree.ext.dnd._onDragEvent(\"enter\", targetNode, sourceNode, event, ui, draggable);\n\t\t\t\t\t\ttargetNode.tree.ext.dnd._onDragEvent(\"over\", targetNode, sourceNode, event, ui, draggable);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// else go ahead with standard event handling\n\t\t\t},\n\t\t\tstop: function stop(event, ui) {\n\t\t\t\tvar logObject,\n\n\t\t\t\t// 'draggable' was renamed to 'ui-draggable' since jQueryUI 1.10:\n\t\t\t\tdraggable = $(this).data(\"ui-draggable\") || $(this).data(\"draggable\"),\n\t\t\t\t    sourceNode = ui.helper.data(\"ftSourceNode\") || null,\n\t\t\t\t    targetNode = ui.helper.data(\"ftTargetNode\") || null,\n\t\t\t\t    dropped = event.type === \"mouseup\" && event.which === 1;\n\n\t\t\t\tif (!dropped) {\n\t\t\t\t\tlogObject = sourceNode || targetNode || $.ui.fancytree;\n\t\t\t\t\tlogObject.debug(\"Drag was cancelled\");\n\t\t\t\t}\n\t\t\t\tif (targetNode) {\n\t\t\t\t\tif (dropped) {\n\t\t\t\t\t\ttargetNode.tree.ext.dnd._onDragEvent(\"drop\", targetNode, sourceNode, event, ui, draggable);\n\t\t\t\t\t}\n\t\t\t\t\ttargetNode.tree.ext.dnd._onDragEvent(\"leave\", targetNode, sourceNode, event, ui, draggable);\n\t\t\t\t}\n\t\t\t\tif (sourceNode) {\n\t\t\t\t\tsourceNode.tree.ext.dnd._onDragEvent(\"stop\", sourceNode, null, event, ui, draggable);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tdidRegisterDnd = true;\n\t}\n\n\t/* *****************************************************************************\n  * Drag and drop support\n  */\n\tfunction _initDragAndDrop(tree) {\n\t\tvar dnd = tree.options.dnd || null,\n\t\t    glyph = tree.options.glyph || null;\n\n\t\t// Register 'connectToFancytree' option with ui.draggable\n\t\tif (dnd) {\n\t\t\t_registerDnd();\n\t\t}\n\t\t// Attach ui.draggable to this Fancytree instance\n\t\tif (dnd && dnd.dragStart) {\n\t\t\ttree.widget.element.draggable($.extend({\n\t\t\t\taddClasses: false,\n\t\t\t\t// DT issue 244: helper should be child of scrollParent:\n\t\t\t\tappendTo: tree.$container,\n\t\t\t\t//\t\t\tappendTo: \"body\",\n\t\t\t\tcontainment: false,\n\t\t\t\t//\t\t\tcontainment: \"parent\",\n\t\t\t\tdelay: 0,\n\t\t\t\tdistance: 4,\n\t\t\t\trevert: false,\n\t\t\t\tscroll: true, // to disable, also set css 'position: inherit' on ul.fancytree-container\n\t\t\t\tscrollSpeed: 7,\n\t\t\t\tscrollSensitivity: 10,\n\t\t\t\t// Delegate draggable.start, drag, and stop events to our handler\n\t\t\t\tconnectToFancytree: true,\n\t\t\t\t// Let source tree create the helper element\n\t\t\t\thelper: function helper(event) {\n\t\t\t\t\tvar $helper,\n\t\t\t\t\t    $nodeTag,\n\t\t\t\t\t    opts,\n\t\t\t\t\t    sourceNode = $.ui.fancytree.getNode(event.target);\n\n\t\t\t\t\tif (!sourceNode) {\n\t\t\t\t\t\t// #405, DT issue 211: might happen, if dragging a table *header*\n\t\t\t\t\t\treturn \"<div>ERROR?: helper requested but sourceNode not found</div>\";\n\t\t\t\t\t}\n\t\t\t\t\topts = sourceNode.tree.options.dnd;\n\t\t\t\t\t$nodeTag = $(sourceNode.span);\n\t\t\t\t\t// Only event and node argument is available\n\t\t\t\t\t$helper = $(\"<div class='fancytree-drag-helper'><span class='fancytree-drag-helper-img' /></div>\").css({ zIndex: 3, position: \"relative\" }) // so it appears above ext-wide selection bar\n\t\t\t\t\t.append($nodeTag.find(\"span.fancytree-title\").clone());\n\n\t\t\t\t\t// Attach node reference to helper object\n\t\t\t\t\t$helper.data(\"ftSourceNode\", sourceNode);\n\n\t\t\t\t\t// Support glyph symbols instead of icons\n\t\t\t\t\tif (glyph) {\n\t\t\t\t\t\t$helper.find(\".fancytree-drag-helper-img\").addClass(glyph.map.dragHelper);\n\t\t\t\t\t}\n\t\t\t\t\t// Allow to modify the helper, e.g. to add multi-node-drag feedback\n\t\t\t\t\tif (opts.initHelper) {\n\t\t\t\t\t\topts.initHelper.call(sourceNode.tree, sourceNode, {\n\t\t\t\t\t\t\tnode: sourceNode,\n\t\t\t\t\t\t\ttree: sourceNode.tree,\n\t\t\t\t\t\t\toriginalEvent: event,\n\t\t\t\t\t\t\tui: { helper: $helper }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// We return an unconnected element, so `draggable` will add this\n\t\t\t\t\t// to the parent specified as `appendTo` option\n\t\t\t\t\treturn $helper;\n\t\t\t\t},\n\t\t\t\tstart: function start(event, ui) {\n\t\t\t\t\tvar sourceNode = ui.helper.data(\"ftSourceNode\");\n\t\t\t\t\treturn !!sourceNode; // Abort dragging if no node could be found\n\t\t\t\t}\n\t\t\t}, tree.options.dnd.draggable));\n\t\t}\n\t\t// Attach ui.droppable to this Fancytree instance\n\t\tif (dnd && dnd.dragDrop) {\n\t\t\ttree.widget.element.droppable($.extend({\n\t\t\t\taddClasses: false,\n\t\t\t\ttolerance: \"intersect\",\n\t\t\t\tgreedy: false\n\t\t\t\t/*\n    \t\t\tactivate: function(event, ui) {\n    \t\t\t\ttree.debug(\"droppable - activate\", event, ui, this);\n    \t\t\t},\n    \t\t\tcreate: function(event, ui) {\n    \t\t\t\ttree.debug(\"droppable - create\", event, ui);\n    \t\t\t},\n    \t\t\tdeactivate: function(event, ui) {\n    \t\t\t\ttree.debug(\"droppable - deactivate\", event, ui);\n    \t\t\t},\n    \t\t\tdrop: function(event, ui) {\n    \t\t\t\ttree.debug(\"droppable - drop\", event, ui);\n    \t\t\t},\n    \t\t\tout: function(event, ui) {\n    \t\t\t\ttree.debug(\"droppable - out\", event, ui);\n    \t\t\t},\n    \t\t\tover: function(event, ui) {\n    \t\t\t\ttree.debug(\"droppable - over\", event, ui);\n    \t\t\t}\n    */\n\t\t\t}, tree.options.dnd.droppable));\n\t\t}\n\t}\n\n\t/* *****************************************************************************\n  *\n  */\n\n\t$.ui.fancytree.registerExtension({\n\t\tname: \"dnd\",\n\t\tversion: \"2.21.0\",\n\t\t// Default options for this extension.\n\t\toptions: {\n\t\t\t// Make tree nodes accept draggables\n\t\t\tautoExpandMS: 1000, // Expand nodes after n milliseconds of hovering.\n\t\t\tdraggable: null, // Additional options passed to jQuery draggable\n\t\t\tdroppable: null, // Additional options passed to jQuery droppable\n\t\t\tfocusOnClick: false, // Focus, although draggable cancels mousedown event (#270)\n\t\t\tpreventVoidMoves: true, // Prevent dropping nodes 'before self', etc.\n\t\t\tpreventRecursiveMoves: true, // Prevent dropping nodes on own descendants\n\t\t\tsmartRevert: true, // set draggable.revert = true if drop was rejected\n\t\t\t// Events (drag support)\n\t\t\tdragStart: null, // Callback(sourceNode, data), return true, to enable dnd\n\t\t\tdragStop: null, // Callback(sourceNode, data)\n\t\t\tinitHelper: null, // Callback(sourceNode, data)\n\t\t\tupdateHelper: null, // Callback(sourceNode, data)\n\t\t\t// Events (drop support)\n\t\t\tdragEnter: null, // Callback(targetNode, data)\n\t\t\tdragOver: null, // Callback(targetNode, data)\n\t\t\tdragExpand: null, // Callback(targetNode, data), return false to prevent autoExpand\n\t\t\tdragDrop: null, // Callback(targetNode, data)\n\t\t\tdragLeave: null // Callback(targetNode, data)\n\t\t},\n\n\t\ttreeInit: function treeInit(ctx) {\n\t\t\tvar tree = ctx.tree;\n\t\t\tthis._superApply(arguments);\n\t\t\t// issue #270: draggable eats mousedown events\n\t\t\tif (tree.options.dnd.dragStart) {\n\t\t\t\ttree.$container.on(\"mousedown\", function (event) {\n\t\t\t\t\t//\t\t\t\tif( !tree.hasFocus() && ctx.options.dnd.focusOnClick ) {\n\t\t\t\t\tif (ctx.options.dnd.focusOnClick) {\n\t\t\t\t\t\t// #270\n\t\t\t\t\t\tvar node = $.ui.fancytree.getNode(event);\n\t\t\t\t\t\tif (node) {\n\t\t\t\t\t\t\tnode.debug(\"Re-enable focus that was prevented by jQuery UI draggable.\");\n\t\t\t\t\t\t\t// node.setFocus();\n\t\t\t\t\t\t\t// $(node.span).closest(\":tabbable\").focus();\n\t\t\t\t\t\t\t// $(event.target).trigger(\"focus\");\n\t\t\t\t\t\t\t// $(event.target).closest(\":tabbable\").trigger(\"focus\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t// #300\n\t\t\t\t\t\t\t$(event.target).closest(\":tabbable\").focus();\n\t\t\t\t\t\t}, 10);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t_initDragAndDrop(tree);\n\t\t},\n\t\t/* Display drop marker according to hitMode ('after', 'before', 'over'). */\n\t\t_setDndStatus: function _setDndStatus(sourceNode, targetNode, helper, hitMode, accept) {\n\t\t\tvar markerOffsetX,\n\t\t\t    markerAt = \"center\",\n\t\t\t    instData = this._local,\n\t\t\t    glyph = this.options.glyph || null,\n\t\t\t    $source = sourceNode ? $(sourceNode.span) : null,\n\t\t\t    $target = $(targetNode.span),\n\t\t\t    $targetTitle = $target.find(\">span.fancytree-title\");\n\n\t\t\tif (!instData.$dropMarker) {\n\t\t\t\tinstData.$dropMarker = $(\"<div id='fancytree-drop-marker'></div>\").hide().css({ \"z-index\": 1000 }).prependTo($(this.$div).parent());\n\t\t\t\t//                .prependTo(\"body\");\n\n\t\t\t\tif (glyph) {\n\t\t\t\t\t// instData.$dropMarker.addClass(glyph.map.dragHelper);\n\t\t\t\t\tinstData.$dropMarker.addClass(glyph.map.dropMarker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hitMode === \"after\" || hitMode === \"before\" || hitMode === \"over\") {\n\t\t\t\tmarkerOffsetX = -24;\n\t\t\t\tswitch (hitMode) {\n\t\t\t\t\tcase \"before\":\n\t\t\t\t\t\tmarkerAt = \"top\";\n\t\t\t\t\t\tmarkerOffsetX -= 16;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"after\":\n\t\t\t\t\t\tmarkerAt = \"bottom\";\n\t\t\t\t\t\tmarkerOffsetX -= 16;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinstData.$dropMarker.toggleClass(classDropAfter, hitMode === \"after\").toggleClass(classDropOver, hitMode === \"over\").toggleClass(classDropBefore, hitMode === \"before\").show().position($.ui.fancytree.fixPositionOptions({\n\t\t\t\t\tmy: \"left\" + offsetString(markerOffsetX) + \" center\",\n\t\t\t\t\tat: \"left \" + markerAt,\n\t\t\t\t\tof: $targetTitle\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinstData.$dropMarker.hide();\n\t\t\t}\n\t\t\tif ($source) {\n\t\t\t\t$source.toggleClass(classDropAccept, accept === true).toggleClass(classDropReject, accept === false);\n\t\t\t}\n\t\t\t$target.toggleClass(classDropTarget, hitMode === \"after\" || hitMode === \"before\" || hitMode === \"over\").toggleClass(classDropAfter, hitMode === \"after\").toggleClass(classDropBefore, hitMode === \"before\").toggleClass(classDropAccept, accept === true).toggleClass(classDropReject, accept === false);\n\n\t\t\thelper.toggleClass(classDropAccept, accept === true).toggleClass(classDropReject, accept === false);\n\t\t},\n\n\t\t/*\n   * Handles drag'n'drop functionality.\n   *\n   * A standard jQuery drag-and-drop process may generate these calls:\n   *\n   * start:\n   *     _onDragEvent(\"start\", sourceNode, null, event, ui, draggable);\n   * drag:\n   *     _onDragEvent(\"leave\", prevTargetNode, sourceNode, event, ui, draggable);\n   *     _onDragEvent(\"over\", targetNode, sourceNode, event, ui, draggable);\n   *     _onDragEvent(\"enter\", targetNode, sourceNode, event, ui, draggable);\n   * stop:\n   *     _onDragEvent(\"drop\", targetNode, sourceNode, event, ui, draggable);\n   *     _onDragEvent(\"leave\", targetNode, sourceNode, event, ui, draggable);\n   *     _onDragEvent(\"stop\", sourceNode, null, event, ui, draggable);\n   */\n\t\t_onDragEvent: function _onDragEvent(eventName, node, otherNode, event, ui, draggable) {\n\t\t\t// if(eventName !== \"over\"){\n\t\t\t// \tthis.debug(\"tree.ext.dnd._onDragEvent(%s, %o, %o) - %o\", eventName, node, otherNode, this);\n\t\t\t// }\n\t\t\tvar accept,\n\t\t\t    nodeOfs,\n\t\t\t    parentRect,\n\t\t\t    rect,\n\t\t\t    relPos,\n\t\t\t    relPos2,\n\t\t\t    enterResponse,\n\t\t\t    hitMode,\n\t\t\t    r,\n\t\t\t    opts = this.options,\n\t\t\t    dnd = opts.dnd,\n\t\t\t    ctx = this._makeHookContext(node, event, { otherNode: otherNode, ui: ui, draggable: draggable }),\n\t\t\t    res = null,\n\t\t\t    that = this,\n\t\t\t    $nodeTag = $(node.span);\n\n\t\t\tif (dnd.smartRevert) {\n\t\t\t\tdraggable.options.revert = \"invalid\";\n\t\t\t}\n\n\t\t\tswitch (eventName) {\n\n\t\t\t\tcase \"start\":\n\t\t\t\t\tif (node.isStatusNode()) {\n\t\t\t\t\t\tres = false;\n\t\t\t\t\t} else if (dnd.dragStart) {\n\t\t\t\t\t\tres = dnd.dragStart(node, ctx);\n\t\t\t\t\t}\n\t\t\t\t\tif (res === false) {\n\t\t\t\t\t\tthis.debug(\"tree.dragStart() cancelled\");\n\t\t\t\t\t\t//draggable._clear();\n\t\t\t\t\t\t// NOTE: the return value seems to be ignored (drag is not cancelled, when false is returned)\n\t\t\t\t\t\t// TODO: call this._cancelDrag()?\n\t\t\t\t\t\tui.helper.trigger(\"mouseup\").hide();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dnd.smartRevert) {\n\t\t\t\t\t\t\t// #567, #593: fix revert position\n\t\t\t\t\t\t\t// rect = node.li.getBoundingClientRect();\n\t\t\t\t\t\t\trect = node[ctx.tree.nodeContainerAttrName].getBoundingClientRect();\n\t\t\t\t\t\t\tparentRect = $(draggable.options.appendTo)[0].getBoundingClientRect();\n\t\t\t\t\t\t\tdraggable.originalPosition.left = Math.max(0, rect.left - parentRect.left);\n\t\t\t\t\t\t\tdraggable.originalPosition.top = Math.max(0, rect.top - parentRect.top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$nodeTag.addClass(\"fancytree-drag-source\");\n\t\t\t\t\t\t// Register global handlers to allow cancel\n\t\t\t\t\t\t$(document).on(\"keydown.fancytree-dnd,mousedown.fancytree-dnd\", function (event) {\n\t\t\t\t\t\t\t// node.tree.debug(\"dnd global event\", event.type, event.which);\n\t\t\t\t\t\t\tif (event.type === \"keydown\" && event.which === $.ui.keyCode.ESCAPE) {\n\t\t\t\t\t\t\t\tthat.ext.dnd._cancelDrag();\n\t\t\t\t\t\t\t} else if (event.type === \"mousedown\") {\n\t\t\t\t\t\t\t\tthat.ext.dnd._cancelDrag();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"enter\":\n\t\t\t\t\tif (dnd.preventRecursiveMoves && node.isDescendantOf(otherNode)) {\n\t\t\t\t\t\tr = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr = dnd.dragEnter ? dnd.dragEnter(node, ctx) : null;\n\t\t\t\t\t}\n\t\t\t\t\tif (!r) {\n\t\t\t\t\t\t// convert null, undefined, false to false\n\t\t\t\t\t\tres = false;\n\t\t\t\t\t} else if ($.isArray(r)) {\n\t\t\t\t\t\t// TODO: also accept passing an object of this format directly\n\t\t\t\t\t\tres = {\n\t\t\t\t\t\t\tover: $.inArray(\"over\", r) >= 0,\n\t\t\t\t\t\t\tbefore: $.inArray(\"before\", r) >= 0,\n\t\t\t\t\t\t\tafter: $.inArray(\"after\", r) >= 0\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres = {\n\t\t\t\t\t\t\tover: r === true || r === \"over\",\n\t\t\t\t\t\t\tbefore: r === true || r === \"before\",\n\t\t\t\t\t\t\tafter: r === true || r === \"after\"\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tui.helper.data(\"enterResponse\", res);\n\t\t\t\t\t// this.debug(\"helper.enterResponse: %o\", res);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"over\":\n\t\t\t\t\tenterResponse = ui.helper.data(\"enterResponse\");\n\t\t\t\t\thitMode = null;\n\t\t\t\t\tif (enterResponse === false) {\n\t\t\t\t\t\t// Don't call dragOver if onEnter returned false.\n\t\t\t\t\t\t//                break;\n\t\t\t\t\t} else if (typeof enterResponse === \"string\") {\n\t\t\t\t\t\t// Use hitMode from onEnter if provided.\n\t\t\t\t\t\thitMode = enterResponse;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Calculate hitMode from relative cursor position.\n\t\t\t\t\t\tnodeOfs = $nodeTag.offset();\n\t\t\t\t\t\trelPos = { x: event.pageX - nodeOfs.left,\n\t\t\t\t\t\t\ty: event.pageY - nodeOfs.top };\n\t\t\t\t\t\trelPos2 = { x: relPos.x / $nodeTag.width(),\n\t\t\t\t\t\t\ty: relPos.y / $nodeTag.height() };\n\n\t\t\t\t\t\tif (enterResponse.after && relPos2.y > 0.75) {\n\t\t\t\t\t\t\thitMode = \"after\";\n\t\t\t\t\t\t} else if (!enterResponse.over && enterResponse.after && relPos2.y > 0.5) {\n\t\t\t\t\t\t\thitMode = \"after\";\n\t\t\t\t\t\t} else if (enterResponse.before && relPos2.y <= 0.25) {\n\t\t\t\t\t\t\thitMode = \"before\";\n\t\t\t\t\t\t} else if (!enterResponse.over && enterResponse.before && relPos2.y <= 0.5) {\n\t\t\t\t\t\t\thitMode = \"before\";\n\t\t\t\t\t\t} else if (enterResponse.over) {\n\t\t\t\t\t\t\thitMode = \"over\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Prevent no-ops like 'before source node'\n\t\t\t\t\t\t// TODO: these are no-ops when moving nodes, but not in copy mode\n\t\t\t\t\t\tif (dnd.preventVoidMoves) {\n\t\t\t\t\t\t\tif (node === otherNode) {\n\t\t\t\t\t\t\t\tthis.debug(\"    drop over source node prevented\");\n\t\t\t\t\t\t\t\thitMode = null;\n\t\t\t\t\t\t\t} else if (hitMode === \"before\" && otherNode && node === otherNode.getNextSibling()) {\n\t\t\t\t\t\t\t\tthis.debug(\"    drop after source node prevented\");\n\t\t\t\t\t\t\t\thitMode = null;\n\t\t\t\t\t\t\t} else if (hitMode === \"after\" && otherNode && node === otherNode.getPrevSibling()) {\n\t\t\t\t\t\t\t\tthis.debug(\"    drop before source node prevented\");\n\t\t\t\t\t\t\t\thitMode = null;\n\t\t\t\t\t\t\t} else if (hitMode === \"over\" && otherNode && otherNode.parent === node && otherNode.isLastSibling()) {\n\t\t\t\t\t\t\t\tthis.debug(\"    drop last child over own parent prevented\");\n\t\t\t\t\t\t\t\thitMode = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//                this.debug(\"hitMode: %s - %s - %s\", hitMode, (node.parent === otherNode), node.isLastSibling());\n\t\t\t\t\t\tui.helper.data(\"hitMode\", hitMode);\n\t\t\t\t\t}\n\t\t\t\t\t// Auto-expand node (only when 'over' the node, not 'before', or 'after')\n\t\t\t\t\tif (hitMode !== \"before\" && hitMode !== \"after\" && dnd.autoExpandMS && node.hasChildren() !== false && !node.expanded && (!dnd.dragExpand || dnd.dragExpand(node, ctx) !== false)) {\n\t\t\t\t\t\tnode.scheduleAction(\"expand\", dnd.autoExpandMS);\n\t\t\t\t\t}\n\t\t\t\t\tif (hitMode && dnd.dragOver) {\n\t\t\t\t\t\t// TODO: http://code.google.com/p/dynatree/source/detail?r=625\n\t\t\t\t\t\tctx.hitMode = hitMode;\n\t\t\t\t\t\tres = dnd.dragOver(node, ctx);\n\t\t\t\t\t}\n\t\t\t\t\taccept = res !== false && hitMode !== null;\n\t\t\t\t\tif (dnd.smartRevert) {\n\t\t\t\t\t\tdraggable.options.revert = !accept;\n\t\t\t\t\t}\n\t\t\t\t\tthis._local._setDndStatus(otherNode, node, ui.helper, hitMode, accept);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"drop\":\n\t\t\t\t\thitMode = ui.helper.data(\"hitMode\");\n\t\t\t\t\tif (hitMode && dnd.dragDrop) {\n\t\t\t\t\t\tctx.hitMode = hitMode;\n\t\t\t\t\t\tdnd.dragDrop(node, ctx);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"leave\":\n\t\t\t\t\t// Cancel pending expand request\n\t\t\t\t\tnode.scheduleAction(\"cancel\");\n\t\t\t\t\tui.helper.data(\"enterResponse\", null);\n\t\t\t\t\tui.helper.data(\"hitMode\", null);\n\t\t\t\t\tthis._local._setDndStatus(otherNode, node, ui.helper, \"out\", undefined);\n\t\t\t\t\tif (dnd.dragLeave) {\n\t\t\t\t\t\tdnd.dragLeave(node, ctx);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"stop\":\n\t\t\t\t\t$nodeTag.removeClass(\"fancytree-drag-source\");\n\t\t\t\t\t$(document).off(\".fancytree-dnd\");\n\t\t\t\t\tif (dnd.dragStop) {\n\t\t\t\t\t\tdnd.dragStop(node, ctx);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t$.error(\"Unsupported drag event: \" + eventName);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\n\t\t_cancelDrag: function _cancelDrag() {\n\t\t\tvar dd = $.ui.ddmanager.current;\n\t\t\tif (dd) {\n\t\t\t\tdd.cancel();\n\t\t\t}\n\t\t}\n\t});\n})(jQuery, window, document);\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/bower_components/fancytree/dist/src/jquery.fancytree.dnd.js?");

/***/ }),

/***/ "../../../bower_components/fancytree/dist/src/jquery.fancytree.js":
/*!*******************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/bower_components/fancytree/dist/src/jquery.fancytree.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * jquery.fancytree.js\n * Tree view control with support for lazy loading and much more.\n * https://github.com/mar10/fancytree/\n *\n * Copyright (c) 2008-2017, Martin Wendt (http://wwWendt.de)\n * Released under the MIT license\n * https://github.com/mar10/fancytree/wiki/LicenseInfo\n *\n * @version 2.21.0\n * @date 2017-01-15T17:21:28Z\n */\n\n/** Core Fancytree module.\n */\n\n// Start of local namespace\n;(function ($, window, document, undefined) {\n\t\"use strict\";\n\n\t// prevent duplicate loading\n\n\tif ($.ui && $.ui.fancytree) {\n\t\t$.ui.fancytree.warn(\"Fancytree: ignored duplicate include\");\n\t\treturn;\n\t}\n\n\t/* *****************************************************************************\n  * Private functions and variables\n  */\n\n\tvar i,\n\t    attr,\n\t    FT = null,\n\t    // initialized below\n\tTEST_IMG = new RegExp(/\\.|\\//),\n\t    // strings are considered image urls if they conatin '.' or '/'\n\tREX_HTML = /[&<>\"'\\/]/g,\n\t    REX_TOOLTIP = /[<>\"'\\/]/g,\n\t    RECURSIVE_REQUEST_ERROR = \"$recursive_request\",\n\t    ENTITY_MAP = { \"&\": \"&amp;\", \"<\": \"&lt;\", \">\": \"&gt;\", \"\\\"\": \"&quot;\", \"'\": \"&#39;\", \"/\": \"&#x2F;\" },\n\t    IGNORE_KEYCODES = { 16: true, 17: true, 18: true },\n\t    SPECIAL_KEYCODES = {\n\t\t8: \"backspace\", 9: \"tab\", 10: \"return\", 13: \"return\",\n\t\t// 16: null, 17: null, 18: null, // ignore shift, ctrl, alt\n\t\t19: \"pause\", 20: \"capslock\", 27: \"esc\", 32: \"space\", 33: \"pageup\",\n\t\t34: \"pagedown\", 35: \"end\", 36: \"home\", 37: \"left\", 38: \"up\",\n\t\t39: \"right\", 40: \"down\", 45: \"insert\", 46: \"del\", 59: \";\", 61: \"=\",\n\t\t96: \"0\", 97: \"1\", 98: \"2\", 99: \"3\", 100: \"4\", 101: \"5\", 102: \"6\",\n\t\t103: \"7\", 104: \"8\", 105: \"9\", 106: \"*\", 107: \"+\", 109: \"-\", 110: \".\",\n\t\t111: \"/\", 112: \"f1\", 113: \"f2\", 114: \"f3\", 115: \"f4\", 116: \"f5\",\n\t\t117: \"f6\", 118: \"f7\", 119: \"f8\", 120: \"f9\", 121: \"f10\", 122: \"f11\",\n\t\t123: \"f12\", 144: \"numlock\", 145: \"scroll\", 173: \"-\", 186: \";\", 187: \"=\",\n\t\t188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t\t221: \"]\", 222: \"'\" },\n\t    MOUSE_BUTTONS = { 0: \"\", 1: \"left\", 2: \"middle\", 3: \"right\" },\n\n\t//boolean attributes that can be set with equivalent class names in the LI tags\n\tCLASS_ATTRS = \"active expanded focus folder hideCheckbox lazy selected unselectable\".split(\" \"),\n\t    CLASS_ATTR_MAP = {},\n\n\t//\tTop-level Fancytree node attributes, that can be set by dict\n\tNODE_ATTRS = \"expanded extraClasses folder hideCheckbox icon key lazy refKey selected statusNodeType title tooltip unselectable\".split(\" \"),\n\t    NODE_ATTR_MAP = {},\n\n\t// Mapping of lowercase -> real name (because HTML5 data-... attribute only supports lowercase)\n\tNODE_ATTR_LOWERCASE_MAP = {},\n\n\t// Attribute names that should NOT be added to node.data\n\tNONE_NODE_DATA_MAP = { \"active\": true, \"children\": true, \"data\": true, \"focus\": true };\n\n\tfor (i = 0; i < CLASS_ATTRS.length; i++) {\n\t\tCLASS_ATTR_MAP[CLASS_ATTRS[i]] = true;\n\t}\n\tfor (i = 0; i < NODE_ATTRS.length; i++) {\n\t\tattr = NODE_ATTRS[i];\n\t\tNODE_ATTR_MAP[attr] = true;\n\t\tif (attr !== attr.toLowerCase()) {\n\t\t\tNODE_ATTR_LOWERCASE_MAP[attr.toLowerCase()] = attr;\n\t\t}\n\t}\n\n\tfunction _assert(cond, msg) {\n\t\t// TODO: see qunit.js extractStacktrace()\n\t\tif (!cond) {\n\t\t\tmsg = msg ? \": \" + msg : \"\";\n\t\t\t// consoleApply(\"assert\", [!!cond, msg]);\n\t\t\t$.error(\"Fancytree assertion failed\" + msg);\n\t\t}\n\t}\n\n\t_assert($.ui, \"Fancytree requires jQuery UI (http://jqueryui.com)\");\n\n\tfunction consoleApply(method, args) {\n\t\tvar i,\n\t\t    s,\n\t\t    fn = window.console ? window.console[method] : null;\n\n\t\tif (fn) {\n\t\t\ttry {\n\t\t\t\tfn.apply(window.console, args);\n\t\t\t} catch (e) {\n\t\t\t\t// IE 8?\n\t\t\t\ts = \"\";\n\t\t\t\tfor (i = 0; i < args.length; i++) {\n\t\t\t\t\ts += args[i];\n\t\t\t\t}\n\t\t\t\tfn(s);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*Return true if x is a FancytreeNode.*/\n\tfunction _isNode(x) {\n\t\treturn !!(x.tree && x.statusNodeType !== undefined);\n\t}\n\n\t/** Return true if dotted version string is equal or higher than requested version.\n  *\n  * See http://jsfiddle.net/mar10/FjSAN/\n  */\n\tfunction isVersionAtLeast(dottedVersion, major, minor, patch) {\n\t\tvar i,\n\t\t    v,\n\t\t    t,\n\t\t    verParts = $.map($.trim(dottedVersion).split(\".\"), function (e) {\n\t\t\treturn parseInt(e, 10);\n\t\t}),\n\t\t    testParts = $.map(Array.prototype.slice.call(arguments, 1), function (e) {\n\t\t\treturn parseInt(e, 10);\n\t\t});\n\n\t\tfor (i = 0; i < testParts.length; i++) {\n\t\t\tv = verParts[i] || 0;\n\t\t\tt = testParts[i] || 0;\n\t\t\tif (v !== t) {\n\t\t\t\treturn v > t;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/** Return a wrapper that calls sub.methodName() and exposes\n  *  this        : tree\n  *  this._local : tree.ext.EXTNAME\n  *  this._super : base.methodName()\n  */\n\tfunction _makeVirtualFunction(methodName, tree, base, extension, extName) {\n\t\t// $.ui.fancytree.debug(\"_makeVirtualFunction\", methodName, tree, base, extension, extName);\n\t\t// if(rexTestSuper && !rexTestSuper.test(func)){\n\t\t//     // extension.methodName() doesn't call _super(), so no wrapper required\n\t\t//     return func;\n\t\t// }\n\t\t// Use an immediate function as closure\n\t\tvar proxy = function () {\n\t\t\tvar prevFunc = tree[methodName],\n\t\t\t    // org. tree method or prev. proxy\n\t\t\tbaseFunc = extension[methodName],\n\t\t\t    //\n\t\t\t_local = tree.ext[extName],\n\t\t\t    _super = function _super() {\n\t\t\t\treturn prevFunc.apply(tree, arguments);\n\t\t\t},\n\t\t\t    _superApply = function _superApply(args) {\n\t\t\t\treturn prevFunc.apply(tree, args);\n\t\t\t};\n\n\t\t\t// Return the wrapper function\n\t\t\treturn function () {\n\t\t\t\tvar prevLocal = tree._local,\n\t\t\t\t    prevSuper = tree._super,\n\t\t\t\t    prevSuperApply = tree._superApply;\n\n\t\t\t\ttry {\n\t\t\t\t\ttree._local = _local;\n\t\t\t\t\ttree._super = _super;\n\t\t\t\t\ttree._superApply = _superApply;\n\t\t\t\t\treturn baseFunc.apply(tree, arguments);\n\t\t\t\t} finally {\n\t\t\t\t\ttree._local = prevLocal;\n\t\t\t\t\ttree._super = prevSuper;\n\t\t\t\t\ttree._superApply = prevSuperApply;\n\t\t\t\t}\n\t\t\t};\n\t\t}(); // end of Immediate Function\n\t\treturn proxy;\n\t}\n\n\t/**\n  * Subclass `base` by creating proxy functions\n  */\n\tfunction _subclassObject(tree, base, extension, extName) {\n\t\t// $.ui.fancytree.debug(\"_subclassObject\", tree, base, extension, extName);\n\t\tfor (var attrName in extension) {\n\t\t\tif (typeof extension[attrName] === \"function\") {\n\t\t\t\tif (typeof tree[attrName] === \"function\") {\n\t\t\t\t\t// override existing method\n\t\t\t\t\ttree[attrName] = _makeVirtualFunction(attrName, tree, base, extension, extName);\n\t\t\t\t} else if (attrName.charAt(0) === \"_\") {\n\t\t\t\t\t// Create private methods in tree.ext.EXTENSION namespace\n\t\t\t\t\ttree.ext[extName][attrName] = _makeVirtualFunction(attrName, tree, base, extension, extName);\n\t\t\t\t} else {\n\t\t\t\t\t$.error(\"Could not override tree.\" + attrName + \". Use prefix '_' to create tree.\" + extName + \"._\" + attrName);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create member variables in tree.ext.EXTENSION namespace\n\t\t\t\tif (attrName !== \"options\") {\n\t\t\t\t\ttree.ext[extName][attrName] = extension[attrName];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _getResolvedPromise(context, argArray) {\n\t\tif (context === undefined) {\n\t\t\treturn $.Deferred(function () {\n\t\t\t\tthis.resolve();\n\t\t\t}).promise();\n\t\t} else {\n\t\t\treturn $.Deferred(function () {\n\t\t\t\tthis.resolveWith(context, argArray);\n\t\t\t}).promise();\n\t\t}\n\t}\n\n\tfunction _getRejectedPromise(context, argArray) {\n\t\tif (context === undefined) {\n\t\t\treturn $.Deferred(function () {\n\t\t\t\tthis.reject();\n\t\t\t}).promise();\n\t\t} else {\n\t\t\treturn $.Deferred(function () {\n\t\t\t\tthis.rejectWith(context, argArray);\n\t\t\t}).promise();\n\t\t}\n\t}\n\n\tfunction _makeResolveFunc(deferred, context) {\n\t\treturn function () {\n\t\t\tdeferred.resolveWith(context);\n\t\t};\n\t}\n\n\tfunction _getElementDataAsDict($el) {\n\t\t// Evaluate 'data-NAME' attributes with special treatment for 'data-json'.\n\t\tvar d = $.extend({}, $el.data()),\n\t\t    json = d.json;\n\n\t\tdelete d.fancytree; // added to container by widget factory (old jQuery UI)\n\t\tdelete d.uiFancytree; // added to container by widget factory\n\n\t\tif (json) {\n\t\t\tdelete d.json;\n\t\t\t// <li data-json='...'> is already returned as object (http://api.jquery.com/data/#data-html5)\n\t\t\td = $.extend(d, json);\n\t\t}\n\t\treturn d;\n\t}\n\n\tfunction _escapeHtml(s) {\n\t\treturn (\"\" + s).replace(REX_HTML, function (s) {\n\t\t\treturn ENTITY_MAP[s];\n\t\t});\n\t}\n\n\tfunction _escapeTooltip(s) {\n\t\treturn (\"\" + s).replace(REX_TOOLTIP, function (s) {\n\t\t\treturn ENTITY_MAP[s];\n\t\t});\n\t}\n\n\t// TODO: use currying\n\tfunction _makeNodeTitleMatcher(s) {\n\t\ts = s.toLowerCase();\n\t\treturn function (node) {\n\t\t\treturn node.title.toLowerCase().indexOf(s) >= 0;\n\t\t};\n\t}\n\n\tfunction _makeNodeTitleStartMatcher(s) {\n\t\tvar reMatch = new RegExp(\"^\" + s, \"i\");\n\t\treturn function (node) {\n\t\t\treturn reMatch.test(node.title);\n\t\t};\n\t}\n\n\t/* *****************************************************************************\n  * FancytreeNode\n  */\n\n\t/**\n  * Creates a new FancytreeNode\n  *\n  * @class FancytreeNode\n  * @classdesc A FancytreeNode represents the hierarchical data model and operations.\n  *\n  * @param {FancytreeNode} parent\n  * @param {NodeData} obj\n  *\n  * @property {Fancytree} tree The tree instance\n  * @property {FancytreeNode} parent The parent node\n  * @property {string} key Node id (must be unique inside the tree)\n  * @property {string} title Display name (may contain HTML)\n  * @property {object} data Contains all extra data that was passed on node creation\n  * @property {FancytreeNode[] | null | undefined} children Array of child nodes.<br>\n  *     For lazy nodes, null or undefined means 'not yet loaded'. Use an empty array\n  *     to define a node that has no children.\n  * @property {boolean} expanded Use isExpanded(), setExpanded() to access this property.\n  * @property {string} extraClasses Additional CSS classes, added to the node's `&lt;span>`.<br>\n  *     Note: use `node.add/remove/toggleClass()` to modify.\n  * @property {boolean} folder Folder nodes have different default icons and click behavior.<br>\n  *     Note: Also non-folders may have children.\n  * @property {string} statusNodeType null for standard nodes. Otherwise type of special system node: 'error', 'loading', 'nodata', or 'paging'.\n  * @property {boolean} lazy True if this node is loaded on demand, i.e. on first expansion.\n  * @property {boolean} selected Use isSelected(), setSelected() to access this property.\n  * @property {string} tooltip Alternative description used as hover popup\n  */\n\tfunction FancytreeNode(parent, obj) {\n\t\tvar i, l, name, cl;\n\n\t\tthis.parent = parent;\n\t\tthis.tree = parent.tree;\n\t\tthis.ul = null;\n\t\tthis.li = null; // <li id='key' ftnode=this> tag\n\t\tthis.statusNodeType = null; // if this is a temp. node to display the status of its parent\n\t\tthis._isLoading = false; // if this node itself is loading\n\t\tthis._error = null; // {message: '...'} if a load error occurred\n\t\tthis.data = {};\n\n\t\t// TODO: merge this code with node.toDict()\n\t\t// copy attributes from obj object\n\t\tfor (i = 0, l = NODE_ATTRS.length; i < l; i++) {\n\t\t\tname = NODE_ATTRS[i];\n\t\t\tthis[name] = obj[name];\n\t\t}\n\t\t// node.data += obj.data\n\t\tif (obj.data) {\n\t\t\t$.extend(this.data, obj.data);\n\t\t}\n\t\t// copy all other attributes to this.data.NAME\n\t\tfor (name in obj) {\n\t\t\tif (!NODE_ATTR_MAP[name] && !$.isFunction(obj[name]) && !NONE_NODE_DATA_MAP[name]) {\n\t\t\t\t// node.data.NAME = obj.NAME\n\t\t\t\tthis.data[name] = obj[name];\n\t\t\t}\n\t\t}\n\n\t\t// Fix missing key\n\t\tif (this.key == null) {\n\t\t\t// test for null OR undefined\n\t\t\tif (this.tree.options.defaultKey) {\n\t\t\t\tthis.key = this.tree.options.defaultKey(this);\n\t\t\t\t_assert(this.key, \"defaultKey() must return a unique key\");\n\t\t\t} else {\n\t\t\t\tthis.key = \"_\" + FT._nextNodeKey++;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.key = \"\" + this.key; // Convert to string (#217)\n\t\t}\n\n\t\t// Fix tree.activeNode\n\t\t// TODO: not elegant: we use obj.active as marker to set tree.activeNode\n\t\t// when loading from a dictionary.\n\t\tif (obj.active) {\n\t\t\t_assert(this.tree.activeNode === null, \"only one active node allowed\");\n\t\t\tthis.tree.activeNode = this;\n\t\t}\n\t\tif (obj.selected) {\n\t\t\t// #186\n\t\t\tthis.tree.lastSelectedNode = this;\n\t\t}\n\t\t// TODO: handle obj.focus = true\n\t\t// Create child nodes\n\t\tcl = obj.children;\n\t\tif (cl) {\n\t\t\tif (cl.length) {\n\t\t\t\tthis._setChildren(cl);\n\t\t\t} else {\n\t\t\t\t// if an empty array was passed for a lazy node, keep it, in order to mark it 'loaded'\n\t\t\t\tthis.children = this.lazy ? [] : null;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.children = null;\n\t\t}\n\t\t// Add to key/ref map (except for root node)\n\t\t//\tif( parent ) {\n\t\tthis.tree._callHook(\"treeRegisterNode\", this.tree, true, this);\n\t\t//\t}\n\t}\n\n\tFancytreeNode.prototype = /** @lends FancytreeNode# */{\n\t\t/* Return the direct child FancytreeNode with a given key, index. */\n\t\t_findDirectChild: function _findDirectChild(ptr) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    cl = this.children;\n\n\t\t\tif (cl) {\n\t\t\t\tif (typeof ptr === \"string\") {\n\t\t\t\t\tfor (i = 0, l = cl.length; i < l; i++) {\n\t\t\t\t\t\tif (cl[i].key === ptr) {\n\t\t\t\t\t\t\treturn cl[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof ptr === \"number\") {\n\t\t\t\t\treturn this.children[ptr];\n\t\t\t\t} else if (ptr.parent === this) {\n\t\t\t\t\treturn ptr;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t// TODO: activate()\n\t\t// TODO: activateSilently()\n\t\t/* Internal helper called in recursive addChildren sequence.*/\n\t\t_setChildren: function _setChildren(children) {\n\t\t\t_assert(children && (!this.children || this.children.length === 0), \"only init supported\");\n\t\t\tthis.children = [];\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tthis.children.push(new FancytreeNode(this, children[i]));\n\t\t\t}\n\t\t},\n\t\t/**\n   * Append (or insert) a list of child nodes.\n   *\n   * @param {NodeData[]} children array of child node definitions (also single child accepted)\n   * @param {FancytreeNode | string | Integer} [insertBefore] child node (or key or index of such).\n   *     If omitted, the new children are appended.\n   * @returns {FancytreeNode} first child added\n   *\n   * @see FancytreeNode#applyPatch\n   */\n\t\taddChildren: function addChildren(children, insertBefore) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    pos,\n\t\t\t    firstNode = null,\n\t\t\t    nodeList = [];\n\n\t\t\tif ($.isPlainObject(children)) {\n\t\t\t\tchildren = [children];\n\t\t\t}\n\t\t\tif (!this.children) {\n\t\t\t\tthis.children = [];\n\t\t\t}\n\t\t\tfor (i = 0, l = children.length; i < l; i++) {\n\t\t\t\tnodeList.push(new FancytreeNode(this, children[i]));\n\t\t\t}\n\t\t\tfirstNode = nodeList[0];\n\t\t\tif (insertBefore == null) {\n\t\t\t\tthis.children = this.children.concat(nodeList);\n\t\t\t} else {\n\t\t\t\tinsertBefore = this._findDirectChild(insertBefore);\n\t\t\t\tpos = $.inArray(insertBefore, this.children);\n\t\t\t\t_assert(pos >= 0, \"insertBefore must be an existing child\");\n\t\t\t\t// insert nodeList after children[pos]\n\t\t\t\tthis.children.splice.apply(this.children, [pos, 0].concat(nodeList));\n\t\t\t}\n\t\t\tif (!this.parent || this.parent.ul || this.tr) {\n\t\t\t\t// render if the parent was rendered (or this is a root node)\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tif (this.tree.options.selectMode === 3) {\n\t\t\t\tthis.fixSelection3FromEndNodes();\n\t\t\t}\n\t\t\tthis.triggerModifyChild(\"add\", nodeList.length === 1 ? nodeList[0] : null);\n\t\t\treturn firstNode;\n\t\t},\n\t\t/**\n   * Add class to node's span tag and to .extraClasses.\n   *\n   * @param {string} className class name\n   *\n   * @since 2.17\n   */\n\t\taddClass: function addClass(className) {\n\t\t\treturn this.toggleClass(className, true);\n\t\t},\n\t\t/**\n   * Append or prepend a node, or append a child node.\n   *\n   * This a convenience function that calls addChildren()\n   *\n   * @param {NodeData} node node definition\n   * @param {string} [mode=child] 'before', 'after', 'firstChild', or 'child' ('over' is a synonym for 'child')\n   * @returns {FancytreeNode} new node\n   */\n\t\taddNode: function addNode(node, mode) {\n\t\t\tif (mode === undefined || mode === \"over\") {\n\t\t\t\tmode = \"child\";\n\t\t\t}\n\t\t\tswitch (mode) {\n\t\t\t\tcase \"after\":\n\t\t\t\t\treturn this.getParent().addChildren(node, this.getNextSibling());\n\t\t\t\tcase \"before\":\n\t\t\t\t\treturn this.getParent().addChildren(node, this);\n\t\t\t\tcase \"firstChild\":\n\t\t\t\t\t// Insert before the first child if any\n\t\t\t\t\tvar insertBefore = this.children ? this.children[0] : null;\n\t\t\t\t\treturn this.addChildren(node, insertBefore);\n\t\t\t\tcase \"child\":\n\t\t\t\tcase \"over\":\n\t\t\t\t\treturn this.addChildren(node);\n\t\t\t}\n\t\t\t_assert(false, \"Invalid mode: \" + mode);\n\t\t},\n\t\t/**Add child status nodes that indicate 'More...', etc.\n   *\n   * This also maintains the node's `partload` property.\n   * @param {boolean|object} node optional node definition. Pass `false` to remove all paging nodes.\n   * @param {string} [mode='child'] 'child'|firstChild'\n   * @since 2.15\n   */\n\t\taddPagingNode: function addPagingNode(node, mode) {\n\t\t\tvar i, n;\n\n\t\t\tmode = mode || \"child\";\n\t\t\tif (node === false) {\n\t\t\t\tfor (i = this.children.length - 1; i >= 0; i--) {\n\t\t\t\t\tn = this.children[i];\n\t\t\t\t\tif (n.statusNodeType === \"paging\") {\n\t\t\t\t\t\tthis.removeChild(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.partload = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnode = $.extend({\n\t\t\t\ttitle: this.tree.options.strings.moreData,\n\t\t\t\tstatusNodeType: \"paging\",\n\t\t\t\ticon: false\n\t\t\t}, node);\n\t\t\tthis.partload = true;\n\t\t\treturn this.addNode(node, mode);\n\t\t},\n\t\t/**\n   * Append new node after this.\n   *\n   * This a convenience function that calls addNode(node, 'after')\n   *\n   * @param {NodeData} node node definition\n   * @returns {FancytreeNode} new node\n   */\n\t\tappendSibling: function appendSibling(node) {\n\t\t\treturn this.addNode(node, \"after\");\n\t\t},\n\t\t/**\n   * Modify existing child nodes.\n   *\n   * @param {NodePatch} patch\n   * @returns {$.Promise}\n   * @see FancytreeNode#addChildren\n   */\n\t\tapplyPatch: function applyPatch(patch) {\n\t\t\t// patch [key, null] means 'remove'\n\t\t\tif (patch === null) {\n\t\t\t\tthis.remove();\n\t\t\t\treturn _getResolvedPromise(this);\n\t\t\t}\n\t\t\t// TODO: make sure that root node is not collapsed or modified\n\t\t\t// copy (most) attributes to node.ATTR or node.data.ATTR\n\t\t\tvar name,\n\t\t\t    promise,\n\t\t\t    v,\n\t\t\t    IGNORE_MAP = { children: true, expanded: true, parent: true }; // TODO: should be global\n\n\t\t\tfor (name in patch) {\n\t\t\t\tv = patch[name];\n\t\t\t\tif (!IGNORE_MAP[name] && !$.isFunction(v)) {\n\t\t\t\t\tif (NODE_ATTR_MAP[name]) {\n\t\t\t\t\t\tthis[name] = v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.data[name] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Remove and/or create children\n\t\t\tif (patch.hasOwnProperty(\"children\")) {\n\t\t\t\tthis.removeChildren();\n\t\t\t\tif (patch.children) {\n\t\t\t\t\t// only if not null and not empty list\n\t\t\t\t\t// TODO: addChildren instead?\n\t\t\t\t\tthis._setChildren(patch.children);\n\t\t\t\t}\n\t\t\t\t// TODO: how can we APPEND or INSERT child nodes?\n\t\t\t}\n\t\t\tif (this.isVisible()) {\n\t\t\t\tthis.renderTitle();\n\t\t\t\tthis.renderStatus();\n\t\t\t}\n\t\t\t// Expand collapse (final step, since this may be async)\n\t\t\tif (patch.hasOwnProperty(\"expanded\")) {\n\t\t\t\tpromise = this.setExpanded(patch.expanded);\n\t\t\t} else {\n\t\t\t\tpromise = _getResolvedPromise(this);\n\t\t\t}\n\t\t\treturn promise;\n\t\t},\n\t\t/** Collapse all sibling nodes.\n   * @returns {$.Promise}\n   */\n\t\tcollapseSiblings: function collapseSiblings() {\n\t\t\treturn this.tree._callHook(\"nodeCollapseSiblings\", this);\n\t\t},\n\t\t/** Copy this node as sibling or child of `node`.\n   *\n   * @param {FancytreeNode} node source node\n   * @param {string} [mode=child] 'before' | 'after' | 'child'\n   * @param {Function} [map] callback function(NodeData) that could modify the new node\n   * @returns {FancytreeNode} new\n   */\n\t\tcopyTo: function copyTo(node, mode, map) {\n\t\t\treturn node.addNode(this.toDict(true, map), mode);\n\t\t},\n\t\t/** Count direct and indirect children.\n   *\n   * @param {boolean} [deep=true] pass 'false' to only count direct children\n   * @returns {int} number of child nodes\n   */\n\t\tcountChildren: function countChildren(deep) {\n\t\t\tvar cl = this.children,\n\t\t\t    i,\n\t\t\t    l,\n\t\t\t    n;\n\t\t\tif (!cl) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tn = cl.length;\n\t\t\tif (deep !== false) {\n\t\t\t\tfor (i = 0, l = n; i < l; i++) {\n\t\t\t\t\tn += cl[i].countChildren();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n;\n\t\t},\n\t\t// TODO: deactivate()\n\t\t/** Write to browser console if debugLevel >= 2 (prepending node info)\n   *\n   * @param {*} msg string or object or array of such\n   */\n\t\tdebug: function debug(msg) {\n\t\t\tif (this.tree.options.debugLevel >= 2) {\n\t\t\t\tArray.prototype.unshift.call(arguments, this.toString());\n\t\t\t\tconsoleApply(\"log\", arguments);\n\t\t\t}\n\t\t},\n\t\t/** Deprecated.\n   * @deprecated since 2014-02-16. Use resetLazy() instead.\n   */\n\t\tdiscard: function discard() {\n\t\t\tthis.warn(\"FancytreeNode.discard() is deprecated since 2014-02-16. Use .resetLazy() instead.\");\n\t\t\treturn this.resetLazy();\n\t\t},\n\t\t/** Remove DOM elements for all descendents. May be called on .collapse event\n   * to keep the DOM small.\n   * @param {boolean} [includeSelf=false]\n   */\n\t\tdiscardMarkup: function discardMarkup(includeSelf) {\n\t\t\tvar fn = includeSelf ? \"nodeRemoveMarkup\" : \"nodeRemoveChildMarkup\";\n\t\t\tthis.tree._callHook(fn, this);\n\t\t},\n\t\t/**Find all nodes that match condition (excluding self).\n   *\n   * @param {string | function(node)} match title string to search for, or a\n   *     callback function that returns `true` if a node is matched.\n   * @returns {FancytreeNode[]} array of nodes (may be empty)\n   */\n\t\tfindAll: function findAll(match) {\n\t\t\tmatch = $.isFunction(match) ? match : _makeNodeTitleMatcher(match);\n\t\t\tvar res = [];\n\t\t\tthis.visit(function (n) {\n\t\t\t\tif (match(n)) {\n\t\t\t\t\tres.push(n);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn res;\n\t\t},\n\t\t/**Find first node that matches condition (excluding self).\n   *\n   * @param {string | function(node)} match title string to search for, or a\n   *     callback function that returns `true` if a node is matched.\n   * @returns {FancytreeNode} matching node or null\n   * @see FancytreeNode#findAll\n   */\n\t\tfindFirst: function findFirst(match) {\n\t\t\tmatch = $.isFunction(match) ? match : _makeNodeTitleMatcher(match);\n\t\t\tvar res = null;\n\t\t\tthis.visit(function (n) {\n\t\t\t\tif (match(n)) {\n\t\t\t\t\tres = n;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn res;\n\t\t},\n\t\t/* Apply selection state (internal use only) */\n\t\t_changeSelectStatusAttrs: function _changeSelectStatusAttrs(state) {\n\t\t\tvar changed = false;\n\n\t\t\tswitch (state) {\n\t\t\t\tcase false:\n\t\t\t\t\tchanged = this.selected || this.partsel;\n\t\t\t\t\tthis.selected = false;\n\t\t\t\t\tthis.partsel = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase true:\n\t\t\t\t\tchanged = !this.selected || !this.partsel;\n\t\t\t\t\tthis.selected = true;\n\t\t\t\t\tthis.partsel = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase undefined:\n\t\t\t\t\tchanged = this.selected || !this.partsel;\n\t\t\t\t\tthis.selected = false;\n\t\t\t\t\tthis.partsel = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_assert(false, \"invalid state: \" + state);\n\t\t\t}\n\t\t\t// this.debug(\"fixSelection3AfterLoad() _changeSelectStatusAttrs()\", state, changed);\n\t\t\tif (changed) {\n\t\t\t\tthis.renderStatus();\n\t\t\t}\n\t\t\treturn changed;\n\t\t},\n\t\t/**\n   * Fix selection status, after this node was (de)selected in multi-hier mode.\n   * This includes (de)selecting all children.\n   */\n\t\tfixSelection3AfterClick: function fixSelection3AfterClick() {\n\t\t\tvar flag = this.isSelected();\n\n\t\t\t//\t\tthis.debug(\"fixSelection3AfterClick()\");\n\n\t\t\tthis.visit(function (node) {\n\t\t\t\tnode._changeSelectStatusAttrs(flag);\n\t\t\t});\n\t\t\tthis.fixSelection3FromEndNodes();\n\t\t},\n\t\t/**\n   * Fix selection status for multi-hier mode.\n   * Only end-nodes are considered to update the descendants branch and parents.\n   * Should be called after this node has loaded new children or after\n   * children have been modified using the API.\n   */\n\t\tfixSelection3FromEndNodes: function fixSelection3FromEndNodes() {\n\t\t\t//\t\tthis.debug(\"fixSelection3FromEndNodes()\");\n\t\t\t_assert(this.tree.options.selectMode === 3, \"expected selectMode 3\");\n\n\t\t\t// Visit all end nodes and adjust their parent's `selected` and `partsel`\n\t\t\t// attributes. Return selection state true, false, or undefined.\n\t\t\tfunction _walk(node) {\n\t\t\t\tvar i,\n\t\t\t\t    l,\n\t\t\t\t    child,\n\t\t\t\t    s,\n\t\t\t\t    state,\n\t\t\t\t    allSelected,\n\t\t\t\t    someSelected,\n\t\t\t\t    children = node.children;\n\n\t\t\t\tif (children && children.length) {\n\t\t\t\t\t// check all children recursively\n\t\t\t\t\tallSelected = true;\n\t\t\t\t\tsomeSelected = false;\n\n\t\t\t\t\tfor (i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\t// the selection state of a node is not relevant; we need the end-nodes\n\t\t\t\t\t\ts = _walk(child);\n\t\t\t\t\t\tif (s !== false) {\n\t\t\t\t\t\t\tsomeSelected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s !== true) {\n\t\t\t\t\t\t\tallSelected = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstate = allSelected ? true : someSelected ? undefined : false;\n\t\t\t\t} else {\n\t\t\t\t\t// This is an end-node: simply report the status\n\t\t\t\t\t//\t\t\t\tstate = ( node.unselectable ) ? undefined : !!node.selected;\n\t\t\t\t\tstate = !!node.selected;\n\t\t\t\t}\n\t\t\t\tnode._changeSelectStatusAttrs(state);\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\t_walk(this);\n\n\t\t\t// Update parent's state\n\t\t\tthis.visitParents(function (node) {\n\t\t\t\tvar i,\n\t\t\t\t    l,\n\t\t\t\t    child,\n\t\t\t\t    state,\n\t\t\t\t    children = node.children,\n\t\t\t\t    allSelected = true,\n\t\t\t\t    someSelected = false;\n\n\t\t\t\tfor (i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchild = children[i];\n\t\t\t\t\t// When fixing the parents, we trust the sibling status (i.e.\n\t\t\t\t\t// we don't recurse)\n\t\t\t\t\tif (child.selected || child.partsel) {\n\t\t\t\t\t\tsomeSelected = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!child.unselectable && !child.selected) {\n\t\t\t\t\t\tallSelected = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstate = allSelected ? true : someSelected ? undefined : false;\n\t\t\t\tnode._changeSelectStatusAttrs(state);\n\t\t\t});\n\t\t},\n\t\t// TODO: focus()\n\t\t/**\n   * Update node data. If dict contains 'children', then also replace\n   * the hole sub tree.\n   * @param {NodeData} dict\n   *\n   * @see FancytreeNode#addChildren\n   * @see FancytreeNode#applyPatch\n   */\n\t\tfromDict: function fromDict(dict) {\n\t\t\t// copy all other attributes to this.data.xxx\n\t\t\tfor (var name in dict) {\n\t\t\t\tif (NODE_ATTR_MAP[name]) {\n\t\t\t\t\t// node.NAME = dict.NAME\n\t\t\t\t\tthis[name] = dict[name];\n\t\t\t\t} else if (name === \"data\") {\n\t\t\t\t\t// node.data += dict.data\n\t\t\t\t\t$.extend(this.data, dict.data);\n\t\t\t\t} else if (!$.isFunction(dict[name]) && !NONE_NODE_DATA_MAP[name]) {\n\t\t\t\t\t// node.data.NAME = dict.NAME\n\t\t\t\t\tthis.data[name] = dict[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dict.children) {\n\t\t\t\t// recursively set children and render\n\t\t\t\tthis.removeChildren();\n\t\t\t\tthis.addChildren(dict.children);\n\t\t\t}\n\t\t\tthis.renderTitle();\n\t\t\t/*\n   \t\tvar children = dict.children;\n   \t\tif(children === undefined){\n   \t\t\tthis.data = $.extend(this.data, dict);\n   \t\t\tthis.render();\n   \t\t\treturn;\n   \t\t}\n   \t\tdict = $.extend({}, dict);\n   \t\tdict.children = undefined;\n   \t\tthis.data = $.extend(this.data, dict);\n   \t\tthis.removeChildren();\n   \t\tthis.addChild(children);\n   */\n\t\t},\n\t\t/** Return the list of child nodes (undefined for unexpanded lazy nodes).\n   * @returns {FancytreeNode[] | undefined}\n   */\n\t\tgetChildren: function getChildren() {\n\t\t\tif (this.hasChildren() === undefined) {\n\t\t\t\t// TODO: only required for lazy nodes?\n\t\t\t\treturn undefined; // Lazy node: unloaded, currently loading, or load error\n\t\t\t}\n\t\t\treturn this.children;\n\t\t},\n\t\t/** Return the first child node or null.\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetFirstChild: function getFirstChild() {\n\t\t\treturn this.children ? this.children[0] : null;\n\t\t},\n\t\t/** Return the 0-based child index.\n   * @returns {int}\n   */\n\t\tgetIndex: function getIndex() {\n\t\t\t//\t\treturn this.parent.children.indexOf(this);\n\t\t\treturn $.inArray(this, this.parent.children); // indexOf doesn't work in IE7\n\t\t},\n\t\t/** Return the hierarchical child index (1-based, e.g. '3.2.4').\n   * @param {string} [separator=\".\"]\n   * @param {int} [digits=1]\n   * @returns {string}\n   */\n\t\tgetIndexHier: function getIndexHier(separator, digits) {\n\t\t\tseparator = separator || \".\";\n\t\t\tvar s,\n\t\t\t    res = [];\n\t\t\t$.each(this.getParentList(false, true), function (i, o) {\n\t\t\t\ts = \"\" + (o.getIndex() + 1);\n\t\t\t\tif (digits) {\n\t\t\t\t\t// prepend leading zeroes\n\t\t\t\t\ts = (\"0000000\" + s).substr(-digits);\n\t\t\t\t}\n\t\t\t\tres.push(s);\n\t\t\t});\n\t\t\treturn res.join(separator);\n\t\t},\n\t\t/** Return the parent keys separated by options.keyPathSeparator, e.g. \"id_1/id_17/id_32\".\n   * @param {boolean} [excludeSelf=false]\n   * @returns {string}\n   */\n\t\tgetKeyPath: function getKeyPath(excludeSelf) {\n\t\t\tvar path = [],\n\t\t\t    sep = this.tree.options.keyPathSeparator;\n\t\t\tthis.visitParents(function (n) {\n\t\t\t\tif (n.parent) {\n\t\t\t\t\tpath.unshift(n.key);\n\t\t\t\t}\n\t\t\t}, !excludeSelf);\n\t\t\treturn sep + path.join(sep);\n\t\t},\n\t\t/** Return the last child of this node or null.\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetLastChild: function getLastChild() {\n\t\t\treturn this.children ? this.children[this.children.length - 1] : null;\n\t\t},\n\t\t/** Return node depth. 0: System root node, 1: visible top-level node, 2: first sub-level, ... .\n   * @returns {int}\n   */\n\t\tgetLevel: function getLevel() {\n\t\t\tvar level = 0,\n\t\t\t    dtn = this.parent;\n\t\t\twhile (dtn) {\n\t\t\t\tlevel++;\n\t\t\t\tdtn = dtn.parent;\n\t\t\t}\n\t\t\treturn level;\n\t\t},\n\t\t/** Return the successor node (under the same parent) or null.\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetNextSibling: function getNextSibling() {\n\t\t\t// TODO: use indexOf, if available: (not in IE6)\n\t\t\tif (this.parent) {\n\t\t\t\tvar i,\n\t\t\t\t    l,\n\t\t\t\t    ac = this.parent.children;\n\n\t\t\t\tfor (i = 0, l = ac.length - 1; i < l; i++) {\n\t\t\t\t\t// up to length-2, so next(last) = null\n\t\t\t\t\tif (ac[i] === this) {\n\t\t\t\t\t\treturn ac[i + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/** Return the parent node (null for the system root node).\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetParent: function getParent() {\n\t\t\t// TODO: return null for top-level nodes?\n\t\t\treturn this.parent;\n\t\t},\n\t\t/** Return an array of all parent nodes (top-down).\n   * @param {boolean} [includeRoot=false] Include the invisible system root node.\n   * @param {boolean} [includeSelf=false] Include the node itself.\n   * @returns {FancytreeNode[]}\n   */\n\t\tgetParentList: function getParentList(includeRoot, includeSelf) {\n\t\t\tvar l = [],\n\t\t\t    dtn = includeSelf ? this : this.parent;\n\t\t\twhile (dtn) {\n\t\t\t\tif (includeRoot || dtn.parent) {\n\t\t\t\t\tl.unshift(dtn);\n\t\t\t\t}\n\t\t\t\tdtn = dtn.parent;\n\t\t\t}\n\t\t\treturn l;\n\t\t},\n\t\t/** Return the predecessor node (under the same parent) or null.\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetPrevSibling: function getPrevSibling() {\n\t\t\tif (this.parent) {\n\t\t\t\tvar i,\n\t\t\t\t    l,\n\t\t\t\t    ac = this.parent.children;\n\n\t\t\t\tfor (i = 1, l = ac.length; i < l; i++) {\n\t\t\t\t\t// start with 1, so prev(first) = null\n\t\t\t\t\tif (ac[i] === this) {\n\t\t\t\t\t\treturn ac[i - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n   * Return an array of selected descendant nodes.\n   * @param {boolean} [stopOnParents=false] only return the topmost selected\n   *     node (useful with selectMode 3)\n   * @returns {FancytreeNode[]}\n   */\n\t\tgetSelectedNodes: function getSelectedNodes(stopOnParents) {\n\t\t\tvar nodeList = [];\n\t\t\tthis.visit(function (node) {\n\t\t\t\tif (node.selected) {\n\t\t\t\t\tnodeList.push(node);\n\t\t\t\t\tif (stopOnParents === true) {\n\t\t\t\t\t\treturn \"skip\"; // stop processing this branch\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn nodeList;\n\t\t},\n\t\t/** Return true if node has children. Return undefined if not sure, i.e. the node is lazy and not yet loaded).\n   * @returns {boolean | undefined}\n   */\n\t\thasChildren: function hasChildren() {\n\t\t\tif (this.lazy) {\n\t\t\t\tif (this.children == null) {\n\t\t\t\t\t// null or undefined: Not yet loaded\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else if (this.children.length === 0) {\n\t\t\t\t\t// Loaded, but response was empty\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (this.children.length === 1 && this.children[0].isStatusNode()) {\n\t\t\t\t\t// Currently loading or load error\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn !!(this.children && this.children.length);\n\t\t},\n\t\t/** Return true if node has keyboard focus.\n   * @returns {boolean}\n   */\n\t\thasFocus: function hasFocus() {\n\t\t\treturn this.tree.hasFocus() && this.tree.focusNode === this;\n\t\t},\n\t\t/** Write to browser console if debugLevel >= 1 (prepending node info)\n   *\n   * @param {*} msg string or object or array of such\n   */\n\t\tinfo: function info(msg) {\n\t\t\tif (this.tree.options.debugLevel >= 1) {\n\t\t\t\tArray.prototype.unshift.call(arguments, this.toString());\n\t\t\t\tconsoleApply(\"info\", arguments);\n\t\t\t}\n\t\t},\n\t\t/** Return true if node is active (see also FancytreeNode#isSelected).\n   * @returns {boolean}\n   */\n\t\tisActive: function isActive() {\n\t\t\treturn this.tree.activeNode === this;\n\t\t},\n\t\t/** Return true if node is a direct child of otherNode.\n   * @param {FancytreeNode} otherNode\n   * @returns {boolean}\n   */\n\t\tisChildOf: function isChildOf(otherNode) {\n\t\t\treturn this.parent && this.parent === otherNode;\n\t\t},\n\t\t/** Return true, if node is a direct or indirect sub node of otherNode.\n   * @param {FancytreeNode} otherNode\n   * @returns {boolean}\n   */\n\t\tisDescendantOf: function isDescendantOf(otherNode) {\n\t\t\tif (!otherNode || otherNode.tree !== this.tree) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar p = this.parent;\n\t\t\twhile (p) {\n\t\t\t\tif (p === otherNode) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tp = p.parent;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/** Return true if node is expanded.\n   * @returns {boolean}\n   */\n\t\tisExpanded: function isExpanded() {\n\t\t\treturn !!this.expanded;\n\t\t},\n\t\t/** Return true if node is the first node of its parent's children.\n   * @returns {boolean}\n   */\n\t\tisFirstSibling: function isFirstSibling() {\n\t\t\tvar p = this.parent;\n\t\t\treturn !p || p.children[0] === this;\n\t\t},\n\t\t/** Return true if node is a folder, i.e. has the node.folder attribute set.\n   * @returns {boolean}\n   */\n\t\tisFolder: function isFolder() {\n\t\t\treturn !!this.folder;\n\t\t},\n\t\t/** Return true if node is the last node of its parent's children.\n   * @returns {boolean}\n   */\n\t\tisLastSibling: function isLastSibling() {\n\t\t\tvar p = this.parent;\n\t\t\treturn !p || p.children[p.children.length - 1] === this;\n\t\t},\n\t\t/** Return true if node is lazy (even if data was already loaded)\n   * @returns {boolean}\n   */\n\t\tisLazy: function isLazy() {\n\t\t\treturn !!this.lazy;\n\t\t},\n\t\t/** Return true if node is lazy and loaded. For non-lazy nodes always return true.\n   * @returns {boolean}\n   */\n\t\tisLoaded: function isLoaded() {\n\t\t\treturn !this.lazy || this.hasChildren() !== undefined; // Also checks if the only child is a status node\n\t\t},\n\t\t/** Return true if children are currently beeing loaded, i.e. a Ajax request is pending.\n   * @returns {boolean}\n   */\n\t\tisLoading: function isLoading() {\n\t\t\treturn !!this._isLoading;\n\t\t},\n\t\t/*\n   * @deprecated since v2.4.0:  Use isRootNode() instead\n   */\n\t\tisRoot: function isRoot() {\n\t\t\treturn this.isRootNode();\n\t\t},\n\t\t/** (experimental) Return true if this is partially loaded.\n   * @returns {boolean}\n   * @since 2.15\n   */\n\t\tisPartload: function isPartload() {\n\t\t\treturn !!this.partload;\n\t\t},\n\t\t/** Return true if this is the (invisible) system root node.\n   * @returns {boolean}\n   * @since 2.4\n   */\n\t\tisRootNode: function isRootNode() {\n\t\t\treturn this.tree.rootNode === this;\n\t\t},\n\t\t/** Return true if node is selected, i.e. has a checkmark set (see also FancytreeNode#isActive).\n   * @returns {boolean}\n   */\n\t\tisSelected: function isSelected() {\n\t\t\treturn !!this.selected;\n\t\t},\n\t\t/** Return true if this node is a temporarily generated system node like\n   * 'loading', 'paging', or 'error' (node.statusNodeType contains the type).\n   * @returns {boolean}\n   */\n\t\tisStatusNode: function isStatusNode() {\n\t\t\treturn !!this.statusNodeType;\n\t\t},\n\t\t/** Return true if this node is a status node of type 'paging'.\n   * @returns {boolean}\n   * @since 2.15\n   */\n\t\tisPagingNode: function isPagingNode() {\n\t\t\treturn this.statusNodeType === \"paging\";\n\t\t},\n\t\t/** Return true if this a top level node, i.e. a direct child of the (invisible) system root node.\n   * @returns {boolean}\n   * @since 2.4\n   */\n\t\tisTopLevel: function isTopLevel() {\n\t\t\treturn this.tree.rootNode === this.parent;\n\t\t},\n\t\t/** Return true if node is lazy and not yet loaded. For non-lazy nodes always return false.\n   * @returns {boolean}\n   */\n\t\tisUndefined: function isUndefined() {\n\t\t\treturn this.hasChildren() === undefined; // also checks if the only child is a status node\n\t\t},\n\t\t/** Return true if all parent nodes are expanded. Note: this does not check\n   * whether the node is scrolled into the visible part of the screen.\n   * @returns {boolean}\n   */\n\t\tisVisible: function isVisible() {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    parents = this.getParentList(false, false);\n\n\t\t\tfor (i = 0, l = parents.length; i < l; i++) {\n\t\t\t\tif (!parents[i].expanded) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/** Deprecated.\n   * @deprecated since 2014-02-16: use load() instead.\n   */\n\t\tlazyLoad: function lazyLoad(discard) {\n\t\t\tthis.warn(\"FancytreeNode.lazyLoad() is deprecated since 2014-02-16. Use .load() instead.\");\n\t\t\treturn this.load(discard);\n\t\t},\n\t\t/**\n   * Load all children of a lazy node if neccessary. The <i>expanded</i> state is maintained.\n   * @param {boolean} [forceReload=false] Pass true to discard any existing nodes before. Otherwise this method does nothing if the node was already loaded.\n   * @returns {$.Promise}\n   */\n\t\tload: function load(forceReload) {\n\t\t\tvar res,\n\t\t\t    source,\n\t\t\t    that = this,\n\t\t\t    wasExpanded = this.isExpanded();\n\n\t\t\t_assert(this.isLazy(), \"load() requires a lazy node\");\n\t\t\t// _assert( forceReload || this.isUndefined(), \"Pass forceReload=true to re-load a lazy node\" );\n\t\t\tif (!forceReload && !this.isUndefined()) {\n\t\t\t\treturn _getResolvedPromise(this);\n\t\t\t}\n\t\t\tif (this.isLoaded()) {\n\t\t\t\tthis.resetLazy(); // also collapses\n\t\t\t}\n\t\t\t// This method is also called by setExpanded() and loadKeyPath(), so we\n\t\t\t// have to avoid recursion.\n\t\t\tsource = this.tree._triggerNodeEvent(\"lazyLoad\", this);\n\t\t\tif (source === false) {\n\t\t\t\t// #69\n\t\t\t\treturn _getResolvedPromise(this);\n\t\t\t}\n\t\t\t_assert(typeof source !== \"boolean\", \"lazyLoad event must return source in data.result\");\n\t\t\tres = this.tree._callHook(\"nodeLoadChildren\", this, source);\n\t\t\tif (wasExpanded) {\n\t\t\t\tthis.expanded = true;\n\t\t\t\tres.always(function () {\n\t\t\t\t\tthat.render();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tres.always(function () {\n\t\t\t\t\tthat.renderStatus(); // fix expander icon to 'loaded'\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\t/** Expand all parents and optionally scroll into visible area as neccessary.\n   * Promise is resolved, when lazy loading and animations are done.\n   * @param {object} [opts] passed to `setExpanded()`.\n   *     Defaults to {noAnimation: false, noEvents: false, scrollIntoView: true}\n   * @returns {$.Promise}\n   */\n\t\tmakeVisible: function makeVisible(opts) {\n\t\t\tvar i,\n\t\t\t    that = this,\n\t\t\t    deferreds = [],\n\t\t\t    dfd = new $.Deferred(),\n\t\t\t    parents = this.getParentList(false, false),\n\t\t\t    len = parents.length,\n\t\t\t    effects = !(opts && opts.noAnimation === true),\n\t\t\t    scroll = !(opts && opts.scrollIntoView === false);\n\n\t\t\t// Expand bottom-up, so only the top node is animated\n\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t// that.debug(\"pushexpand\" + parents[i]);\n\t\t\t\tdeferreds.push(parents[i].setExpanded(true, opts));\n\t\t\t}\n\t\t\t$.when.apply($, deferreds).done(function () {\n\t\t\t\t// All expands have finished\n\t\t\t\t// that.debug(\"expand DONE\", scroll);\n\t\t\t\tif (scroll) {\n\t\t\t\t\tthat.scrollIntoView(effects).done(function () {\n\t\t\t\t\t\t// that.debug(\"scroll DONE\");\n\t\t\t\t\t\tdfd.resolve();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdfd.resolve();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn dfd.promise();\n\t\t},\n\t\t/** Move this node to targetNode.\n   *  @param {FancytreeNode} targetNode\n   *  @param {string} mode <pre>\n   *      'child': append this node as last child of targetNode.\n   *               This is the default. To be compatble with the D'n'd\n   *               hitMode, we also accept 'over'.\n   *      'firstChild': add this node as first child of targetNode.\n   *      'before': add this node as sibling before targetNode.\n   *      'after': add this node as sibling after targetNode.</pre>\n   *  @param {function} [map] optional callback(FancytreeNode) to allow modifcations\n   */\n\t\tmoveTo: function moveTo(targetNode, mode, map) {\n\t\t\tif (mode === undefined || mode === \"over\") {\n\t\t\t\tmode = \"child\";\n\t\t\t} else if (mode === \"firstChild\") {\n\t\t\t\tif (targetNode.children && targetNode.children.length) {\n\t\t\t\t\tmode = \"before\";\n\t\t\t\t\ttargetNode = targetNode.children[0];\n\t\t\t\t} else {\n\t\t\t\t\tmode = \"child\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar pos,\n\t\t\t    prevParent = this.parent,\n\t\t\t    targetParent = mode === \"child\" ? targetNode : targetNode.parent;\n\n\t\t\tif (this === targetNode) {\n\t\t\t\treturn;\n\t\t\t} else if (!this.parent) {\n\t\t\t\t$.error(\"Cannot move system root\");\n\t\t\t} else if (targetParent.isDescendantOf(this)) {\n\t\t\t\t$.error(\"Cannot move a node to its own descendant\");\n\t\t\t}\n\t\t\tif (targetParent !== prevParent) {\n\t\t\t\tprevParent.triggerModifyChild(\"remove\", this);\n\t\t\t}\n\t\t\t// Unlink this node from current parent\n\t\t\tif (this.parent.children.length === 1) {\n\t\t\t\tif (this.parent === targetParent) {\n\t\t\t\t\treturn; // #258\n\t\t\t\t}\n\t\t\t\tthis.parent.children = this.parent.lazy ? [] : null;\n\t\t\t\tthis.parent.expanded = false;\n\t\t\t} else {\n\t\t\t\tpos = $.inArray(this, this.parent.children);\n\t\t\t\t_assert(pos >= 0, \"invalid source parent\");\n\t\t\t\tthis.parent.children.splice(pos, 1);\n\t\t\t}\n\t\t\t// Remove from source DOM parent\n\t\t\t//\t\tif(this.parent.ul){\n\t\t\t//\t\t\tthis.parent.ul.removeChild(this.li);\n\t\t\t//\t\t}\n\n\t\t\t// Insert this node to target parent's child list\n\t\t\tthis.parent = targetParent;\n\t\t\tif (targetParent.hasChildren()) {\n\t\t\t\tswitch (mode) {\n\t\t\t\t\tcase \"child\":\n\t\t\t\t\t\t// Append to existing target children\n\t\t\t\t\t\ttargetParent.children.push(this);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"before\":\n\t\t\t\t\t\t// Insert this node before target node\n\t\t\t\t\t\tpos = $.inArray(targetNode, targetParent.children);\n\t\t\t\t\t\t_assert(pos >= 0, \"invalid target parent\");\n\t\t\t\t\t\ttargetParent.children.splice(pos, 0, this);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"after\":\n\t\t\t\t\t\t// Insert this node after target node\n\t\t\t\t\t\tpos = $.inArray(targetNode, targetParent.children);\n\t\t\t\t\t\t_assert(pos >= 0, \"invalid target parent\");\n\t\t\t\t\t\ttargetParent.children.splice(pos + 1, 0, this);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$.error(\"Invalid mode \" + mode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttargetParent.children = [this];\n\t\t\t}\n\t\t\t// Parent has no <ul> tag yet:\n\t\t\t//\t\tif( !targetParent.ul ) {\n\t\t\t//\t\t\t// This is the parent's first child: create UL tag\n\t\t\t//\t\t\t// (Hidden, because it will be\n\t\t\t//\t\t\ttargetParent.ul = document.createElement(\"ul\");\n\t\t\t//\t\t\ttargetParent.ul.style.display = \"none\";\n\t\t\t//\t\t\ttargetParent.li.appendChild(targetParent.ul);\n\t\t\t//\t\t}\n\t\t\t//\t\t// Issue 319: Add to target DOM parent (only if node was already rendered(expanded))\n\t\t\t//\t\tif(this.li){\n\t\t\t//\t\t\ttargetParent.ul.appendChild(this.li);\n\t\t\t//\t\t}^\n\n\t\t\t// Let caller modify the nodes\n\t\t\tif (map) {\n\t\t\t\ttargetNode.visit(map, true);\n\t\t\t}\n\t\t\tif (targetParent === prevParent) {\n\t\t\t\ttargetParent.triggerModifyChild(\"move\", this);\n\t\t\t} else {\n\t\t\t\t// prevParent.triggerModifyChild(\"remove\", this);\n\t\t\t\ttargetParent.triggerModifyChild(\"add\", this);\n\t\t\t}\n\t\t\t// Handle cross-tree moves\n\t\t\tif (this.tree !== targetNode.tree) {\n\t\t\t\t// Fix node.tree for all source nodes\n\t\t\t\t//\t\t\t_assert(false, \"Cross-tree move is not yet implemented.\");\n\t\t\t\tthis.warn(\"Cross-tree moveTo is experimantal!\");\n\t\t\t\tthis.visit(function (n) {\n\t\t\t\t\t// TODO: fix selection state and activation, ...\n\t\t\t\t\tn.tree = targetNode.tree;\n\t\t\t\t}, true);\n\t\t\t}\n\n\t\t\t// A collaposed node won't re-render children, so we have to remove it manually\n\t\t\t// if( !targetParent.expanded ){\n\t\t\t//   prevParent.ul.removeChild(this.li);\n\t\t\t// }\n\n\t\t\t// Update HTML markup\n\t\t\tif (!prevParent.isDescendantOf(targetParent)) {\n\t\t\t\tprevParent.render();\n\t\t\t}\n\t\t\tif (!targetParent.isDescendantOf(prevParent) && targetParent !== prevParent) {\n\t\t\t\ttargetParent.render();\n\t\t\t}\n\t\t\t// TODO: fix selection state\n\t\t\t// TODO: fix active state\n\n\t\t\t/*\n   \t\tvar tree = this.tree;\n   \t\tvar opts = tree.options;\n   \t\tvar pers = tree.persistence;\n   \n   \n   \t\t// Always expand, if it's below minExpandLevel\n   //\t\ttree.logDebug (\"%s._addChildNode(%o), l=%o\", this, ftnode, ftnode.getLevel());\n   \t\tif ( opts.minExpandLevel >= ftnode.getLevel() ) {\n   //\t\t\ttree.logDebug (\"Force expand for %o\", ftnode);\n   \t\t\tthis.bExpanded = true;\n   \t\t}\n   \n   \t\t// In multi-hier mode, update the parents selection state\n   \t\t// DT issue #82: only if not initializing, because the children may not exist yet\n   //\t\tif( !ftnode.data.isStatusNode() && opts.selectMode==3 && !isInitializing )\n   //\t\t\tftnode._fixSelectionState();\n   \n   \t\t// In multi-hier mode, update the parents selection state\n   \t\tif( ftnode.bSelected && opts.selectMode==3 ) {\n   \t\t\tvar p = this;\n   \t\t\twhile( p ) {\n   \t\t\t\tif( !p.hasSubSel )\n   \t\t\t\t\tp._setSubSel(true);\n   \t\t\t\tp = p.parent;\n   \t\t\t}\n   \t\t}\n   \t\t// render this node and the new child\n   \t\tif ( tree.bEnableUpdate )\n   \t\t\tthis.render();\n   \n   \t\treturn ftnode;\n   \n   */\n\t\t},\n\t\t/** Set focus relative to this node and optionally activate.\n   *\n   * @param {number} where The keyCode that would normally trigger this move,\n   *\t\te.g. `$.ui.keyCode.LEFT` would collapse the node if it\n   *      is expanded or move to the parent oterwise.\n   * @param {boolean} [activate=true]\n   * @returns {$.Promise}\n   */\n\t\tnavigate: function navigate(where, activate) {\n\t\t\tvar i,\n\t\t\t    parents,\n\t\t\t    res,\n\t\t\t    handled = true,\n\t\t\t    KC = $.ui.keyCode,\n\t\t\t    sib = null;\n\n\t\t\t// Navigate to node\n\t\t\tfunction _goto(n) {\n\t\t\t\tif (n) {\n\t\t\t\t\t// setFocus/setActive will scroll later (if autoScroll is specified)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tn.makeVisible({ scrollIntoView: false });\n\t\t\t\t\t} catch (e) {} // #272\n\t\t\t\t\t// Node may still be hidden by a filter\n\t\t\t\t\tif (!$(n.span).is(\":visible\")) {\n\t\t\t\t\t\tn.debug(\"Navigate: skipping hidden node\");\n\t\t\t\t\t\tn.navigate(where, activate);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn activate === false ? n.setFocus() : n.setActive();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (where) {\n\t\t\t\tcase KC.BACKSPACE:\n\t\t\t\t\tif (this.parent && this.parent.parent) {\n\t\t\t\t\t\tres = _goto(this.parent);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KC.HOME:\n\t\t\t\t\tthis.tree.visit(function (n) {\n\t\t\t\t\t\t// goto first visible node\n\t\t\t\t\t\tif ($(n.span).is(\":visible\")) {\n\t\t\t\t\t\t\tres = _goto(n);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase KC.END:\n\t\t\t\t\tthis.tree.visit(function (n) {\n\t\t\t\t\t\t// goto last visible node\n\t\t\t\t\t\tif ($(n.span).is(\":visible\")) {\n\t\t\t\t\t\t\tres = n;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\tres = _goto(res);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KC.LEFT:\n\t\t\t\t\tif (this.expanded) {\n\t\t\t\t\t\tthis.setExpanded(false);\n\t\t\t\t\t\tres = _goto(this);\n\t\t\t\t\t} else if (this.parent && this.parent.parent) {\n\t\t\t\t\t\tres = _goto(this.parent);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KC.RIGHT:\n\t\t\t\t\tif (!this.expanded && (this.children || this.lazy)) {\n\t\t\t\t\t\tthis.setExpanded();\n\t\t\t\t\t\tres = _goto(this);\n\t\t\t\t\t} else if (this.children && this.children.length) {\n\t\t\t\t\t\tres = _goto(this.children[0]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase KC.UP:\n\t\t\t\t\tsib = this.getPrevSibling();\n\t\t\t\t\t// #359: skip hidden sibling nodes, preventing a _goto() recursion\n\t\t\t\t\twhile (sib && !$(sib.span).is(\":visible\")) {\n\t\t\t\t\t\tsib = sib.getPrevSibling();\n\t\t\t\t\t}\n\t\t\t\t\twhile (sib && sib.expanded && sib.children && sib.children.length) {\n\t\t\t\t\t\tsib = sib.children[sib.children.length - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!sib && this.parent && this.parent.parent) {\n\t\t\t\t\t\tsib = this.parent;\n\t\t\t\t\t}\n\t\t\t\t\tres = _goto(sib);\n\t\t\t\t\tbreak;\n\t\t\t\tcase KC.DOWN:\n\t\t\t\t\tif (this.expanded && this.children && this.children.length) {\n\t\t\t\t\t\tsib = this.children[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparents = this.getParentList(false, true);\n\t\t\t\t\t\tfor (i = parents.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tsib = parents[i].getNextSibling();\n\t\t\t\t\t\t\t// #359: skip hidden sibling nodes, preventing a _goto() recursion\n\t\t\t\t\t\t\twhile (sib && !$(sib.span).is(\":visible\")) {\n\t\t\t\t\t\t\t\tsib = sib.getNextSibling();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (sib) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tres = _goto(sib);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\thandled = false;\n\t\t\t}\n\t\t\treturn res || _getResolvedPromise();\n\t\t},\n\t\t/**\n   * Remove this node (not allowed for system root).\n   */\n\t\tremove: function remove() {\n\t\t\treturn this.parent.removeChild(this);\n\t\t},\n\t\t/**\n   * Remove childNode from list of direct children.\n   * @param {FancytreeNode} childNode\n   */\n\t\tremoveChild: function removeChild(childNode) {\n\t\t\treturn this.tree._callHook(\"nodeRemoveChild\", this, childNode);\n\t\t},\n\t\t/**\n   * Remove all child nodes and descendents. This converts the node into a leaf.<br>\n   * If this was a lazy node, it is still considered 'loaded'; call node.resetLazy()\n   * in order to trigger lazyLoad on next expand.\n   */\n\t\tremoveChildren: function removeChildren() {\n\t\t\treturn this.tree._callHook(\"nodeRemoveChildren\", this);\n\t\t},\n\t\t/**\n   * Remove class from node's span tag and .extraClasses.\n   *\n   * @param {string} className class name\n   *\n   * @since 2.17\n   */\n\t\tremoveClass: function removeClass(className) {\n\t\t\treturn this.toggleClass(className, false);\n\t\t},\n\t\t/**\n   * This method renders and updates all HTML markup that is required\n   * to display this node in its current state.<br>\n   * Note:\n   * <ul>\n   * <li>It should only be neccessary to call this method after the node object\n   *     was modified by direct access to its properties, because the common\n   *     API methods (node.setTitle(), moveTo(), addChildren(), remove(), ...)\n   *     already handle this.\n   * <li> {@link FancytreeNode#renderTitle} and {@link FancytreeNode#renderStatus}\n   *     are implied. If changes are more local, calling only renderTitle() or\n   *     renderStatus() may be sufficient and faster.\n   * <li>If a node was created/removed, node.render() must be called <i>on the parent</i>.\n   * </ul>\n   *\n   * @param {boolean} [force=false] re-render, even if html markup was already created\n   * @param {boolean} [deep=false] also render all descendants, even if parent is collapsed\n   */\n\t\trender: function render(force, deep) {\n\t\t\treturn this.tree._callHook(\"nodeRender\", this, force, deep);\n\t\t},\n\t\t/** Create HTML markup for the node's outer &lt;span> (expander, checkbox, icon, and title).\n   * Implies {@link FancytreeNode#renderStatus}.\n   * @see Fancytree_Hooks#nodeRenderTitle\n   */\n\t\trenderTitle: function renderTitle() {\n\t\t\treturn this.tree._callHook(\"nodeRenderTitle\", this);\n\t\t},\n\t\t/** Update element's CSS classes according to node state.\n   * @see Fancytree_Hooks#nodeRenderStatus\n   */\n\t\trenderStatus: function renderStatus() {\n\t\t\treturn this.tree._callHook(\"nodeRenderStatus\", this);\n\t\t},\n\t\t/**\n   * (experimental) Replace this node with `source`.\n   * (Currently only available for paging nodes.)\n   * @param {NodeData[]} source List of child node definitions\n   * @since 2.15\n   */\n\t\treplaceWith: function replaceWith(source) {\n\t\t\tvar res,\n\t\t\t    parent = this.parent,\n\t\t\t    pos = $.inArray(this, parent.children),\n\t\t\t    that = this;\n\n\t\t\t_assert(this.isPagingNode(), \"replaceWith() currently requires a paging status node\");\n\n\t\t\tres = this.tree._callHook(\"nodeLoadChildren\", this, source);\n\t\t\tres.done(function (data) {\n\t\t\t\t// New nodes are currently children of `this`.\n\t\t\t\tvar children = that.children;\n\t\t\t\t// Prepend newly loaded child nodes to `this`\n\t\t\t\t// Move new children after self\n\t\t\t\tfor (i = 0; i < children.length; i++) {\n\t\t\t\t\tchildren[i].parent = parent;\n\t\t\t\t}\n\t\t\t\tparent.children.splice.apply(parent.children, [pos + 1, 0].concat(children));\n\n\t\t\t\t// Remove self\n\t\t\t\tthat.children = null;\n\t\t\t\tthat.remove();\n\t\t\t\t// Redraw new nodes\n\t\t\t\tparent.render();\n\t\t\t\t// TODO: set node.partload = false if this was tha last paging node?\n\t\t\t\t// parent.addPagingNode(false);\n\t\t\t}).fail(function () {\n\t\t\t\tthat.setExpanded();\n\t\t\t});\n\t\t\treturn res;\n\t\t\t// $.error(\"Not implemented: replaceWith()\");\n\t\t},\n\t\t/**\n   * Remove all children, collapse, and set the lazy-flag, so that the lazyLoad\n   * event is triggered on next expand.\n   */\n\t\tresetLazy: function resetLazy() {\n\t\t\tthis.removeChildren();\n\t\t\tthis.expanded = false;\n\t\t\tthis.lazy = true;\n\t\t\tthis.children = undefined;\n\t\t\tthis.renderStatus();\n\t\t},\n\t\t/** Schedule activity for delayed execution (cancel any pending request).\n   *  scheduleAction('cancel') will only cancel a pending request (if any).\n   * @param {string} mode\n   * @param {number} ms\n   */\n\t\tscheduleAction: function scheduleAction(mode, ms) {\n\t\t\tif (this.tree.timer) {\n\t\t\t\tclearTimeout(this.tree.timer);\n\t\t\t\t//            this.tree.debug(\"clearTimeout(%o)\", this.tree.timer);\n\t\t\t}\n\t\t\tthis.tree.timer = null;\n\t\t\tvar self = this; // required for closures\n\t\t\tswitch (mode) {\n\t\t\t\tcase \"cancel\":\n\t\t\t\t\t// Simply made sure that timer was cleared\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"expand\":\n\t\t\t\t\tthis.tree.timer = setTimeout(function () {\n\t\t\t\t\t\tself.tree.debug(\"setTimeout: trigger expand\");\n\t\t\t\t\t\tself.setExpanded(true);\n\t\t\t\t\t}, ms);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"activate\":\n\t\t\t\t\tthis.tree.timer = setTimeout(function () {\n\t\t\t\t\t\tself.tree.debug(\"setTimeout: trigger activate\");\n\t\t\t\t\t\tself.setActive(true);\n\t\t\t\t\t}, ms);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$.error(\"Invalid mode \" + mode);\n\t\t\t}\n\t\t\t//        this.tree.debug(\"setTimeout(%s, %s): %s\", mode, ms, this.tree.timer);\n\t\t},\n\t\t/**\n   *\n   * @param {boolean | PlainObject} [effects=false] animation options.\n   * @param {object} [options=null] {topNode: null, effects: ..., parent: ...} this node will remain visible in\n   *     any case, even if `this` is outside the scroll pane.\n   * @returns {$.Promise}\n   */\n\t\tscrollIntoView: function scrollIntoView(effects, options) {\n\t\t\tif (options !== undefined && _isNode(options)) {\n\t\t\t\tthis.warn(\"scrollIntoView() with 'topNode' option is deprecated since 2014-05-08. Use 'options.topNode' instead.\");\n\t\t\t\toptions = { topNode: options };\n\t\t\t}\n\t\t\t// this.$scrollParent = (this.options.scrollParent === \"auto\") ? $ul.scrollParent() : $(this.options.scrollParent);\n\t\t\t// this.$scrollParent = this.$scrollParent.length ? this.$scrollParent || this.$container;\n\n\t\t\tvar topNodeY,\n\t\t\t    nodeY,\n\t\t\t    horzScrollbarHeight,\n\t\t\t    containerOffsetTop,\n\t\t\t    opts = $.extend({\n\t\t\t\teffects: effects === true ? { duration: 200, queue: false } : effects,\n\t\t\t\tscrollOfs: this.tree.options.scrollOfs,\n\t\t\t\tscrollParent: this.tree.options.scrollParent || this.tree.$container,\n\t\t\t\ttopNode: null\n\t\t\t}, options),\n\t\t\t    dfd = new $.Deferred(),\n\t\t\t    that = this,\n\t\t\t    nodeHeight = $(this.span).height(),\n\t\t\t    $container = $(opts.scrollParent),\n\t\t\t    topOfs = opts.scrollOfs.top || 0,\n\t\t\t    bottomOfs = opts.scrollOfs.bottom || 0,\n\t\t\t    containerHeight = $container.height(),\n\t\t\t    // - topOfs - bottomOfs,\n\t\t\tscrollTop = $container.scrollTop(),\n\t\t\t    $animateTarget = $container,\n\t\t\t    isParentWindow = $container[0] === window,\n\t\t\t    topNode = opts.topNode || null,\n\t\t\t    newScrollTop = null;\n\n\t\t\t// this.debug(\"scrollIntoView(), scrollTop=\" + scrollTop, opts.scrollOfs);\n\t\t\t//\t\t_assert($(this.span).is(\":visible\"), \"scrollIntoView node is invisible\"); // otherwise we cannot calc offsets\n\t\t\tif (!$(this.span).is(\":visible\")) {\n\t\t\t\t// We cannot calc offsets for hidden elements\n\t\t\t\tthis.warn(\"scrollIntoView(): node is invisible.\");\n\t\t\t\treturn _getResolvedPromise();\n\t\t\t}\n\t\t\tif (isParentWindow) {\n\t\t\t\tnodeY = $(this.span).offset().top;\n\t\t\t\ttopNodeY = topNode && topNode.span ? $(topNode.span).offset().top : 0;\n\t\t\t\t$animateTarget = $(\"html,body\");\n\t\t\t} else {\n\t\t\t\t_assert($container[0] !== document && $container[0] !== document.body, \"scrollParent should be a simple element or `window`, not document or body.\");\n\n\t\t\t\tcontainerOffsetTop = $container.offset().top, nodeY = $(this.span).offset().top - containerOffsetTop + scrollTop; // relative to scroll parent\n\t\t\t\ttopNodeY = topNode ? $(topNode.span).offset().top - containerOffsetTop + scrollTop : 0;\n\t\t\t\thorzScrollbarHeight = Math.max(0, $container.innerHeight() - $container[0].clientHeight);\n\t\t\t\tcontainerHeight -= horzScrollbarHeight;\n\t\t\t}\n\n\t\t\t// this.debug(\"    scrollIntoView(), nodeY=\" + nodeY + \", containerHeight=\" + containerHeight);\n\t\t\tif (nodeY < scrollTop + topOfs) {\n\t\t\t\t// Node is above visible container area\n\t\t\t\tnewScrollTop = nodeY - topOfs;\n\t\t\t\t// this.debug(\"    scrollIntoView(), UPPER newScrollTop=\" + newScrollTop);\n\t\t\t} else if (nodeY + nodeHeight > scrollTop + containerHeight - bottomOfs) {\n\t\t\t\tnewScrollTop = nodeY + nodeHeight - containerHeight + bottomOfs;\n\t\t\t\t// this.debug(\"    scrollIntoView(), LOWER newScrollTop=\" + newScrollTop);\n\t\t\t\t// If a topNode was passed, make sure that it is never scrolled\n\t\t\t\t// outside the upper border\n\t\t\t\tif (topNode) {\n\t\t\t\t\t_assert(topNode.isRootNode() || $(topNode.span).is(\":visible\"), \"topNode must be visible\");\n\t\t\t\t\tif (topNodeY < newScrollTop) {\n\t\t\t\t\t\tnewScrollTop = topNodeY - topOfs;\n\t\t\t\t\t\t// this.debug(\"    scrollIntoView(), TOP newScrollTop=\" + newScrollTop);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newScrollTop !== null) {\n\t\t\t\t// this.debug(\"    scrollIntoView(), SET newScrollTop=\" + newScrollTop);\n\t\t\t\tif (opts.effects) {\n\t\t\t\t\topts.effects.complete = function () {\n\t\t\t\t\t\tdfd.resolveWith(that);\n\t\t\t\t\t};\n\t\t\t\t\t$animateTarget.stop(true).animate({\n\t\t\t\t\t\tscrollTop: newScrollTop\n\t\t\t\t\t}, opts.effects);\n\t\t\t\t} else {\n\t\t\t\t\t$animateTarget[0].scrollTop = newScrollTop;\n\t\t\t\t\tdfd.resolveWith(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdfd.resolveWith(this);\n\t\t\t}\n\t\t\treturn dfd.promise();\n\t\t},\n\n\t\t/**Activate this node.\n   * @param {boolean} [flag=true] pass false to deactivate\n   * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false}\n   * @returns {$.Promise}\n   */\n\t\tsetActive: function setActive(flag, opts) {\n\t\t\treturn this.tree._callHook(\"nodeSetActive\", this, flag, opts);\n\t\t},\n\t\t/**Expand or collapse this node. Promise is resolved, when lazy loading and animations are done.\n   * @param {boolean} [flag=true] pass false to collapse\n   * @param {object} [opts] additional options. Defaults to {noAnimation: false, noEvents: false}\n   * @returns {$.Promise}\n   */\n\t\tsetExpanded: function setExpanded(flag, opts) {\n\t\t\treturn this.tree._callHook(\"nodeSetExpanded\", this, flag, opts);\n\t\t},\n\t\t/**Set keyboard focus to this node.\n   * @param {boolean} [flag=true] pass false to blur\n   * @see Fancytree#setFocus\n   */\n\t\tsetFocus: function setFocus(flag) {\n\t\t\treturn this.tree._callHook(\"nodeSetFocus\", this, flag);\n\t\t},\n\t\t/**Select this node, i.e. check the checkbox.\n   * @param {boolean} [flag=true] pass false to deselect\n   */\n\t\tsetSelected: function setSelected(flag) {\n\t\t\treturn this.tree._callHook(\"nodeSetSelected\", this, flag);\n\t\t},\n\t\t/**Mark a lazy node as 'error', 'loading', 'nodata', or 'ok'.\n   * @param {string} status 'error'|'empty'|'ok'\n   * @param {string} [message]\n   * @param {string} [details]\n   */\n\t\tsetStatus: function setStatus(status, message, details) {\n\t\t\treturn this.tree._callHook(\"nodeSetStatus\", this, status, message, details);\n\t\t},\n\t\t/**Rename this node.\n   * @param {string} title\n   */\n\t\tsetTitle: function setTitle(title) {\n\t\t\tthis.title = title;\n\t\t\tthis.renderTitle();\n\t\t\tthis.triggerModify(\"rename\");\n\t\t},\n\t\t/**Sort child list by title.\n   * @param {function} [cmp] custom compare function(a, b) that returns -1, 0, or 1 (defaults to sort by title).\n   * @param {boolean} [deep=false] pass true to sort all descendant nodes\n   */\n\t\tsortChildren: function sortChildren(cmp, deep) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    cl = this.children;\n\n\t\t\tif (!cl) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcmp = cmp || function (a, b) {\n\t\t\t\tvar x = a.title.toLowerCase(),\n\t\t\t\t    y = b.title.toLowerCase();\n\t\t\t\treturn x === y ? 0 : x > y ? 1 : -1;\n\t\t\t};\n\t\t\tcl.sort(cmp);\n\t\t\tif (deep) {\n\t\t\t\tfor (i = 0, l = cl.length; i < l; i++) {\n\t\t\t\t\tif (cl[i].children) {\n\t\t\t\t\t\tcl[i].sortChildren(cmp, \"$norender$\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (deep !== \"$norender$\") {\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t\tthis.triggerModifyChild(\"sort\");\n\t\t},\n\t\t/** Convert node (or whole branch) into a plain object.\n   *\n   * The result is compatible with node.addChildren().\n   *\n   * @param {boolean} [recursive=false] include child nodes\n   * @param {function} [callback] callback(dict, node) is called for every node, in order to allow modifications\n   * @returns {NodeData}\n   */\n\t\ttoDict: function toDict(recursive, callback) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    node,\n\t\t\t    dict = {},\n\t\t\t    self = this;\n\n\t\t\t$.each(NODE_ATTRS, function (i, a) {\n\t\t\t\tif (self[a] || self[a] === false) {\n\t\t\t\t\tdict[a] = self[a];\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!$.isEmptyObject(this.data)) {\n\t\t\t\tdict.data = $.extend({}, this.data);\n\t\t\t\tif ($.isEmptyObject(dict.data)) {\n\t\t\t\t\tdelete dict.data;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (callback) {\n\t\t\t\tcallback(dict, self);\n\t\t\t}\n\t\t\tif (recursive) {\n\t\t\t\tif (this.hasChildren()) {\n\t\t\t\t\tdict.children = [];\n\t\t\t\t\tfor (i = 0, l = this.children.length; i < l; i++) {\n\t\t\t\t\t\tnode = this.children[i];\n\t\t\t\t\t\tif (!node.isStatusNode()) {\n\t\t\t\t\t\t\tdict.children.push(node.toDict(true, callback));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//                dict.children = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dict;\n\t\t},\n\t\t/**\n   * Set, clear, or toggle class of node's span tag and .extraClasses.\n   *\n   * @param {string} className class name (separate multiple classes by space)\n   * @param {boolean} [flag] true/false to add/remove class. If omitted, class is toggled.\n   * @returns {boolean} true if a class was added\n   *\n   * @since 2.17\n   */\n\t\ttoggleClass: function toggleClass(value, flag) {\n\t\t\tvar className,\n\t\t\t    hasClass,\n\t\t\t    rnotwhite = /\\S+/g,\n\t\t\t    classNames = value.match(rnotwhite) || [],\n\t\t\t    i = 0,\n\t\t\t    wasAdded = false,\n\t\t\t    statusElem = this[this.tree.statusClassPropName],\n\t\t\t    curClasses = \" \" + (this.extraClasses || \"\") + \" \";\n\n\t\t\t// this.info(\"toggleClass('\" + value + \"', \" + flag + \")\", curClasses);\n\t\t\t// Modify DOM element directly if it already exists\n\t\t\tif (statusElem) {\n\t\t\t\t$(statusElem).toggleClass(value, flag);\n\t\t\t}\n\t\t\t// Modify node.extraClasses to make this change persistent\n\t\t\t// Toggle if flag was not passed\n\t\t\twhile (className = classNames[i++]) {\n\t\t\t\thasClass = curClasses.indexOf(\" \" + className + \" \") >= 0;\n\t\t\t\tflag = flag === undefined ? !hasClass : !!flag;\n\t\t\t\tif (flag) {\n\t\t\t\t\tif (!hasClass) {\n\t\t\t\t\t\tcurClasses += className + \" \";\n\t\t\t\t\t\twasAdded = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (curClasses.indexOf(\" \" + className + \" \") > -1) {\n\t\t\t\t\t\tcurClasses = curClasses.replace(\" \" + className + \" \", \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.extraClasses = $.trim(curClasses);\n\t\t\t// this.info(\"-> toggleClass('\" + value + \"', \" + flag + \"): '\" + this.extraClasses + \"'\");\n\t\t\treturn wasAdded;\n\t\t},\n\t\t/** Flip expanded status.  */\n\t\ttoggleExpanded: function toggleExpanded() {\n\t\t\treturn this.tree._callHook(\"nodeToggleExpanded\", this);\n\t\t},\n\t\t/** Flip selection status.  */\n\t\ttoggleSelected: function toggleSelected() {\n\t\t\treturn this.tree._callHook(\"nodeToggleSelected\", this);\n\t\t},\n\t\ttoString: function toString() {\n\t\t\treturn \"<FancytreeNode(#\" + this.key + \", '\" + this.title + \"')>\";\n\t\t},\n\t\t/**\n   * Trigger `modifyChild` event on a parent to signal that a child was modified.\n   * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...\n   * @param {FancytreeNode} [childNode]\n   * @param {object} [extra]\n   */\n\t\ttriggerModifyChild: function triggerModifyChild(operation, childNode, extra) {\n\t\t\tvar data,\n\t\t\t    modifyChild = this.tree.options.modifyChild;\n\n\t\t\tif (modifyChild) {\n\t\t\t\tif (childNode && childNode.parent !== this) {\n\t\t\t\t\t$.error(\"childNode \" + childNode + \" is not a child of \" + this);\n\t\t\t\t}\n\t\t\t\tdata = {\n\t\t\t\t\tnode: this,\n\t\t\t\t\ttree: this.tree,\n\t\t\t\t\toperation: operation,\n\t\t\t\t\tchildNode: childNode || null\n\t\t\t\t};\n\t\t\t\tif (extra) {\n\t\t\t\t\t$.extend(data, extra);\n\t\t\t\t}\n\t\t\t\tmodifyChild({ type: \"modifyChild\" }, data);\n\t\t\t}\n\t\t},\n\t\t/**\n   * Trigger `modifyChild` event on node.parent(!).\n   * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...\n   * @param {object} [extra]\n   */\n\t\ttriggerModify: function triggerModify(operation, extra) {\n\t\t\tthis.parent.triggerModifyChild(operation, this, extra);\n\t\t},\n\t\t/** Call fn(node) for all child nodes.<br>\n   * Stop iteration, if fn() returns false. Skip current branch, if fn() returns \"skip\".<br>\n   * Return false if iteration was stopped.\n   *\n   * @param {function} fn the callback function.\n   *     Return false to stop iteration, return \"skip\" to skip this node and\n   *     its children only.\n   * @param {boolean} [includeSelf=false]\n   * @returns {boolean}\n   */\n\t\tvisit: function visit(fn, includeSelf) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    res = true,\n\t\t\t    children = this.children;\n\n\t\t\tif (includeSelf === true) {\n\t\t\t\tres = fn(this);\n\t\t\t\tif (res === false || res === \"skip\") {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (children) {\n\t\t\t\tfor (i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tres = children[i].visit(fn, true);\n\t\t\t\t\tif (res === false) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\t/** Call fn(node) for all child nodes and recursively load lazy children.<br>\n   * <b>Note:</b> If you need this method, you probably should consider to review\n   * your architecture! Recursivley loading nodes is a perfect way for lazy\n   * programmers to flood the server with requests ;-)\n   *\n   * @param {function} [fn] optional callback function.\n   *     Return false to stop iteration, return \"skip\" to skip this node and\n   *     its children only.\n   * @param {boolean} [includeSelf=false]\n   * @returns {$.Promise}\n   * @since 2.4\n   */\n\t\tvisitAndLoad: function visitAndLoad(fn, includeSelf, _recursion) {\n\t\t\tvar dfd,\n\t\t\t    res,\n\t\t\t    loaders,\n\t\t\t    node = this;\n\n\t\t\t// node.debug(\"visitAndLoad\");\n\t\t\tif (fn && includeSelf === true) {\n\t\t\t\tres = fn(node);\n\t\t\t\tif (res === false || res === \"skip\") {\n\t\t\t\t\treturn _recursion ? res : _getResolvedPromise();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!node.children && !node.lazy) {\n\t\t\t\treturn _getResolvedPromise();\n\t\t\t}\n\t\t\tdfd = new $.Deferred();\n\t\t\tloaders = [];\n\t\t\t// node.debug(\"load()...\");\n\t\t\tnode.load().done(function () {\n\t\t\t\t// node.debug(\"load()... done.\");\n\t\t\t\tfor (var i = 0, l = node.children.length; i < l; i++) {\n\t\t\t\t\tres = node.children[i].visitAndLoad(fn, true, true);\n\t\t\t\t\tif (res === false) {\n\t\t\t\t\t\tdfd.reject();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (res !== \"skip\") {\n\t\t\t\t\t\tloaders.push(res); // Add promise to the list\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$.when.apply(this, loaders).then(function () {\n\t\t\t\t\tdfd.resolve();\n\t\t\t\t});\n\t\t\t});\n\t\t\treturn dfd.promise();\n\t\t},\n\t\t/** Call fn(node) for all parent nodes, bottom-up, including invisible system root.<br>\n   * Stop iteration, if fn() returns false.<br>\n   * Return false if iteration was stopped.\n   *\n   * @param {function} fn the callback function.\n   *     Return false to stop iteration, return \"skip\" to skip this node and children only.\n   * @param {boolean} [includeSelf=false]\n   * @returns {boolean}\n   */\n\t\tvisitParents: function visitParents(fn, includeSelf) {\n\t\t\t// Visit parent nodes (bottom up)\n\t\t\tif (includeSelf && fn(this) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar p = this.parent;\n\t\t\twhile (p) {\n\t\t\t\tif (fn(p) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = p.parent;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/** Write warning to browser console (prepending node info)\n   *\n   * @param {*} msg string or object or array of such\n   */\n\t\twarn: function warn(msg) {\n\t\t\tArray.prototype.unshift.call(arguments, this.toString());\n\t\t\tconsoleApply(\"warn\", arguments);\n\t\t}\n\t};\n\n\t/* *****************************************************************************\n  * Fancytree\n  */\n\t/**\n  * Construct a new tree object.\n  *\n  * @class Fancytree\n  * @classdesc The controller behind a fancytree.\n  * This class also contains 'hook methods': see {@link Fancytree_Hooks}.\n  *\n  * @param {Widget} widget\n  *\n  * @property {string} _id Automatically generated unique tree instance ID, e.g. \"1\".\n  * @property {string} _ns Automatically generated unique tree namespace, e.g. \".fancytree-1\".\n  * @property {FancytreeNode} activeNode Currently active node or null.\n  * @property {string} ariaPropName Property name of FancytreeNode that contains the element which will receive the aria attributes.\n  *     Typically \"li\", but \"tr\" for table extension.\n  * @property {jQueryObject} $container Outer &lt;ul> element (or &lt;table> element for ext-table).\n  * @property {jQueryObject} $div A jQuery object containing the element used to instantiate the tree widget (`widget.element`)\n  * @property {object} data Metadata, i.e. properties that may be passed to `source` in addition to a children array.\n  * @property {object} ext Hash of all active plugin instances.\n  * @property {FancytreeNode} focusNode Currently focused node or null.\n  * @property {FancytreeNode} lastSelectedNode Used to implement selectMode 1 (single select)\n  * @property {string} nodeContainerAttrName Property name of FancytreeNode that contains the outer element of single nodes.\n  *     Typically \"li\", but \"tr\" for table extension.\n  * @property {FancytreeOptions} options Current options, i.e. default options + options passed to constructor.\n  * @property {FancytreeNode} rootNode Invisible system root node.\n  * @property {string} statusClassPropName Property name of FancytreeNode that contains the element which will receive the status classes.\n  *     Typically \"span\", but \"tr\" for table extension.\n  * @property {object} widget Base widget instance.\n  */\n\tfunction Fancytree(widget) {\n\t\tthis.widget = widget;\n\t\tthis.$div = widget.element;\n\t\tthis.options = widget.options;\n\t\tif (this.options) {\n\t\t\tif ($.isFunction(this.options.lazyload) && !$.isFunction(this.options.lazyLoad)) {\n\t\t\t\tthis.options.lazyLoad = function () {\n\t\t\t\t\tFT.warn(\"The 'lazyload' event is deprecated since 2014-02-25. Use 'lazyLoad' (with uppercase L) instead.\");\n\t\t\t\t\treturn widget.options.lazyload.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ($.isFunction(this.options.loaderror)) {\n\t\t\t\t$.error(\"The 'loaderror' event was renamed since 2014-07-03. Use 'loadError' (with uppercase E) instead.\");\n\t\t\t}\n\t\t\tif (this.options.fx !== undefined) {\n\t\t\t\tFT.warn(\"The 'fx' option was replaced by 'toggleEffect' since 2014-11-30.\");\n\t\t\t}\n\t\t\tif (this.options.removeNode !== undefined) {\n\t\t\t\t$.error(\"The 'removeNode' event was replaced by 'modifyChild' since 2.20 (2016-09-10).\");\n\t\t\t}\n\t\t}\n\t\tthis.ext = {}; // Active extension instances\n\t\t// allow to init tree.data.foo from <div data-foo=''>\n\t\tthis.data = _getElementDataAsDict(this.$div);\n\t\t// TODO: use widget.uuid instead?\n\t\tthis._id = $.ui.fancytree._nextId++;\n\t\t// TODO: use widget.eventNamespace instead?\n\t\tthis._ns = \".fancytree-\" + this._id; // append for namespaced events\n\t\tthis.activeNode = null;\n\t\tthis.focusNode = null;\n\t\tthis._hasFocus = null;\n\t\tthis._enableUpdate = true;\n\t\t// this._dirtyRoots = null;\n\t\tthis.lastSelectedNode = null;\n\t\tthis.systemFocusElement = null;\n\t\tthis.lastQuicksearchTerm = \"\";\n\t\tthis.lastQuicksearchTime = 0;\n\n\t\tthis.statusClassPropName = \"span\";\n\t\tthis.ariaPropName = \"li\";\n\t\tthis.nodeContainerAttrName = \"li\";\n\n\t\t// Remove previous markup if any\n\t\tthis.$div.find(\">ul.fancytree-container\").remove();\n\n\t\t// Create a node without parent.\n\t\tvar fakeParent = { tree: this },\n\t\t    $ul;\n\t\tthis.rootNode = new FancytreeNode(fakeParent, {\n\t\t\ttitle: \"root\",\n\t\t\tkey: \"root_\" + this._id,\n\t\t\tchildren: null,\n\t\t\texpanded: true\n\t\t});\n\t\tthis.rootNode.parent = null;\n\n\t\t// Create root markup\n\t\t$ul = $(\"<ul>\", {\n\t\t\t\"class\": \"ui-fancytree fancytree-container fancytree-plain\"\n\t\t}).appendTo(this.$div);\n\t\tthis.$container = $ul;\n\t\tthis.rootNode.ul = $ul[0];\n\n\t\tif (this.options.debugLevel == null) {\n\t\t\tthis.options.debugLevel = FT.debugLevel;\n\t\t}\n\t\t// Add container to the TAB chain\n\t\t// See http://www.w3.org/TR/wai-aria-practices/#focus_activedescendant\n\t\t// #577: Allow to set tabindex to \"0\", \"-1\" and \"\"\n\t\tthis.$container.attr(\"tabindex\", this.options.tabindex);\n\n\t\tif (this.options.rtl) {\n\t\t\tthis.$container.attr(\"DIR\", \"RTL\").addClass(\"fancytree-rtl\");\n\t\t\t// }else{\n\t\t\t//\tthis.$container.attr(\"DIR\", null).removeClass(\"fancytree-rtl\");\n\t\t}\n\t\tif (this.options.aria) {\n\t\t\tthis.$container.attr(\"role\", \"tree\");\n\t\t\tif (this.options.selectMode !== 1) {\n\t\t\t\tthis.$container.attr(\"aria-multiselectable\", true);\n\t\t\t}\n\t\t}\n\t}\n\n\tFancytree.prototype = /** @lends Fancytree# */{\n\t\t/* Return a context object that can be re-used for _callHook().\n   * @param {Fancytree | FancytreeNode | EventData} obj\n   * @param {Event} originalEvent\n   * @param {Object} extra\n   * @returns {EventData}\n   */\n\t\t_makeHookContext: function _makeHookContext(obj, originalEvent, extra) {\n\t\t\tvar ctx, tree;\n\t\t\tif (obj.node !== undefined) {\n\t\t\t\t// obj is already a context object\n\t\t\t\tif (originalEvent && obj.originalEvent !== originalEvent) {\n\t\t\t\t\t$.error(\"invalid args\");\n\t\t\t\t}\n\t\t\t\tctx = obj;\n\t\t\t} else if (obj.tree) {\n\t\t\t\t// obj is a FancytreeNode\n\t\t\t\ttree = obj.tree;\n\t\t\t\tctx = { node: obj, tree: tree, widget: tree.widget, options: tree.widget.options, originalEvent: originalEvent };\n\t\t\t} else if (obj.widget) {\n\t\t\t\t// obj is a Fancytree\n\t\t\t\tctx = { node: null, tree: obj, widget: obj.widget, options: obj.widget.options, originalEvent: originalEvent };\n\t\t\t} else {\n\t\t\t\t$.error(\"invalid args\");\n\t\t\t}\n\t\t\tif (extra) {\n\t\t\t\t$.extend(ctx, extra);\n\t\t\t}\n\t\t\treturn ctx;\n\t\t},\n\t\t/* Trigger a hook function: funcName(ctx, [...]).\n   *\n   * @param {string} funcName\n   * @param {Fancytree|FancytreeNode|EventData} contextObject\n   * @param {any}  [_extraArgs] optional additional arguments\n   * @returns {any}\n   */\n\t\t_callHook: function _callHook(funcName, contextObject, _extraArgs) {\n\t\t\tvar ctx = this._makeHookContext(contextObject),\n\t\t\t    fn = this[funcName],\n\t\t\t    args = Array.prototype.slice.call(arguments, 2);\n\t\t\tif (!$.isFunction(fn)) {\n\t\t\t\t$.error(\"_callHook('\" + funcName + \"') is not a function\");\n\t\t\t}\n\t\t\targs.unshift(ctx);\n\t\t\t//\t\tthis.debug(\"_hook\", funcName, ctx.node && ctx.node.toString() || ctx.tree.toString(), args);\n\t\t\treturn fn.apply(this, args);\n\t\t},\n\t\t/* Check if current extensions dependencies are met and throw an error if not.\n   *\n   * This method may be called inside the `treeInit` hook for custom extensions.\n   *\n   * @param {string} extension name of the required extension\n   * @param {boolean} [required=true] pass `false` if the extension is optional, but we want to check for order if it is present\n   * @param {boolean} [before] `true` if `name` must be included before this, `false` otherwise (use `null` if order doesn't matter)\n   * @param {string} [message] optional error message (defaults to a descriptve error message)\n   */\n\t\t_requireExtension: function _requireExtension(name, required, before, message) {\n\t\t\tbefore = !!before;\n\t\t\tvar thisName = this._local.name,\n\t\t\t    extList = this.options.extensions,\n\t\t\t    isBefore = $.inArray(name, extList) < $.inArray(thisName, extList),\n\t\t\t    isMissing = required && this.ext[name] == null,\n\t\t\t    badOrder = !isMissing && before != null && before !== isBefore;\n\n\t\t\t_assert(thisName && thisName !== name, \"invalid or same name\");\n\n\t\t\tif (isMissing || badOrder) {\n\t\t\t\tif (!message) {\n\t\t\t\t\tif (isMissing || required) {\n\t\t\t\t\t\tmessage = \"'\" + thisName + \"' extension requires '\" + name + \"'\";\n\t\t\t\t\t\tif (badOrder) {\n\t\t\t\t\t\t\tmessage += \" to be registered \" + (before ? \"before\" : \"after\") + \" itself\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage = \"If used together, `\" + name + \"` must be registered \" + (before ? \"before\" : \"after\") + \" `\" + thisName + \"`\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$.error(message);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/** Activate node with a given key and fire focus and activate events.\n   *\n   * A prevously activated node will be deactivated.\n   * If activeVisible option is set, all parents will be expanded as necessary.\n   * Pass key = false, to deactivate the current node only.\n   * @param {string} key\n   * @returns {FancytreeNode} activated node (null, if not found)\n   */\n\t\tactivateKey: function activateKey(key) {\n\t\t\tvar node = this.getNodeByKey(key);\n\t\t\tif (node) {\n\t\t\t\tnode.setActive();\n\t\t\t} else if (this.activeNode) {\n\t\t\t\tthis.activeNode.setActive(false);\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\t\t/** (experimental) Add child status nodes that indicate 'More...', ....\n   * @param {boolean|object} node optional node definition. Pass `false` to remove all paging nodes.\n   * @param {string} [mode='append'] 'child'|firstChild'\n   * @since 2.15\n   */\n\t\taddPagingNode: function addPagingNode(node, mode) {\n\t\t\treturn this.rootNode.addPagingNode(node, mode);\n\t\t},\n\t\t/** (experimental) Modify existing data model.\n   *\n   * @param {Array} patchList array of [key, NodePatch] arrays\n   * @returns {$.Promise} resolved, when all patches have been applied\n   * @see TreePatch\n   */\n\t\tapplyPatch: function applyPatch(patchList) {\n\t\t\tvar dfd,\n\t\t\t    i,\n\t\t\t    p2,\n\t\t\t    key,\n\t\t\t    patch,\n\t\t\t    node,\n\t\t\t    patchCount = patchList.length,\n\t\t\t    deferredList = [];\n\n\t\t\tfor (i = 0; i < patchCount; i++) {\n\t\t\t\tp2 = patchList[i];\n\t\t\t\t_assert(p2.length === 2, \"patchList must be an array of length-2-arrays\");\n\t\t\t\tkey = p2[0];\n\t\t\t\tpatch = p2[1];\n\t\t\t\tnode = key === null ? this.rootNode : this.getNodeByKey(key);\n\t\t\t\tif (node) {\n\t\t\t\t\tdfd = new $.Deferred();\n\t\t\t\t\tdeferredList.push(dfd);\n\t\t\t\t\tnode.applyPatch(patch).always(_makeResolveFunc(dfd, node));\n\t\t\t\t} else {\n\t\t\t\t\tthis.warn(\"could not find node with key '\" + key + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return a promise that is resolved, when ALL patches were applied\n\t\t\treturn $.when.apply($, deferredList).promise();\n\t\t},\n\t\t/* TODO: implement in dnd extension\n  cancelDrag: function() {\n  \tvar dd = $.ui.ddmanager.current;\n  \tif(dd){\n  \t\tdd.cancel();\n  \t}\n  },\n    */\n\t\t/** Remove all nodes.\n   * @since 2.14\n   */\n\t\tclear: function clear(source) {\n\t\t\tthis._callHook(\"treeClear\", this);\n\t\t},\n\t\t/** Return the number of nodes.\n  * @returns {integer}\n  */\n\t\tcount: function count() {\n\t\t\treturn this.rootNode.countChildren();\n\t\t},\n\t\t/** Write to browser console if debugLevel >= 2 (prepending tree name)\n   *\n   * @param {*} msg string or object or array of such\n   */\n\t\tdebug: function debug(msg) {\n\t\t\tif (this.options.debugLevel >= 2) {\n\t\t\t\tArray.prototype.unshift.call(arguments, this.toString());\n\t\t\t\tconsoleApply(\"log\", arguments);\n\t\t\t}\n\t\t},\n\t\t// TODO: disable()\n\t\t// TODO: enable()\n\t\t/** Temporarily suppress rendering to improve performance on bulk-updates.\n   *\n   * @param {boolean} flag\n   * @returns {boolean} previous status\n   * @since 2.19\n   */\n\t\tenableUpdate: function enableUpdate(flag) {\n\t\t\tflag = flag !== false;\n\t\t\t/*jshint -W018 */ // Confusing use of '!'\n\t\t\tif (!!this._enableUpdate === !!flag) {\n\t\t\t\treturn flag;\n\t\t\t}\n\t\t\t/*jshint +W018 */\n\t\t\tthis._enableUpdate = flag;\n\t\t\tif (flag) {\n\t\t\t\tthis.debug(\"enableUpdate(true): redraw \", this._dirtyRoots);\n\t\t\t\tthis.render();\n\t\t\t} else {\n\t\t\t\t// \tthis._dirtyRoots = null;\n\t\t\t\tthis.debug(\"enableUpdate(false)...\");\n\t\t\t}\n\t\t\treturn !flag; // return previous value\n\t\t},\n\t\t/**Find all nodes that matches condition.\n   *\n   * @param {string | function(node)} match title string to search for, or a\n   *     callback function that returns `true` if a node is matched.\n   * @returns {FancytreeNode[]} array of nodes (may be empty)\n   * @see FancytreeNode#findAll\n   * @since 2.12\n   */\n\t\tfindAll: function findAll(match) {\n\t\t\treturn this.rootNode.findAll(match);\n\t\t},\n\t\t/**Find first node that matches condition.\n   *\n   * @param {string | function(node)} match title string to search for, or a\n   *     callback function that returns `true` if a node is matched.\n   * @returns {FancytreeNode} matching node or null\n   * @see FancytreeNode#findFirst\n   * @since 2.12\n   */\n\t\tfindFirst: function findFirst(match) {\n\t\t\treturn this.rootNode.findFirst(match);\n\t\t},\n\t\t/** Find the next visible node that starts with `match`, starting at `startNode`\n   * and wrap-around at the end.\n   *\n   * @param {string|function} match\n   * @param {FancytreeNode} [startNode] defaults to first node\n   * @returns {FancytreeNode} matching node or null\n   */\n\t\tfindNextNode: function findNextNode(match, startNode, visibleOnly) {\n\t\t\tvar stopNode = null,\n\t\t\t    parentChildren = startNode.parent.children,\n\t\t\t    matchingNode = null,\n\t\t\t    walkVisible = function walkVisible(parent, idx, fn) {\n\t\t\t\tvar i,\n\t\t\t\t    grandParent,\n\t\t\t\t    parentChildren = parent.children,\n\t\t\t\t    siblingCount = parentChildren.length,\n\t\t\t\t    node = parentChildren[idx];\n\t\t\t\t// visit node itself\n\t\t\t\tif (node && fn(node) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// visit descendants\n\t\t\t\tif (node && node.children && node.expanded) {\n\t\t\t\t\tif (walkVisible(node, 0, fn) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// visit subsequent siblings\n\t\t\t\tfor (i = idx + 1; i < siblingCount; i++) {\n\t\t\t\t\tif (walkVisible(parent, i, fn) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// visit parent's subsequent siblings\n\t\t\t\tgrandParent = parent.parent;\n\t\t\t\tif (grandParent) {\n\t\t\t\t\treturn walkVisible(grandParent, grandParent.children.indexOf(parent) + 1, fn);\n\t\t\t\t} else {\n\t\t\t\t\t// wrap-around: restart with first node\n\t\t\t\t\treturn walkVisible(parent, 0, fn);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch = typeof match === \"string\" ? _makeNodeTitleStartMatcher(match) : match;\n\t\t\tstartNode = startNode || this.getFirstChild();\n\n\t\t\twalkVisible(startNode.parent, parentChildren.indexOf(startNode), function (node) {\n\t\t\t\t// Stop iteration if we see the start node a second time\n\t\t\t\tif (node === stopNode) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tstopNode = stopNode || node;\n\t\t\t\t// Ignore nodes hidden by a filter\n\t\t\t\tif (!$(node.span).is(\":visible\")) {\n\t\t\t\t\tnode.debug(\"quicksearch: skipping hidden node\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Test if we found a match, but search for a second match if this\n\t\t\t\t// was the currently active node\n\t\t\t\tif (match(node)) {\n\t\t\t\t\t// node.debug(\"quicksearch match \" + node.title, startNode);\n\t\t\t\t\tmatchingNode = node;\n\t\t\t\t\tif (matchingNode !== startNode) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn matchingNode;\n\t\t},\n\t\t// TODO: fromDict\n\t\t/**\n   * Generate INPUT elements that can be submitted with html forms.\n   *\n   * In selectMode 3 only the topmost selected nodes are considered, unless\n   * `opts.stopOnParents: false` is passed.\n   *\n   * @example\n   * // Generate input elements for active and selected nodes\n   * tree.generateFormElements();\n   * // Generate input elements selected nodes, using a custom `name` attribute\n   * tree.generateFormElements(\"cust_sel\", false);\n   * // Generate input elements using a custom filter\n   * tree.generateFormElements(true, true, { filter: function(node) {\n   *     return node.isSelected() && node.data.yes;\n   * }});\n   *\n   * @param {boolean | string} [selected=true] Pass false to disable, pass a string to override the field name (default: 'ft_ID[]')\n   * @param {boolean | string} [active=true] Pass false to disable, pass a string to override the field name (default: 'ft_ID_active')\n   * @param {object} [opts] default { filter: null, stopOnParents: true }\n   */\n\t\tgenerateFormElements: function generateFormElements(selected, active, opts) {\n\t\t\topts = opts || {};\n\n\t\t\tvar nodeList,\n\t\t\t    selectedName = typeof selected === \"string\" ? selected : \"ft_\" + this._id + \"[]\",\n\t\t\t    activeName = typeof active === \"string\" ? active : \"ft_\" + this._id + \"_active\",\n\t\t\t    id = \"fancytree_result_\" + this._id,\n\t\t\t    $result = $(\"#\" + id),\n\t\t\t    stopOnParents = this.options.selectMode === 3 && opts.stopOnParents !== false;\n\n\t\t\tif ($result.length) {\n\t\t\t\t$result.empty();\n\t\t\t} else {\n\t\t\t\t$result = $(\"<div>\", {\n\t\t\t\t\tid: id\n\t\t\t\t}).hide().insertAfter(this.$container);\n\t\t\t}\n\t\t\tif (active !== false && this.activeNode) {\n\t\t\t\t$result.append($(\"<input>\", {\n\t\t\t\t\ttype: \"radio\",\n\t\t\t\t\tname: activeName,\n\t\t\t\t\tvalue: this.activeNode.key,\n\t\t\t\t\tchecked: true\n\t\t\t\t}));\n\t\t\t}\n\t\t\tfunction _appender(node) {\n\t\t\t\t$result.append($(\"<input>\", {\n\t\t\t\t\ttype: \"checkbox\",\n\t\t\t\t\tname: selectedName,\n\t\t\t\t\tvalue: node.key,\n\t\t\t\t\tchecked: true\n\t\t\t\t}));\n\t\t\t}\n\t\t\tif (opts.filter) {\n\t\t\t\tthis.visit(function (node) {\n\t\t\t\t\tvar res = opts.filter(node);\n\t\t\t\t\tif (res === \"skip\") {\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t\tif (res !== false) {\n\t\t\t\t\t\t_appender(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (selected !== false) {\n\t\t\t\tnodeList = this.getSelectedNodes(stopOnParents);\n\t\t\t\t$.each(nodeList, function (idx, node) {\n\t\t\t\t\t_appender(node);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**\n   * Return the currently active node or null.\n   * @returns {FancytreeNode}\n   */\n\t\tgetActiveNode: function getActiveNode() {\n\t\t\treturn this.activeNode;\n\t\t},\n\t\t/** Return the first top level node if any (not the invisible root node).\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetFirstChild: function getFirstChild() {\n\t\t\treturn this.rootNode.getFirstChild();\n\t\t},\n\t\t/**\n   * Return node that has keyboard focus or null.\n   * @returns {FancytreeNode}\n   */\n\t\tgetFocusNode: function getFocusNode() {\n\t\t\treturn this.focusNode;\n\t\t},\n\t\t/**\n   * Return node with a given key or null if not found.\n   * @param {string} key\n   * @param {FancytreeNode} [searchRoot] only search below this node\n   * @returns {FancytreeNode | null}\n   */\n\t\tgetNodeByKey: function getNodeByKey(key, searchRoot) {\n\t\t\t// Search the DOM by element ID (assuming this is faster than traversing all nodes).\n\t\t\t// $(\"#...\") has problems, if the key contains '.', so we use getElementById()\n\t\t\tvar el, match;\n\t\t\tif (!searchRoot) {\n\t\t\t\tel = document.getElementById(this.options.idPrefix + key);\n\t\t\t\tif (el) {\n\t\t\t\t\treturn el.ftnode ? el.ftnode : null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Not found in the DOM, but still may be in an unrendered part of tree\n\t\t\t// TODO: optimize with specialized loop\n\t\t\t// TODO: consider keyMap?\n\t\t\tsearchRoot = searchRoot || this.rootNode;\n\t\t\tmatch = null;\n\t\t\tsearchRoot.visit(function (node) {\n\t\t\t\t//            window.console.log(\"getNodeByKey(\" + key + \"): \", node.key);\n\t\t\t\tif (node.key === key) {\n\t\t\t\t\tmatch = node;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}, true);\n\t\t\treturn match;\n\t\t},\n\t\t/** Return the invisible system root node.\n   * @returns {FancytreeNode}\n   */\n\t\tgetRootNode: function getRootNode() {\n\t\t\treturn this.rootNode;\n\t\t},\n\t\t/**\n   * Return an array of selected nodes.\n   * @param {boolean} [stopOnParents=false] only return the topmost selected\n   *     node (useful with selectMode 3)\n   * @returns {FancytreeNode[]}\n   */\n\t\tgetSelectedNodes: function getSelectedNodes(stopOnParents) {\n\t\t\treturn this.rootNode.getSelectedNodes(stopOnParents);\n\t\t},\n\t\t/** Return true if the tree control has keyboard focus\n   * @returns {boolean}\n   */\n\t\thasFocus: function hasFocus() {\n\t\t\treturn !!this._hasFocus;\n\t\t},\n\t\t/** Write to browser console if debugLevel >= 1 (prepending tree name)\n   * @param {*} msg string or object or array of such\n   */\n\t\tinfo: function info(msg) {\n\t\t\tif (this.options.debugLevel >= 1) {\n\t\t\t\tArray.prototype.unshift.call(arguments, this.toString());\n\t\t\t\tconsoleApply(\"info\", arguments);\n\t\t\t}\n\t\t},\n\t\t/*\n  \tTODO: isInitializing: function() {\n  \t\treturn ( this.phase==\"init\" || this.phase==\"postInit\" );\n  \t},\n  \tTODO: isReloading: function() {\n  \t\treturn ( this.phase==\"init\" || this.phase==\"postInit\" ) && this.options.persist && this.persistence.cookiesFound;\n  \t},\n  \tTODO: isUserEvent: function() {\n  \t\treturn ( this.phase==\"userEvent\" );\n  \t},\n  */\n\n\t\t/**\n   * Make sure that a node with a given ID is loaded, by traversing - and\n   * loading - its parents. This method is ment for lazy hierarchies.\n   * A callback is executed for every node as we go.\n   * @example\n   * tree.loadKeyPath(\"/_3/_23/_26/_27\", function(node, status){\n   *   if(status === \"loaded\") {\n   *     console.log(\"loaded intermiediate node \" + node);\n   *   }else if(status === \"ok\") {\n   *     node.activate();\n   *   }\n   * });\n   *\n   * @param {string | string[]} keyPathList one or more key paths (e.g. '/3/2_1/7')\n   * @param {function} callback callback(node, status) is called for every visited node ('loading', 'loaded', 'ok', 'error')\n   * @returns {$.Promise}\n   */\n\t\tloadKeyPath: function loadKeyPath(keyPathList, callback, _rootNode) {\n\t\t\tvar deferredList,\n\t\t\t    dfd,\n\t\t\t    i,\n\t\t\t    path,\n\t\t\t    key,\n\t\t\t    loadMap,\n\t\t\t    node,\n\t\t\t    root,\n\t\t\t    segList,\n\t\t\t    sep = this.options.keyPathSeparator,\n\t\t\t    self = this;\n\n\t\t\tcallback = callback || $.noop;\n\t\t\tif (!$.isArray(keyPathList)) {\n\t\t\t\tkeyPathList = [keyPathList];\n\t\t\t}\n\t\t\t// Pass 1: handle all path segments for nodes that are already loaded\n\t\t\t// Collect distinct top-most lazy nodes in a map\n\t\t\tloadMap = {};\n\n\t\t\tfor (i = 0; i < keyPathList.length; i++) {\n\t\t\t\troot = _rootNode || this.rootNode;\n\t\t\t\tpath = keyPathList[i];\n\t\t\t\t// strip leading slash\n\t\t\t\tif (path.charAt(0) === sep) {\n\t\t\t\t\tpath = path.substr(1);\n\t\t\t\t}\n\t\t\t\t// traverse and strip keys, until we hit a lazy, unloaded node\n\t\t\t\tsegList = path.split(sep);\n\t\t\t\twhile (segList.length) {\n\t\t\t\t\tkey = segList.shift();\n\t\t\t\t\t//                node = _findDirectChild(root, key);\n\t\t\t\t\tnode = root._findDirectChild(key);\n\t\t\t\t\tif (!node) {\n\t\t\t\t\t\tthis.warn(\"loadKeyPath: key not found: \" + key + \" (parent: \" + root + \")\");\n\t\t\t\t\t\tcallback.call(this, key, \"error\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (segList.length === 0) {\n\t\t\t\t\t\tcallback.call(this, node, \"ok\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (!node.lazy || node.hasChildren() !== undefined) {\n\t\t\t\t\t\tcallback.call(this, node, \"loaded\");\n\t\t\t\t\t\troot = node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback.call(this, node, \"loaded\");\n\t\t\t\t\t\t//                    segList.unshift(key);\n\t\t\t\t\t\tif (loadMap[key]) {\n\t\t\t\t\t\t\tloadMap[key].push(segList.join(sep));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tloadMap[key] = [segList.join(sep)];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//        alert(\"loadKeyPath: loadMap=\" + JSON.stringify(loadMap));\n\t\t\t// Now load all lazy nodes and continue itearation for remaining paths\n\t\t\tdeferredList = [];\n\t\t\t// Avoid jshint warning 'Don't make functions within a loop.':\n\t\t\tfunction __lazyload(key, node, dfd) {\n\t\t\t\tcallback.call(self, node, \"loading\");\n\t\t\t\tnode.load().done(function () {\n\t\t\t\t\tself.loadKeyPath.call(self, loadMap[key], callback, node).always(_makeResolveFunc(dfd, self));\n\t\t\t\t}).fail(function (errMsg) {\n\t\t\t\t\tself.warn(\"loadKeyPath: error loading: \" + key + \" (parent: \" + root + \")\");\n\t\t\t\t\tcallback.call(self, node, \"error\");\n\t\t\t\t\tdfd.reject();\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (key in loadMap) {\n\t\t\t\tnode = root._findDirectChild(key);\n\t\t\t\tif (node == null) {\n\t\t\t\t\t// #576\n\t\t\t\t\tnode = self.getNodeByKey(key);\n\t\t\t\t}\n\t\t\t\tdfd = new $.Deferred();\n\t\t\t\tdeferredList.push(dfd);\n\t\t\t\t__lazyload(key, node, dfd);\n\t\t\t}\n\t\t\t// Return a promise that is resolved, when ALL paths were loaded\n\t\t\treturn $.when.apply($, deferredList).promise();\n\t\t},\n\t\t/** Re-fire beforeActivate, activate, and (optional) focus events.\n   * Calling this method in the `init` event, will activate the node that\n   * was marked 'active' in the source data, and optionally set the keyboard\n   * focus.\n   * @param [setFocus=false]\n   */\n\t\treactivate: function reactivate(setFocus) {\n\t\t\tvar res,\n\t\t\t    node = this.activeNode;\n\n\t\t\tif (!node) {\n\t\t\t\treturn _getResolvedPromise();\n\t\t\t}\n\t\t\tthis.activeNode = null; // Force re-activating\n\t\t\tres = node.setActive(true, { noFocus: true });\n\t\t\tif (setFocus) {\n\t\t\t\tnode.setFocus();\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\t/** Reload tree from source and return a promise.\n   * @param [source] optional new source (defaults to initial source data)\n   * @returns {$.Promise}\n   */\n\t\treload: function reload(source) {\n\t\t\tthis._callHook(\"treeClear\", this);\n\t\t\treturn this._callHook(\"treeLoad\", this, source);\n\t\t},\n\t\t/**Render tree (i.e. create DOM elements for all top-level nodes).\n   * @param {boolean} [force=false] create DOM elemnts, even if parent is collapsed\n   * @param {boolean} [deep=false]\n   */\n\t\trender: function render(force, deep) {\n\t\t\treturn this.rootNode.render(force, deep);\n\t\t},\n\t\t// TODO: selectKey: function(key, select)\n\t\t// TODO: serializeArray: function(stopOnParents)\n\t\t/**\n   * @param {boolean} [flag=true]\n   */\n\t\tsetFocus: function setFocus(flag) {\n\t\t\treturn this._callHook(\"treeSetFocus\", this, flag);\n\t\t},\n\t\t/**\n   * Return all nodes as nested list of {@link NodeData}.\n   *\n   * @param {boolean} [includeRoot=false] Returns the hidden system root node (and its children)\n   * @param {function} [callback] callback(dict, node) is called for every node, in order to allow modifications\n   * @returns {Array | object}\n   * @see FancytreeNode#toDict\n   */\n\t\ttoDict: function toDict(includeRoot, callback) {\n\t\t\tvar res = this.rootNode.toDict(true, callback);\n\t\t\treturn includeRoot ? res : res.children;\n\t\t},\n\t\t/* Implicitly called for string conversions.\n   * @returns {string}\n   */\n\t\ttoString: function toString() {\n\t\t\treturn \"<Fancytree(#\" + this._id + \")>\";\n\t\t},\n\t\t/* _trigger a widget event with additional node ctx.\n   * @see EventData\n   */\n\t\t_triggerNodeEvent: function _triggerNodeEvent(type, node, originalEvent, extra) {\n\t\t\t//\t\tthis.debug(\"_trigger(\" + type + \"): '\" + ctx.node.title + \"'\", ctx);\n\t\t\tvar ctx = this._makeHookContext(node, originalEvent, extra),\n\t\t\t    res = this.widget._trigger(type, originalEvent, ctx);\n\t\t\tif (res !== false && ctx.result !== undefined) {\n\t\t\t\treturn ctx.result;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\t/* _trigger a widget event with additional tree data. */\n\t\t_triggerTreeEvent: function _triggerTreeEvent(type, originalEvent, extra) {\n\t\t\t//\t\tthis.debug(\"_trigger(\" + type + \")\", ctx);\n\t\t\tvar ctx = this._makeHookContext(this, originalEvent, extra),\n\t\t\t    res = this.widget._trigger(type, originalEvent, ctx);\n\n\t\t\tif (res !== false && ctx.result !== undefined) {\n\t\t\t\treturn ctx.result;\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\t/** Call fn(node) for all nodes.\n   *\n   * @param {function} fn the callback function.\n   *     Return false to stop iteration, return \"skip\" to skip this node and children only.\n   * @returns {boolean} false, if the iterator was stopped.\n   */\n\t\tvisit: function visit(fn) {\n\t\t\treturn this.rootNode.visit(fn, false);\n\t\t},\n\t\t/** Write warning to browser console (prepending tree info)\n   *\n   * @param {*} msg string or object or array of such\n   */\n\t\twarn: function warn(msg) {\n\t\t\tArray.prototype.unshift.call(arguments, this.toString());\n\t\t\tconsoleApply(\"warn\", arguments);\n\t\t}\n\t};\n\n\t/**\n  * These additional methods of the {@link Fancytree} class are 'hook functions'\n  * that can be used and overloaded by extensions.\n  * (See <a href=\"https://github.com/mar10/fancytree/wiki/TutorialExtensions\">writing extensions</a>.)\n  * @mixin Fancytree_Hooks\n  */\n\t$.extend(Fancytree.prototype,\n\t/** @lends Fancytree_Hooks# */\n\t{\n\t\t/** Default handling for mouse click events.\n   *\n   * @param {EventData} ctx\n   */\n\t\tnodeClick: function nodeClick(ctx) {\n\t\t\tvar activate,\n\t\t\t    expand,\n\n\t\t\t// event = ctx.originalEvent,\n\t\t\ttargetType = ctx.targetType,\n\t\t\t    node = ctx.node;\n\n\t\t\t//\t    this.debug(\"ftnode.onClick(\" + event.type + \"): ftnode:\" + this + \", button:\" + event.button + \", which: \" + event.which, ctx);\n\t\t\t// TODO: use switch\n\t\t\t// TODO: make sure clicks on embedded <input> doesn't steal focus (see table sample)\n\t\t\tif (targetType === \"expander\") {\n\t\t\t\tif (node.isLoading()) {\n\t\t\t\t\t// #495: we probably got a click event while a lazy load is pending.\n\t\t\t\t\t// The 'expanded' state is not yet set, so 'toggle' would expand\n\t\t\t\t\t// and trigger lazyLoad again.\n\t\t\t\t\t// It would be better to allow to collapse/expand the status node\n\t\t\t\t\t// while loading (instead of ignoring), but that would require some\n\t\t\t\t\t// more work.\n\t\t\t\t\tnode.debug(\"Got 2nd click while loading: ignored\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// Clicking the expander icon always expands/collapses\n\t\t\t\tthis._callHook(\"nodeToggleExpanded\", ctx);\n\t\t\t} else if (targetType === \"checkbox\") {\n\t\t\t\t// Clicking the checkbox always (de)selects\n\t\t\t\tthis._callHook(\"nodeToggleSelected\", ctx);\n\t\t\t\tif (ctx.options.focusOnSelect) {\n\t\t\t\t\t// #358\n\t\t\t\t\tthis._callHook(\"nodeSetFocus\", ctx, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Honor `clickFolderMode` for\n\t\t\t\texpand = false;\n\t\t\t\tactivate = true;\n\t\t\t\tif (node.folder) {\n\t\t\t\t\tswitch (ctx.options.clickFolderMode) {\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t// expand only\n\t\t\t\t\t\t\texpand = true;\n\t\t\t\t\t\t\tactivate = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t// expand and activate\n\t\t\t\t\t\t\tactivate = true;\n\t\t\t\t\t\t\texpand = true; //!node.isExpanded();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// else 1 or 4: just activate\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (activate) {\n\t\t\t\t\tthis.nodeSetFocus(ctx);\n\t\t\t\t\tthis._callHook(\"nodeSetActive\", ctx, true);\n\t\t\t\t}\n\t\t\t\tif (expand) {\n\t\t\t\t\tif (!activate) {}\n\t\t\t\t\t//                    this._callHook(\"nodeSetFocus\", ctx);\n\n\t\t\t\t\t//\t\t\t\tthis._callHook(\"nodeSetExpanded\", ctx, true);\n\t\t\t\t\tthis._callHook(\"nodeToggleExpanded\", ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Make sure that clicks stop, otherwise <a href='#'> jumps to the top\n\t\t\t// if(event.target.localName === \"a\" && event.target.className === \"fancytree-title\"){\n\t\t\t// \tevent.preventDefault();\n\t\t\t// }\n\t\t\t// TODO: return promise?\n\t\t},\n\t\t/** Collapse all other  children of same parent.\n   *\n   * @param {EventData} ctx\n   * @param {object} callOpts\n   */\n\t\tnodeCollapseSiblings: function nodeCollapseSiblings(ctx, callOpts) {\n\t\t\t// TODO: return promise?\n\t\t\tvar ac,\n\t\t\t    i,\n\t\t\t    l,\n\t\t\t    node = ctx.node;\n\n\t\t\tif (node.parent) {\n\t\t\t\tac = node.parent.children;\n\t\t\t\tfor (i = 0, l = ac.length; i < l; i++) {\n\t\t\t\t\tif (ac[i] !== node && ac[i].expanded) {\n\t\t\t\t\t\tthis._callHook(\"nodeSetExpanded\", ac[i], false, callOpts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/** Default handling for mouse douleclick events.\n   * @param {EventData} ctx\n   */\n\t\tnodeDblclick: function nodeDblclick(ctx) {\n\t\t\t// TODO: return promise?\n\t\t\tif (ctx.targetType === \"title\" && ctx.options.clickFolderMode === 4) {\n\t\t\t\t//\t\t\tthis.nodeSetFocus(ctx);\n\t\t\t\t//\t\t\tthis._callHook(\"nodeSetActive\", ctx, true);\n\t\t\t\tthis._callHook(\"nodeToggleExpanded\", ctx);\n\t\t\t}\n\t\t\t// TODO: prevent text selection on dblclicks\n\t\t\tif (ctx.targetType === \"title\") {\n\t\t\t\tctx.originalEvent.preventDefault();\n\t\t\t}\n\t\t},\n\t\t/** Default handling for mouse keydown events.\n   *\n   * NOTE: this may be called with node == null if tree (but no node) has focus.\n   * @param {EventData} ctx\n   */\n\t\tnodeKeydown: function nodeKeydown(ctx) {\n\t\t\t// TODO: return promise?\n\t\t\tvar matchNode,\n\t\t\t    stamp,\n\t\t\t    res,\n\t\t\t    focusNode,\n\t\t\t    event = ctx.originalEvent,\n\t\t\t    node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options,\n\t\t\t    which = event.which,\n\t\t\t    whichChar = String.fromCharCode(which),\n\t\t\t    clean = !(event.altKey || event.ctrlKey || event.metaKey || event.shiftKey),\n\t\t\t    $target = $(event.target),\n\t\t\t    handled = true,\n\t\t\t    activate = !(event.ctrlKey || !opts.autoActivate);\n\n\t\t\t// (node || FT).debug(\"ftnode.nodeKeydown(\" + event.type + \"): ftnode:\" + this + \", charCode:\" + event.charCode + \", keyCode: \" + event.keyCode + \", which: \" + event.which);\n\t\t\t// FT.debug(\"eventToString\", which, '\"' + String.fromCharCode(which) + '\"', '\"' + FT.eventToString(event) + '\"');\n\n\t\t\t// Set focus to active (or first node) if no other node has the focus yet\n\t\t\tif (!node) {\n\t\t\t\tfocusNode = this.getActiveNode() || this.getFirstChild();\n\t\t\t\tif (focusNode) {\n\t\t\t\t\tfocusNode.setFocus();\n\t\t\t\t\tnode = ctx.node = this.focusNode;\n\t\t\t\t\tnode.debug(\"Keydown force focus on active node\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (opts.quicksearch && clean && /\\w/.test(whichChar) && !SPECIAL_KEYCODES[which] && // #659\n\t\t\t!$target.is(\":input:enabled\")) {\n\t\t\t\t// Allow to search for longer streaks if typed in quickly\n\t\t\t\tstamp = new Date().getTime();\n\t\t\t\tif (stamp - tree.lastQuicksearchTime > 500) {\n\t\t\t\t\ttree.lastQuicksearchTerm = \"\";\n\t\t\t\t}\n\t\t\t\ttree.lastQuicksearchTime = stamp;\n\t\t\t\ttree.lastQuicksearchTerm += whichChar;\n\t\t\t\t// tree.debug(\"quicksearch find\", tree.lastQuicksearchTerm);\n\t\t\t\tmatchNode = tree.findNextNode(tree.lastQuicksearchTerm, tree.getActiveNode());\n\t\t\t\tif (matchNode) {\n\t\t\t\t\tmatchNode.setActive();\n\t\t\t\t}\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tswitch (FT.eventToString(event)) {\n\t\t\t\tcase \"+\":\n\t\t\t\tcase \"=\":\n\t\t\t\t\t// 187: '+' @ Chrome, Safari\n\t\t\t\t\ttree.nodeSetExpanded(ctx, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"-\":\n\t\t\t\t\ttree.nodeSetExpanded(ctx, false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"space\":\n\t\t\t\t\tif (node.isPagingNode()) {\n\t\t\t\t\t\ttree._triggerNodeEvent(\"clickPaging\", ctx, event);\n\t\t\t\t\t} else if (opts.checkbox) {\n\t\t\t\t\t\ttree.nodeToggleSelected(ctx);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttree.nodeSetActive(ctx, true);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"return\":\n\t\t\t\t\ttree.nodeSetActive(ctx, true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"home\":\n\t\t\t\tcase \"end\":\n\t\t\t\tcase \"backspace\":\n\t\t\t\tcase \"left\":\n\t\t\t\tcase \"right\":\n\t\t\t\tcase \"up\":\n\t\t\t\tcase \"down\":\n\t\t\t\t\tres = node.navigate(event.which, activate, true);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\thandled = false;\n\t\t\t}\n\t\t\tif (handled) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t// /** Default handling for mouse keypress events. */\n\t\t// nodeKeypress: function(ctx) {\n\t\t//     var event = ctx.originalEvent;\n\t\t// },\n\n\t\t// /** Trigger lazyLoad event (async). */\n\t\t// nodeLazyLoad: function(ctx) {\n\t\t//     var node = ctx.node;\n\t\t//     if(this._triggerNodeEvent())\n\t\t// },\n\t\t/** Load child nodes (async).\n   *\n   * @param {EventData} ctx\n   * @param {object[]|object|string|$.Promise|function} source\n   * @returns {$.Promise} The deferred will be resolved as soon as the (ajax)\n   *     data was rendered.\n   */\n\t\tnodeLoadChildren: function nodeLoadChildren(ctx, source) {\n\t\t\tvar ajax,\n\t\t\t    delay,\n\t\t\t    dfd,\n\t\t\t    tree = ctx.tree,\n\t\t\t    node = ctx.node,\n\t\t\t    requestId = new Date().getTime();\n\n\t\t\tif ($.isFunction(source)) {\n\t\t\t\tsource = source.call(tree, { type: \"source\" }, ctx);\n\t\t\t\t_assert(!$.isFunction(source), \"source callback must not return another function\");\n\t\t\t}\n\t\t\tif (source.url) {\n\t\t\t\tif (node._requestId) {\n\t\t\t\t\tnode.warn(\"Recursive load request #\" + requestId + \" while #\" + node._requestId + \" is pending.\");\n\t\t\t\t\t// } else {\n\t\t\t\t\t// \tnode.debug(\"Send load request #\" + requestId);\n\t\t\t\t}\n\t\t\t\t// `source` is an Ajax options object\n\t\t\t\tajax = $.extend({}, ctx.options.ajax, source);\n\t\t\t\tnode._requestId = requestId;\n\t\t\t\tif (ajax.debugDelay) {\n\t\t\t\t\t// simulate a slow server\n\t\t\t\t\tdelay = ajax.debugDelay;\n\t\t\t\t\tif ($.isArray(delay)) {\n\t\t\t\t\t\t// random delay range [min..max]\n\t\t\t\t\t\tdelay = delay[0] + Math.random() * (delay[1] - delay[0]);\n\t\t\t\t\t}\n\t\t\t\t\tnode.warn(\"nodeLoadChildren waiting debugDelay \" + Math.round(delay) + \" ms ...\");\n\t\t\t\t\tajax.debugDelay = false;\n\t\t\t\t\tdfd = $.Deferred(function (dfd) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t$.ajax(ajax).done(function () {\n\t\t\t\t\t\t\t\tdfd.resolveWith(this, arguments);\n\t\t\t\t\t\t\t}).fail(function () {\n\t\t\t\t\t\t\t\tdfd.rejectWith(this, arguments);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, delay);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdfd = $.ajax(ajax);\n\t\t\t\t}\n\n\t\t\t\t// Defer the deferred: we want to be able to reject, even if ajax\n\t\t\t\t// resolved ok.\n\t\t\t\tsource = new $.Deferred();\n\t\t\t\tdfd.done(function (data, textStatus, jqXHR) {\n\t\t\t\t\tvar errorObj, res;\n\n\t\t\t\t\tif ((this.dataType === \"json\" || this.dataType === \"jsonp\") && typeof data === \"string\") {\n\t\t\t\t\t\t$.error(\"Ajax request returned a string (did you get the JSON dataType wrong?).\");\n\t\t\t\t\t}\n\t\t\t\t\tif (node._requestId && node._requestId > requestId) {\n\t\t\t\t\t\t// The expected request time stamp is later than `requestId`\n\t\t\t\t\t\t// (which was kept as as closure variable to this handler function)\n\t\t\t\t\t\t// node.warn(\"Ignored load response for obsolete request #\" + requestId + \" (expected #\" + node._requestId + \")\");\n\t\t\t\t\t\tsource.rejectWith(this, [RECURSIVE_REQUEST_ERROR]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\t// } else {\n\t\t\t\t\t\t// \tnode.debug(\"Response returned for load request #\" + requestId);\n\t\t\t\t\t}\n\t\t\t\t\t// postProcess is similar to the standard ajax dataFilter hook,\n\t\t\t\t\t// but it is also called for JSONP\n\t\t\t\t\tif (ctx.options.postProcess) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tres = tree._triggerNodeEvent(\"postProcess\", ctx, ctx.originalEvent, {\n\t\t\t\t\t\t\t\tresponse: data, error: null, dataType: this.dataType\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tres = { error: e, message: \"\" + e, details: \"postProcess failed\" };\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\t\terrorObj = $.isPlainObject(res.error) ? res.error : { message: res.error };\n\t\t\t\t\t\t\terrorObj = tree._makeHookContext(node, null, errorObj);\n\t\t\t\t\t\t\tsource.rejectWith(this, [errorObj]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata = $.isArray(res) ? res : data;\n\t\t\t\t\t} else if (data && data.hasOwnProperty(\"d\") && ctx.options.enableAspx) {\n\t\t\t\t\t\t// Process ASPX WebMethod JSON object inside \"d\" property\n\t\t\t\t\t\tdata = typeof data.d === \"string\" ? $.parseJSON(data.d) : data.d;\n\t\t\t\t\t}\n\t\t\t\t\tsource.resolveWith(this, [data]);\n\t\t\t\t}).fail(function (jqXHR, textStatus, errorThrown) {\n\t\t\t\t\tvar errorObj = tree._makeHookContext(node, null, {\n\t\t\t\t\t\terror: jqXHR,\n\t\t\t\t\t\targs: Array.prototype.slice.call(arguments),\n\t\t\t\t\t\tmessage: errorThrown,\n\t\t\t\t\t\tdetails: jqXHR.status + \": \" + errorThrown\n\t\t\t\t\t});\n\t\t\t\t\tsource.rejectWith(this, [errorObj]);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// #383: accept and convert ECMAScript 6 Promise\n\t\t\tif ($.isFunction(source.then) && $.isFunction(source[\"catch\"])) {\n\t\t\t\tdfd = source;\n\t\t\t\tsource = new $.Deferred();\n\t\t\t\tdfd.then(function (value) {\n\t\t\t\t\tsource.resolve(value);\n\t\t\t\t}, function (reason) {\n\t\t\t\t\tsource.reject(reason);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ($.isFunction(source.promise)) {\n\t\t\t\t// `source` is a deferred, i.e. ajax request\n\t\t\t\t// _assert(!node.isLoading(), \"recursive load\");\n\t\t\t\ttree.nodeSetStatus(ctx, \"loading\");\n\n\t\t\t\tsource.done(function (children) {\n\t\t\t\t\ttree.nodeSetStatus(ctx, \"ok\");\n\t\t\t\t\tnode._requestId = null;\n\t\t\t\t}).fail(function (error) {\n\t\t\t\t\tvar ctxErr;\n\n\t\t\t\t\tif (error === RECURSIVE_REQUEST_ERROR) {\n\t\t\t\t\t\tnode.warn(\"Ignored response for obsolete load request #\" + requestId + \" (expected #\" + node._requestId + \")\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (error.node && error.error && error.message) {\n\t\t\t\t\t\t// error is already a context object\n\t\t\t\t\t\tctxErr = error;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctxErr = tree._makeHookContext(node, null, {\n\t\t\t\t\t\t\terror: error, // it can be jqXHR or any custom error\n\t\t\t\t\t\t\targs: Array.prototype.slice.call(arguments),\n\t\t\t\t\t\t\tmessage: error ? error.message || error.toString() : \"\"\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (ctxErr.message === \"[object Object]\") {\n\t\t\t\t\t\t\tctxErr.message = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnode.warn(\"Load children failed (\" + ctxErr.message + \")\", ctxErr);\n\t\t\t\t\tif (tree._triggerNodeEvent(\"loadError\", ctxErr, null) !== false) {\n\t\t\t\t\t\ttree.nodeSetStatus(ctx, \"error\", ctxErr.message, ctxErr.details);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t// $.when(source) resolves also for non-deferreds\n\t\t\treturn $.when(source).done(function (children) {\n\t\t\t\tvar metaData;\n\n\t\t\t\tif ($.isPlainObject(children)) {\n\t\t\t\t\t// We got {foo: 'abc', children: [...]}\n\t\t\t\t\t// Copy extra properties to tree.data.foo\n\t\t\t\t\t_assert(node.isRootNode(), \"source may only be an object for root nodes (expecting an array of child objects otherwise)\");\n\t\t\t\t\t_assert($.isArray(children.children), \"if an object is passed as source, it must contain a 'children' array (all other properties are added to 'tree.data')\");\n\t\t\t\t\tmetaData = children;\n\t\t\t\t\tchildren = children.children;\n\t\t\t\t\tdelete metaData.children;\n\t\t\t\t\t$.extend(tree.data, metaData);\n\t\t\t\t}\n\t\t\t\t_assert($.isArray(children), \"expected array of children\");\n\t\t\t\tnode._setChildren(children);\n\t\t\t\t// trigger fancytreeloadchildren\n\t\t\t\ttree._triggerNodeEvent(\"loadChildren\", node);\n\t\t\t});\n\t\t},\n\t\t/** [Not Implemented]  */\n\t\tnodeLoadKeyPath: function nodeLoadKeyPath(ctx, keyPathList) {\n\t\t\t// TODO: implement and improve\n\t\t\t// http://code.google.com/p/dynatree/issues/detail?id=222\n\t\t},\n\t\t/**\n   * Remove a single direct child of ctx.node.\n   * @param {EventData} ctx\n   * @param {FancytreeNode} childNode dircect child of ctx.node\n   */\n\t\tnodeRemoveChild: function nodeRemoveChild(ctx, childNode) {\n\t\t\tvar idx,\n\t\t\t    node = ctx.node,\n\n\t\t\t// opts = ctx.options,\n\t\t\tsubCtx = $.extend({}, ctx, { node: childNode }),\n\t\t\t    children = node.children;\n\n\t\t\t// FT.debug(\"nodeRemoveChild()\", node.toString(), childNode.toString());\n\n\t\t\tif (children.length === 1) {\n\t\t\t\t_assert(childNode === children[0], \"invalid single child\");\n\t\t\t\treturn this.nodeRemoveChildren(ctx);\n\t\t\t}\n\t\t\tif (this.activeNode && (childNode === this.activeNode || this.activeNode.isDescendantOf(childNode))) {\n\t\t\t\tthis.activeNode.setActive(false); // TODO: don't fire events\n\t\t\t}\n\t\t\tif (this.focusNode && (childNode === this.focusNode || this.focusNode.isDescendantOf(childNode))) {\n\t\t\t\tthis.focusNode = null;\n\t\t\t}\n\t\t\t// TODO: persist must take care to clear select and expand cookies\n\t\t\tthis.nodeRemoveMarkup(subCtx);\n\t\t\tthis.nodeRemoveChildren(subCtx);\n\t\t\tidx = $.inArray(childNode, children);\n\t\t\t_assert(idx >= 0, \"invalid child\");\n\t\t\t// Notify listeners\n\t\t\tnode.triggerModifyChild(\"remove\", childNode);\n\t\t\t// Unlink to support GC\n\t\t\tchildNode.visit(function (n) {\n\t\t\t\tn.parent = null;\n\t\t\t}, true);\n\t\t\tthis._callHook(\"treeRegisterNode\", this, false, childNode);\n\t\t\t// remove from child list\n\t\t\tchildren.splice(idx, 1);\n\t\t},\n\t\t/**Remove HTML markup for all descendents of ctx.node.\n   * @param {EventData} ctx\n   */\n\t\tnodeRemoveChildMarkup: function nodeRemoveChildMarkup(ctx) {\n\t\t\tvar node = ctx.node;\n\n\t\t\t// FT.debug(\"nodeRemoveChildMarkup()\", node.toString());\n\t\t\t// TODO: Unlink attr.ftnode to support GC\n\t\t\tif (node.ul) {\n\t\t\t\tif (node.isRootNode()) {\n\t\t\t\t\t$(node.ul).empty();\n\t\t\t\t} else {\n\t\t\t\t\t$(node.ul).remove();\n\t\t\t\t\tnode.ul = null;\n\t\t\t\t}\n\t\t\t\tnode.visit(function (n) {\n\t\t\t\t\tn.li = n.ul = null;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t/**Remove all descendants of ctx.node.\n  * @param {EventData} ctx\n  */\n\t\tnodeRemoveChildren: function nodeRemoveChildren(ctx) {\n\t\t\tvar subCtx,\n\t\t\t    tree = ctx.tree,\n\t\t\t    node = ctx.node,\n\t\t\t    children = node.children;\n\t\t\t// opts = ctx.options;\n\n\t\t\t// FT.debug(\"nodeRemoveChildren()\", node.toString());\n\t\t\tif (!children) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.activeNode && this.activeNode.isDescendantOf(node)) {\n\t\t\t\tthis.activeNode.setActive(false); // TODO: don't fire events\n\t\t\t}\n\t\t\tif (this.focusNode && this.focusNode.isDescendantOf(node)) {\n\t\t\t\tthis.focusNode = null;\n\t\t\t}\n\t\t\t// TODO: persist must take care to clear select and expand cookies\n\t\t\tthis.nodeRemoveChildMarkup(ctx);\n\t\t\t// Unlink children to support GC\n\t\t\t// TODO: also delete this.children (not possible using visit())\n\t\t\tsubCtx = $.extend({}, ctx);\n\t\t\tnode.triggerModifyChild(\"remove\", null);\n\t\t\tnode.visit(function (n) {\n\t\t\t\tn.parent = null;\n\t\t\t\ttree._callHook(\"treeRegisterNode\", tree, false, n);\n\t\t\t});\n\t\t\tif (node.lazy) {\n\t\t\t\t// 'undefined' would be interpreted as 'not yet loaded' for lazy nodes\n\t\t\t\tnode.children = [];\n\t\t\t} else {\n\t\t\t\tnode.children = null;\n\t\t\t}\n\t\t\tif (!node.isRootNode()) {\n\t\t\t\tnode.expanded = false; // #449, #459\n\t\t\t}\n\t\t\tthis.nodeRenderStatus(ctx);\n\t\t},\n\t\t/**Remove HTML markup for ctx.node and all its descendents.\n   * @param {EventData} ctx\n   */\n\t\tnodeRemoveMarkup: function nodeRemoveMarkup(ctx) {\n\t\t\tvar node = ctx.node;\n\t\t\t// FT.debug(\"nodeRemoveMarkup()\", node.toString());\n\t\t\t// TODO: Unlink attr.ftnode to support GC\n\t\t\tif (node.li) {\n\t\t\t\t$(node.li).remove();\n\t\t\t\tnode.li = null;\n\t\t\t}\n\t\t\tthis.nodeRemoveChildMarkup(ctx);\n\t\t},\n\t\t/**\n   * Create `&lt;li>&lt;span>..&lt;/span> .. &lt;/li>` tags for this node.\n   *\n   * This method takes care that all HTML markup is created that is required\n   * to display this node in its current state.\n   *\n   * Call this method to create new nodes, or after the strucuture\n   * was changed (e.g. after moving this node or adding/removing children)\n   * nodeRenderTitle() and nodeRenderStatus() are implied.\n   *\n   * Note: if a node was created/removed, nodeRender() must be called for the\n   *       parent.\n   * &lt;code>\n   * &lt;li id='KEY' ftnode=NODE>\n   *     &lt;span class='fancytree-node fancytree-expanded fancytree-has-children fancytree-lastsib fancytree-exp-el fancytree-ico-e'>\n   *         &lt;span class=\"fancytree-expander\">&lt;/span>\n   *         &lt;span class=\"fancytree-checkbox\">&lt;/span> // only present in checkbox mode\n   *         &lt;span class=\"fancytree-icon\">&lt;/span>\n   *         &lt;a href=\"#\" class=\"fancytree-title\"> Node 1 &lt;/a>\n   *     &lt;/span>\n   *     &lt;ul> // only present if node has children\n   *         &lt;li id='KEY' ftnode=NODE> child1 ... &lt;/li>\n   *         &lt;li id='KEY' ftnode=NODE> child2 ... &lt;/li>\n   *     &lt;/ul>\n   * &lt;/li>\n   * &lt;/code>\n   *\n   * @param {EventData} ctx\n   * @param {boolean} [force=false] re-render, even if html markup was already created\n   * @param {boolean} [deep=false] also render all descendants, even if parent is collapsed\n   * @param {boolean} [collapsed=false] force root node to be collapsed, so we can apply animated expand later\n   */\n\t\tnodeRender: function nodeRender(ctx, force, deep, collapsed, _recursive) {\n\t\t\t/* This method must take care of all cases where the current data mode\n    * (i.e. node hierarchy) does not match the current markup.\n    *\n    * - node was not yet rendered:\n    *   create markup\n    * - node was rendered: exit fast\n    * - children have been added\n    * - children have been removed\n    */\n\t\t\tvar childLI,\n\t\t\t    childNode1,\n\t\t\t    childNode2,\n\t\t\t    i,\n\t\t\t    l,\n\t\t\t    next,\n\t\t\t    subCtx,\n\t\t\t    node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options,\n\t\t\t    aria = opts.aria,\n\t\t\t    firstTime = false,\n\t\t\t    parent = node.parent,\n\t\t\t    isRootNode = !parent,\n\t\t\t    children = node.children,\n\t\t\t    successorLi = null;\n\t\t\t// FT.debug(\"nodeRender(\" + !!force + \", \" + !!deep + \")\", node.toString());\n\n\t\t\tif (tree._enableUpdate === false) {\n\t\t\t\t// tree.debug(\"no render\", tree._enableUpdate);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!isRootNode && !parent.ul) {\n\t\t\t\t// Calling node.collapse on a deep, unrendered node\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t_assert(isRootNode || parent.ul, \"parent UL must exist\");\n\n\t\t\t// Render the node\n\t\t\tif (!isRootNode) {\n\t\t\t\t// Discard markup on force-mode, or if it is not linked to parent <ul>\n\t\t\t\tif (node.li && (force || node.li.parentNode !== node.parent.ul)) {\n\t\t\t\t\tif (node.li.parentNode === node.parent.ul) {\n\t\t\t\t\t\t// #486: store following node, so we can insert the new markup there later\n\t\t\t\t\t\tsuccessorLi = node.li.nextSibling;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// May happen, when a top-level node was dropped over another\n\t\t\t\t\t\tthis.debug(\"Unlinking \" + node + \" (must be child of \" + node.parent + \")\");\n\t\t\t\t\t}\n\t\t\t\t\t//\t            this.debug(\"nodeRemoveMarkup...\");\n\t\t\t\t\tthis.nodeRemoveMarkup(ctx);\n\t\t\t\t}\n\t\t\t\t// Create <li><span /> </li>\n\t\t\t\t//\t\t\tnode.debug(\"render...\");\n\t\t\t\tif (!node.li) {\n\t\t\t\t\t//\t            node.debug(\"render... really\");\n\t\t\t\t\tfirstTime = true;\n\t\t\t\t\tnode.li = document.createElement(\"li\");\n\t\t\t\t\tnode.li.ftnode = node;\n\n\t\t\t\t\t// We set role 'treeitem' to the title span instead\n\t\t\t\t\tif (aria) {\n\t\t\t\t\t\t// TODO: why does the next line don't work:\n\t\t\t\t\t\t// node.li.role = \"treeitem\";\n\t\t\t\t\t\t// $(node.li).attr(\"role\", \"treeitem\");\n\t\t\t\t\t\t// .attr(\"aria-labelledby\", \"ftal_\" + opts.idPrefix + node.key);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.key && opts.generateIds) {\n\t\t\t\t\t\tnode.li.id = opts.idPrefix + node.key;\n\t\t\t\t\t}\n\t\t\t\t\tnode.span = document.createElement(\"span\");\n\t\t\t\t\tnode.span.className = \"fancytree-node\";\n\t\t\t\t\tif (aria) {\n\t\t\t\t\t\t$(node.li).attr(\"aria-labelledby\", \"ftal_\" + opts.idPrefix + node.key);\n\t\t\t\t\t\t// $(node.span).attr(\"aria-labelledby\", \"ftal_\" + opts.idPrefix + node.key);\n\t\t\t\t\t}\n\t\t\t\t\tnode.li.appendChild(node.span);\n\n\t\t\t\t\t// Create inner HTML for the <span> (expander, checkbox, icon, and title)\n\t\t\t\t\tthis.nodeRenderTitle(ctx);\n\n\t\t\t\t\t// Allow tweaking and binding, after node was created for the first time\n\t\t\t\t\tif (opts.createNode) {\n\t\t\t\t\t\topts.createNode.call(tree, { type: \"createNode\" }, ctx);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//\t\t\t\tthis.nodeRenderTitle(ctx);\n\t\t\t\t\tthis.nodeRenderStatus(ctx);\n\t\t\t\t}\n\t\t\t\t// Allow tweaking after node state was rendered\n\t\t\t\tif (opts.renderNode) {\n\t\t\t\t\topts.renderNode.call(tree, { type: \"renderNode\" }, ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Visit child nodes\n\t\t\tif (children) {\n\t\t\t\tif (isRootNode || node.expanded || deep === true) {\n\t\t\t\t\t// Create a UL to hold the children\n\t\t\t\t\tif (!node.ul) {\n\t\t\t\t\t\tnode.ul = document.createElement(\"ul\");\n\t\t\t\t\t\tif (collapsed === true && !_recursive || !node.expanded) {\n\t\t\t\t\t\t\t// hide top UL, so we can use an animation to show it later\n\t\t\t\t\t\t\tnode.ul.style.display = \"none\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (aria) {\n\t\t\t\t\t\t\t$(node.ul).attr(\"role\", \"group\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (node.li) {\n\t\t\t\t\t\t\t// issue #67\n\t\t\t\t\t\t\tnode.li.appendChild(node.ul);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode.tree.$div.append(node.ul);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add child markup\n\t\t\t\t\tfor (i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\t\tsubCtx = $.extend({}, ctx, { node: children[i] });\n\t\t\t\t\t\tthis.nodeRender(subCtx, force, deep, false, true);\n\t\t\t\t\t}\n\t\t\t\t\t// Remove <li> if nodes have moved to another parent\n\t\t\t\t\tchildLI = node.ul.firstChild;\n\t\t\t\t\twhile (childLI) {\n\t\t\t\t\t\tchildNode2 = childLI.ftnode;\n\t\t\t\t\t\tif (childNode2 && childNode2.parent !== node) {\n\t\t\t\t\t\t\tnode.debug(\"_fixParent: remove missing \" + childNode2, childLI);\n\t\t\t\t\t\t\tnext = childLI.nextSibling;\n\t\t\t\t\t\t\tchildLI.parentNode.removeChild(childLI);\n\t\t\t\t\t\t\tchildLI = next;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchildLI = childLI.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Make sure, that <li> order matches node.children order.\n\t\t\t\t\tchildLI = node.ul.firstChild;\n\t\t\t\t\tfor (i = 0, l = children.length - 1; i < l; i++) {\n\t\t\t\t\t\tchildNode1 = children[i];\n\t\t\t\t\t\tchildNode2 = childLI.ftnode;\n\t\t\t\t\t\tif (childNode1 !== childNode2) {\n\t\t\t\t\t\t\t// node.debug(\"_fixOrder: mismatch at index \" + i + \": \" + childNode1 + \" != \" + childNode2);\n\t\t\t\t\t\t\tnode.ul.insertBefore(childNode1.li, childNode2.li);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchildLI = childLI.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No children: remove markup if any\n\t\t\t\tif (node.ul) {\n\t\t\t\t\t//\t\t\t\talert(\"remove child markup for \" + node);\n\t\t\t\t\tthis.warn(\"remove child markup for \" + node);\n\t\t\t\t\tthis.nodeRemoveChildMarkup(ctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isRootNode) {\n\t\t\t\t// Update element classes according to node state\n\t\t\t\t// this.nodeRenderStatus(ctx);\n\t\t\t\t// Finally add the whole structure to the DOM, so the browser can render\n\t\t\t\tif (firstTime) {\n\t\t\t\t\t// #486: successorLi is set, if we re-rendered (i.e. discarded)\n\t\t\t\t\t// existing markup, which  we want to insert at the same position.\n\t\t\t\t\t// (null is equivalent to append)\n\t\t\t\t\t//\t\t\t\tparent.ul.appendChild(node.li);\n\t\t\t\t\tparent.ul.insertBefore(node.li, successorLi);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/** Create HTML inside the node's outer &lt;span> (i.e. expander, checkbox,\n   * icon, and title).\n   *\n   * nodeRenderStatus() is implied.\n   * @param {EventData} ctx\n   * @param {string} [title] optinal new title\n   */\n\t\tnodeRenderTitle: function nodeRenderTitle(ctx, title) {\n\t\t\t// set node connector images, links and text\n\t\t\tvar id,\n\t\t\t    icon,\n\t\t\t    nodeTitle,\n\t\t\t    role,\n\t\t\t    tabindex,\n\t\t\t    tooltip,\n\t\t\t    node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options,\n\t\t\t    aria = opts.aria,\n\t\t\t    level = node.getLevel(),\n\t\t\t    ares = [];\n\n\t\t\tif (title !== undefined) {\n\t\t\t\tnode.title = title;\n\t\t\t}\n\t\t\tif (!node.span || tree._enableUpdate === false) {\n\t\t\t\t// Silently bail out if node was not rendered yet, assuming\n\t\t\t\t// node.render() will be called as the node becomes visible\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Connector (expanded, expandable or simple)\n\t\t\tif (level < opts.minExpandLevel) {\n\t\t\t\tif (!node.lazy) {\n\t\t\t\t\tnode.expanded = true;\n\t\t\t\t}\n\t\t\t\tif (level > 1) {\n\t\t\t\t\tif (aria) {\n\t\t\t\t\t\tares.push(\"<span role='button' class='fancytree-expander fancytree-expander-fixed'></span>\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tares.push(\"<span class='fancytree-expander fancytree-expander-fixed''></span>\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// .. else (i.e. for root level) skip expander/connector alltogether\n\t\t\t} else {\n\t\t\t\tif (aria) {\n\t\t\t\t\tares.push(\"<span role='button' class='fancytree-expander'></span>\");\n\t\t\t\t} else {\n\t\t\t\t\tares.push(\"<span class='fancytree-expander'></span>\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Checkbox mode\n\t\t\tif (opts.checkbox && node.hideCheckbox !== true && !node.isStatusNode()) {\n\t\t\t\tif (aria) {\n\t\t\t\t\tares.push(\"<span role='checkbox' class='fancytree-checkbox'></span>\");\n\t\t\t\t} else {\n\t\t\t\t\tares.push(\"<span class='fancytree-checkbox'></span>\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Folder or doctype icon\n\t\t\tif (node.data.iconClass !== undefined) {\n\t\t\t\t// 2015-11-16\n\t\t\t\t// Handle / warn about backward compatibility\n\t\t\t\tif (node.icon) {\n\t\t\t\t\t$.error(\"'iconClass' node option is deprecated since v2.14.0: use 'icon' only instead\");\n\t\t\t\t} else {\n\t\t\t\t\tnode.warn(\"'iconClass' node option is deprecated since v2.14.0: use 'icon' instead\");\n\t\t\t\t\tnode.icon = node.data.iconClass;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If opts.icon is a callback and returns something other than undefined, use that\n\t\t\t// else if node.icon is a boolean or string, use that\n\t\t\t// else if opts.icon is a boolean or string, use that\n\t\t\t// else show standard icon (which may be different for folders or documents)\n\t\t\tif ($.isFunction(opts.icon)) {\n\t\t\t\ticon = opts.icon.call(tree, { type: \"icon\" }, ctx);\n\t\t\t\tif (icon == null) {\n\t\t\t\t\ticon = node.icon;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ticon = node.icon != null ? node.icon : opts.icon;\n\t\t\t}\n\t\t\tif (icon == null) {\n\t\t\t\ticon = true; // no icon option at all: show default icon\n\t\t\t} else {\n\t\t\t\tif (typeof icon !== \"boolean\") {\n\t\t\t\t\t// icon is defined, but not true/false: must be a string\n\t\t\t\t\ticon = \"\" + icon;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (icon !== false) {\n\t\t\t\trole = aria ? \" role='img'\" : \"\";\n\t\t\t\tif (typeof icon === \"string\") {\n\t\t\t\t\tif (TEST_IMG.test(icon)) {\n\t\t\t\t\t\t// node.icon is an image url. Prepend imagePath\n\t\t\t\t\t\ticon = icon.charAt(0) === \"/\" ? icon : (opts.imagePath || \"\") + icon;\n\t\t\t\t\t\tares.push(\"<img src='\" + icon + \"' class='fancytree-icon' alt='' />\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tares.push(\"<span \" + role + \" class='fancytree-custom-icon \" + icon + \"'></span>\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// standard icon: theme css will take care of this\n\t\t\t\t\tares.push(\"<span \" + role + \" class='fancytree-icon'></span>\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Node title\n\t\t\tnodeTitle = \"\";\n\t\t\tif (opts.renderTitle) {\n\t\t\t\tnodeTitle = opts.renderTitle.call(tree, { type: \"renderTitle\" }, ctx) || \"\";\n\t\t\t}\n\t\t\tif (!nodeTitle) {\n\t\t\t\tif (node.tooltip) {\n\t\t\t\t\ttooltip = node.tooltip;\n\t\t\t\t} else if (opts.tooltip) {\n\t\t\t\t\ttooltip = opts.tooltip === true ? node.title : opts.tooltip.call(tree, node);\n\t\t\t\t}\n\t\t\t\ttooltip = tooltip ? \" title='\" + _escapeTooltip(tooltip) + \"'\" : \"\";\n\t\t\t\tid = aria ? \" id='ftal_\" + opts.idPrefix + node.key + \"'\" : \"\";\n\t\t\t\t// role = \"\";\n\t\t\t\trole = aria ? \" role='treeitem'\" : \"\";\n\t\t\t\ttabindex = opts.titlesTabbable ? \" tabindex='0'\" : \"\";\n\n\t\t\t\tnodeTitle = \"<span \" + role + \" class='fancytree-title'\" + id + tooltip + tabindex + \">\" + (opts.escapeTitles ? _escapeHtml(node.title) : node.title) + \"</span>\";\n\t\t\t}\n\t\t\tares.push(nodeTitle);\n\t\t\t// Note: this will trigger focusout, if node had the focus\n\t\t\t//$(node.span).html(ares.join(\"\")); // it will cleanup the jQuery data currently associated with SPAN (if any), but it executes more slowly\n\t\t\tnode.span.innerHTML = ares.join(\"\");\n\t\t\t// Update CSS classes\n\t\t\tthis.nodeRenderStatus(ctx);\n\t\t\tif (opts.enhanceTitle) {\n\t\t\t\tctx.$title = $(\">span.fancytree-title\", node.span);\n\t\t\t\tnodeTitle = opts.enhanceTitle.call(tree, { type: \"enhanceTitle\" }, ctx) || \"\";\n\t\t\t}\n\t\t},\n\t\t/** Update element classes according to node state.\n   * @param {EventData} ctx\n   */\n\t\tnodeRenderStatus: function nodeRenderStatus(ctx) {\n\t\t\t// Set classes for current status\n\t\t\tvar node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options,\n\n\t\t\t//\t\t\tnodeContainer = node[tree.nodeContainerAttrName],\n\t\t\thasChildren = node.hasChildren(),\n\t\t\t    isLastSib = node.isLastSibling(),\n\t\t\t    aria = opts.aria,\n\n\t\t\t// $ariaElem = aria ? $(node[tree.ariaPropName]) : null,\n\t\t\t$ariaElem = $(node.span).find(\".fancytree-title\"),\n\t\t\t    cn = opts._classNames,\n\t\t\t    cnList = [],\n\t\t\t    statusElem = node[tree.statusClassPropName];\n\n\t\t\tif (!statusElem || tree._enableUpdate === false) {\n\t\t\t\t// if this function is called for an unrendered node, ignore it (will be updated on nect render anyway)\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Build a list of class names that we will add to the node <span>\n\t\t\tcnList.push(cn.node);\n\t\t\tif (tree.activeNode === node) {\n\t\t\t\tcnList.push(cn.active);\n\t\t\t\t//\t\t\t$(\">span.fancytree-title\", statusElem).attr(\"tabindex\", \"0\");\n\t\t\t\t//\t\t\ttree.$container.removeAttr(\"tabindex\");\n\t\t\t\t// }else{\n\t\t\t\t//\t\t\t$(\">span.fancytree-title\", statusElem).removeAttr(\"tabindex\");\n\t\t\t\t//\t\t\ttree.$container.attr(\"tabindex\", \"0\");\n\t\t\t}\n\t\t\tif (tree.focusNode === node) {\n\t\t\t\tcnList.push(cn.focused);\n\t\t\t\t// if(aria){\n\t\t\t\t// \t$ariaElem.attr(\"aria-activedescendant\", true);\n\t\t\t\t// }\n\t\t\t} else if (aria) {\n\t\t\t\t// $ariaElem.removeAttr(\"aria-activedescendant\");\n\t\t\t}\n\t\t\tif (node.expanded) {\n\t\t\t\tcnList.push(cn.expanded);\n\t\t\t\tif (aria) {\n\t\t\t\t\t$ariaElem.attr(\"aria-expanded\", true);\n\t\t\t\t}\n\t\t\t} else if (aria) {\n\t\t\t\tif (hasChildren) {\n\t\t\t\t\t$ariaElem.attr(\"aria-expanded\", false);\n\t\t\t\t} else {\n\t\t\t\t\t$ariaElem.removeAttr(\"aria-expanded\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.folder) {\n\t\t\t\tcnList.push(cn.folder);\n\t\t\t}\n\t\t\tif (hasChildren !== false) {\n\t\t\t\tcnList.push(cn.hasChildren);\n\t\t\t}\n\t\t\t// TODO: required?\n\t\t\tif (isLastSib) {\n\t\t\t\tcnList.push(cn.lastsib);\n\t\t\t}\n\t\t\tif (node.lazy && node.children == null) {\n\t\t\t\tcnList.push(cn.lazy);\n\t\t\t}\n\t\t\tif (node.partload) {\n\t\t\t\tcnList.push(cn.partload);\n\t\t\t}\n\t\t\tif (node.partsel) {\n\t\t\t\tcnList.push(cn.partsel);\n\t\t\t}\n\t\t\tif (node.unselectable) {\n\t\t\t\tcnList.push(cn.unselectable);\n\t\t\t}\n\t\t\tif (node._isLoading) {\n\t\t\t\tcnList.push(cn.loading);\n\t\t\t}\n\t\t\tif (node._error) {\n\t\t\t\tcnList.push(cn.error);\n\t\t\t}\n\t\t\tif (node.statusNodeType) {\n\t\t\t\tcnList.push(cn.statusNodePrefix + node.statusNodeType);\n\t\t\t}\n\t\t\tif (node.selected) {\n\t\t\t\tcnList.push(cn.selected);\n\t\t\t\tif (aria) {\n\t\t\t\t\t$ariaElem.attr(\"aria-selected\", true);\n\t\t\t\t}\n\t\t\t} else if (aria) {\n\t\t\t\t$ariaElem.attr(\"aria-selected\", false);\n\t\t\t}\n\t\t\tif (node.extraClasses) {\n\t\t\t\tcnList.push(node.extraClasses);\n\t\t\t}\n\t\t\t// IE6 doesn't correctly evaluate multiple class names,\n\t\t\t// so we create combined class names that can be used in the CSS\n\t\t\tif (hasChildren === false) {\n\t\t\t\tcnList.push(cn.combinedExpanderPrefix + \"n\" + (isLastSib ? \"l\" : \"\"));\n\t\t\t} else {\n\t\t\t\tcnList.push(cn.combinedExpanderPrefix + (node.expanded ? \"e\" : \"c\") + (node.lazy && node.children == null ? \"d\" : \"\") + (isLastSib ? \"l\" : \"\"));\n\t\t\t}\n\t\t\tcnList.push(cn.combinedIconPrefix + (node.expanded ? \"e\" : \"c\") + (node.folder ? \"f\" : \"\"));\n\t\t\t//        node.span.className = cnList.join(\" \");\n\t\t\tstatusElem.className = cnList.join(\" \");\n\n\t\t\t// TODO: we should not set this in the <span> tag also, if we set it here:\n\t\t\t// Maybe most (all) of the classes should be set in LI instead of SPAN?\n\t\t\tif (node.li) {\n\t\t\t\tnode.li.className = isLastSib ? cn.lastsib : \"\";\n\t\t\t}\n\t\t},\n\t\t/** Activate node.\n   * flag defaults to true.\n   * If flag is true, the node is activated (must be a synchronous operation)\n   * If flag is false, the node is deactivated (must be a synchronous operation)\n   * @param {EventData} ctx\n   * @param {boolean} [flag=true]\n   * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false}\n   * @returns {$.Promise}\n   */\n\t\tnodeSetActive: function nodeSetActive(ctx, flag, callOpts) {\n\t\t\t// Handle user click / [space] / [enter], according to clickFolderMode.\n\t\t\tcallOpts = callOpts || {};\n\t\t\tvar subCtx,\n\t\t\t    node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options,\n\t\t\t    noEvents = callOpts.noEvents === true,\n\t\t\t    noFocus = callOpts.noFocus === true,\n\t\t\t    isActive = node === tree.activeNode;\n\n\t\t\t// flag defaults to true\n\t\t\tflag = flag !== false;\n\t\t\t// node.debug(\"nodeSetActive\", flag);\n\n\t\t\tif (isActive === flag) {\n\t\t\t\t// Nothing to do\n\t\t\t\treturn _getResolvedPromise(node);\n\t\t\t} else if (flag && !noEvents && this._triggerNodeEvent(\"beforeActivate\", node, ctx.originalEvent) === false) {\n\t\t\t\t// Callback returned false\n\t\t\t\treturn _getRejectedPromise(node, [\"rejected\"]);\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tif (tree.activeNode) {\n\t\t\t\t\t_assert(tree.activeNode !== node, \"node was active (inconsistency)\");\n\t\t\t\t\tsubCtx = $.extend({}, ctx, { node: tree.activeNode });\n\t\t\t\t\ttree.nodeSetActive(subCtx, false);\n\t\t\t\t\t_assert(tree.activeNode === null, \"deactivate was out of sync?\");\n\t\t\t\t}\n\t\t\t\tif (opts.activeVisible) {\n\t\t\t\t\t// If no focus is set (noFocus: true) and there is no focused node, this node is made visible.\n\t\t\t\t\tnode.makeVisible({ scrollIntoView: noFocus && tree.focusNode == null });\n\t\t\t\t}\n\t\t\t\ttree.activeNode = node;\n\t\t\t\ttree.nodeRenderStatus(ctx);\n\t\t\t\tif (!noFocus) {\n\t\t\t\t\ttree.nodeSetFocus(ctx);\n\t\t\t\t}\n\t\t\t\tif (!noEvents) {\n\t\t\t\t\ttree._triggerNodeEvent(\"activate\", node, ctx.originalEvent);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_assert(tree.activeNode === node, \"node was not active (inconsistency)\");\n\t\t\t\ttree.activeNode = null;\n\t\t\t\tthis.nodeRenderStatus(ctx);\n\t\t\t\tif (!noEvents) {\n\t\t\t\t\tctx.tree._triggerNodeEvent(\"deactivate\", node, ctx.originalEvent);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn _getResolvedPromise(node);\n\t\t},\n\t\t/** Expand or collapse node, return Deferred.promise.\n   *\n   * @param {EventData} ctx\n   * @param {boolean} [flag=true]\n   * @param {object} [opts] additional options. Defaults to {noAnimation: false, noEvents: false}\n   * @returns {$.Promise} The deferred will be resolved as soon as the (lazy)\n   *     data was retrieved, rendered, and the expand animation finshed.\n   */\n\t\tnodeSetExpanded: function nodeSetExpanded(ctx, flag, callOpts) {\n\t\t\tcallOpts = callOpts || {};\n\t\t\tvar _afterLoad,\n\t\t\t    dfd,\n\t\t\t    i,\n\t\t\t    l,\n\t\t\t    parents,\n\t\t\t    prevAC,\n\t\t\t    node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options,\n\t\t\t    noAnimation = callOpts.noAnimation === true,\n\t\t\t    noEvents = callOpts.noEvents === true;\n\n\t\t\t// flag defaults to true\n\t\t\tflag = flag !== false;\n\n\t\t\t// node.debug(\"nodeSetExpanded(\" + flag + \")\");\n\n\t\t\tif (node.expanded && flag || !node.expanded && !flag) {\n\t\t\t\t// Nothing to do\n\t\t\t\t// node.debug(\"nodeSetExpanded(\" + flag + \"): nothing to do\");\n\t\t\t\treturn _getResolvedPromise(node);\n\t\t\t} else if (flag && !node.lazy && !node.hasChildren()) {\n\t\t\t\t// Prevent expanding of empty nodes\n\t\t\t\t// return _getRejectedPromise(node, [\"empty\"]);\n\t\t\t\treturn _getResolvedPromise(node);\n\t\t\t} else if (!flag && node.getLevel() < opts.minExpandLevel) {\n\t\t\t\t// Prevent collapsing locked levels\n\t\t\t\treturn _getRejectedPromise(node, [\"locked\"]);\n\t\t\t} else if (!noEvents && this._triggerNodeEvent(\"beforeExpand\", node, ctx.originalEvent) === false) {\n\t\t\t\t// Callback returned false\n\t\t\t\treturn _getRejectedPromise(node, [\"rejected\"]);\n\t\t\t}\n\t\t\t// If this node inside a collpased node, no animation and scrolling is needed\n\t\t\tif (!noAnimation && !node.isVisible()) {\n\t\t\t\tnoAnimation = callOpts.noAnimation = true;\n\t\t\t}\n\n\t\t\tdfd = new $.Deferred();\n\n\t\t\t// Auto-collapse mode: collapse all siblings\n\t\t\tif (flag && !node.expanded && opts.autoCollapse) {\n\t\t\t\tparents = node.getParentList(false, true);\n\t\t\t\tprevAC = opts.autoCollapse;\n\t\t\t\ttry {\n\t\t\t\t\topts.autoCollapse = false;\n\t\t\t\t\tfor (i = 0, l = parents.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: should return promise?\n\t\t\t\t\t\tthis._callHook(\"nodeCollapseSiblings\", parents[i], callOpts);\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\topts.autoCollapse = prevAC;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Trigger expand/collapse after expanding\n\t\t\tdfd.done(function () {\n\t\t\t\tvar lastChild = node.getLastChild();\n\t\t\t\tif (flag && opts.autoScroll && !noAnimation && lastChild) {\n\t\t\t\t\t// Scroll down to last child, but keep current node visible\n\t\t\t\t\tlastChild.scrollIntoView(true, { topNode: node }).always(function () {\n\t\t\t\t\t\tif (!noEvents) {\n\t\t\t\t\t\t\tctx.tree._triggerNodeEvent(flag ? \"expand\" : \"collapse\", ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (!noEvents) {\n\t\t\t\t\t\tctx.tree._triggerNodeEvent(flag ? \"expand\" : \"collapse\", ctx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// vvv Code below is executed after loading finished:\n\t\t\t_afterLoad = function _afterLoad(callback) {\n\t\t\t\tvar isVisible,\n\t\t\t\t    isExpanded,\n\t\t\t\t    effect = opts.toggleEffect;\n\n\t\t\t\tnode.expanded = flag;\n\t\t\t\t// Create required markup, but make sure the top UL is hidden, so we\n\t\t\t\t// can animate later\n\t\t\t\ttree._callHook(\"nodeRender\", ctx, false, false, true);\n\n\t\t\t\t// If the currently active node is now hidden, deactivate it\n\t\t\t\t// if( opts.activeVisible && this.activeNode && ! this.activeNode.isVisible() ) {\n\t\t\t\t//     this.activeNode.deactivate();\n\t\t\t\t// }\n\n\t\t\t\t// Expanding a lazy node: set 'loading...' and call callback\n\t\t\t\t// if( bExpand && this.data.isLazy && this.childList === null && !this._isLoading ) {\n\t\t\t\t//     this._loadContent();\n\t\t\t\t//     return;\n\t\t\t\t// }\n\t\t\t\t// Hide children, if node is collapsed\n\t\t\t\tif (node.ul) {\n\t\t\t\t\tisVisible = node.ul.style.display !== \"none\";\n\t\t\t\t\tisExpanded = !!node.expanded;\n\t\t\t\t\tif (isVisible === isExpanded) {\n\t\t\t\t\t\tnode.warn(\"nodeSetExpanded: UL.style.display already set\");\n\t\t\t\t\t} else if (!effect || noAnimation) {\n\t\t\t\t\t\tnode.ul.style.display = node.expanded || !parent ? \"\" : \"none\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// The UI toggle() effect works with the ext-wide extension,\n\t\t\t\t\t\t// while jQuery.animate() has problems when the title span\n\t\t\t\t\t\t// has positon: absolute\n\n\t\t\t\t\t\t// duration = opts.fx.duration || 200;\n\t\t\t\t\t\t// easing = opts.fx.easing;\n\t\t\t\t\t\t// $(node.ul).animate(opts.fx, duration, easing, function(){\n\n\t\t\t\t\t\t// node.debug(\"nodeSetExpanded: animate start...\");\n\t\t\t\t\t\t$(node.ul).toggle(effect.effect, effect.options, effect.duration, function () {\n\t\t\t\t\t\t\t// node.debug(\"nodeSetExpanded: animate done\");\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback();\n\t\t\t};\n\t\t\t// ^^^ Code above is executed after loading finshed.\n\n\t\t\t// Load lazy nodes, if any. Then continue with _afterLoad()\n\t\t\tif (flag && node.lazy && node.hasChildren() === undefined) {\n\t\t\t\t// node.debug(\"nodeSetExpanded: load start...\");\n\t\t\t\tnode.load().done(function () {\n\t\t\t\t\t// node.debug(\"nodeSetExpanded: load done\");\n\t\t\t\t\tif (dfd.notifyWith) {\n\t\t\t\t\t\t// requires jQuery 1.6+\n\t\t\t\t\t\tdfd.notifyWith(node, [\"loaded\"]);\n\t\t\t\t\t}\n\t\t\t\t\t_afterLoad(function () {\n\t\t\t\t\t\tdfd.resolveWith(node);\n\t\t\t\t\t});\n\t\t\t\t}).fail(function (errMsg) {\n\t\t\t\t\t_afterLoad(function () {\n\t\t\t\t\t\tdfd.rejectWith(node, [\"load failed (\" + errMsg + \")\"]);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t/*\n    \t\t\tvar source = tree._triggerNodeEvent(\"lazyLoad\", node, ctx.originalEvent);\n    \t\t\t_assert(typeof source !== \"boolean\", \"lazyLoad event must return source in data.result\");\n    \t\t\tnode.debug(\"nodeSetExpanded: load start...\");\n    \t\t\tthis._callHook(\"nodeLoadChildren\", ctx, source).done(function(){\n    \t\t\t\tnode.debug(\"nodeSetExpanded: load done\");\n    \t\t\t\tif(dfd.notifyWith){ // requires jQuery 1.6+\n    \t\t\t\t\tdfd.notifyWith(node, [\"loaded\"]);\n    \t\t\t\t}\n    \t\t\t\t_afterLoad.call(tree);\n    \t\t\t}).fail(function(errMsg){\n    \t\t\t\tdfd.rejectWith(node, [\"load failed (\" + errMsg + \")\"]);\n    \t\t\t});\n    */\n\t\t\t} else {\n\t\t\t\t_afterLoad(function () {\n\t\t\t\t\tdfd.resolveWith(node);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// node.debug(\"nodeSetExpanded: returns\");\n\t\t\treturn dfd.promise();\n\t\t},\n\t\t/** Focus or blur this node.\n   * @param {EventData} ctx\n   * @param {boolean} [flag=true]\n   */\n\t\tnodeSetFocus: function nodeSetFocus(ctx, flag) {\n\t\t\t// ctx.node.debug(\"nodeSetFocus(\" + flag + \")\");\n\t\t\tvar ctx2,\n\t\t\t    tree = ctx.tree,\n\t\t\t    node = ctx.node,\n\t\t\t    opts = tree.options,\n\n\t\t\t// et = ctx.originalEvent && ctx.originalEvent.type,\n\t\t\tisInput = ctx.originalEvent ? $(ctx.originalEvent.target).is(\":input\") : false;\n\n\t\t\tflag = flag !== false;\n\n\t\t\t// (node || tree).debug(\"nodeSetFocus(\" + flag + \"), event: \" + et + \", isInput: \"+ isInput);\n\t\t\t// Blur previous node if any\n\t\t\tif (tree.focusNode) {\n\t\t\t\tif (tree.focusNode === node && flag) {\n\t\t\t\t\t// node.debug(\"nodeSetFocus(\" + flag + \"): nothing to do\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tctx2 = $.extend({}, ctx, { node: tree.focusNode });\n\t\t\t\ttree.focusNode = null;\n\t\t\t\tthis._triggerNodeEvent(\"blur\", ctx2);\n\t\t\t\tthis._callHook(\"nodeRenderStatus\", ctx2);\n\t\t\t}\n\t\t\t// Set focus to container and node\n\t\t\tif (flag) {\n\t\t\t\tif (!this.hasFocus()) {\n\t\t\t\t\tnode.debug(\"nodeSetFocus: forcing container focus\");\n\t\t\t\t\tthis._callHook(\"treeSetFocus\", ctx, true, { calledByNode: true });\n\t\t\t\t}\n\t\t\t\tnode.makeVisible({ scrollIntoView: false });\n\t\t\t\ttree.focusNode = node;\n\t\t\t\tif (opts.titlesTabbable) {\n\t\t\t\t\tif (!isInput) {\n\t\t\t\t\t\t// #621\n\t\t\t\t\t\t$(node.span).find(\".fancytree-title\").focus();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// We cannot set KB focus to a node, so use the tree container\n\t\t\t\t\t// #563, #570: IE scrolls on every call to .focus(), if the container\n\t\t\t\t\t// is partially outside the viewport. So do it only, when absolutely\n\t\t\t\t\t// neccessary:\n\t\t\t\t\tif ($(document.activeElement).closest(\".fancytree-container\").length === 0) {\n\t\t\t\t\t\t$(tree.$container).focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (opts.aria) {\n\t\t\t\t\t$(tree.$container).attr(\"aria-activedescendant\", \"ftal_\" + opts.idPrefix + node.key);\n\t\t\t\t}\n\t\t\t\t//\t\t\t$(node.span).find(\".fancytree-title\").focus();\n\t\t\t\tthis._triggerNodeEvent(\"focus\", ctx);\n\t\t\t\t//          if( opts.autoActivate ){\n\t\t\t\t//              tree.nodeSetActive(ctx, true);\n\t\t\t\t//          }\n\t\t\t\tif (opts.autoScroll) {\n\t\t\t\t\tnode.scrollIntoView();\n\t\t\t\t}\n\t\t\t\tthis._callHook(\"nodeRenderStatus\", ctx);\n\t\t\t}\n\t\t},\n\t\t/** (De)Select node, return new status (sync).\n   *\n   * @param {EventData} ctx\n   * @param {boolean} [flag=true]\n   */\n\t\tnodeSetSelected: function nodeSetSelected(ctx, flag) {\n\t\t\tvar node = ctx.node,\n\t\t\t    tree = ctx.tree,\n\t\t\t    opts = ctx.options;\n\t\t\t// flag defaults to true\n\t\t\tflag = flag !== false;\n\n\t\t\t// node.debug(\"nodeSetSelected(\" + flag + \")\", ctx);\n\t\t\tif (node.unselectable) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// TODO: !!node.expanded is nicer, but doesn't pass jshint\n\t\t\t// https://github.com/jshint/jshint/issues/455\n\t\t\t//        if( !!node.expanded === !!flag){\n\t\t\tif (node.selected && flag || !node.selected && !flag) {\n\t\t\t\treturn !!node.selected;\n\t\t\t} else if (this._triggerNodeEvent(\"beforeSelect\", node, ctx.originalEvent) === false) {\n\t\t\t\treturn !!node.selected;\n\t\t\t}\n\t\t\tif (flag && opts.selectMode === 1) {\n\t\t\t\t// single selection mode\n\t\t\t\tif (tree.lastSelectedNode) {\n\t\t\t\t\ttree.lastSelectedNode.setSelected(false);\n\t\t\t\t}\n\t\t\t} else if (opts.selectMode === 3) {\n\t\t\t\t// multi.hier selection mode\n\t\t\t\tnode.selected = flag;\n\t\t\t\t//\t\t\tthis._fixSelectionState(node);\n\t\t\t\tnode.fixSelection3AfterClick();\n\t\t\t}\n\t\t\tnode.selected = flag;\n\t\t\tthis.nodeRenderStatus(ctx);\n\t\t\ttree.lastSelectedNode = flag ? node : null;\n\t\t\ttree._triggerNodeEvent(\"select\", ctx);\n\t\t},\n\t\t/** Show node status (ok, loading, error, nodata) using styles and a dummy child node.\n   *\n   * @param {EventData} ctx\n   * @param status\n   * @param message\n   * @param details\n   * @since 2.3\n   */\n\t\tnodeSetStatus: function nodeSetStatus(ctx, status, message, details) {\n\t\t\tvar node = ctx.node,\n\t\t\t    tree = ctx.tree;\n\n\t\t\tfunction _clearStatusNode() {\n\t\t\t\t// Remove dedicated dummy node, if any\n\t\t\t\tvar firstChild = node.children ? node.children[0] : null;\n\t\t\t\tif (firstChild && firstChild.isStatusNode()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// I've seen exceptions here with loadKeyPath...\n\t\t\t\t\t\tif (node.ul) {\n\t\t\t\t\t\t\tnode.ul.removeChild(firstChild.li);\n\t\t\t\t\t\t\tfirstChild.li = null; // avoid leaks (DT issue 215)\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t\tif (node.children.length === 1) {\n\t\t\t\t\t\tnode.children = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode.children.shift();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _setStatusNode(data, type) {\n\t\t\t\t// Create/modify the dedicated dummy node for 'loading...' or\n\t\t\t\t// 'error!' status. (only called for direct child of the invisible\n\t\t\t\t// system root)\n\t\t\t\tvar firstChild = node.children ? node.children[0] : null;\n\t\t\t\tif (firstChild && firstChild.isStatusNode()) {\n\t\t\t\t\t$.extend(firstChild, data);\n\t\t\t\t\tfirstChild.statusNodeType = type;\n\t\t\t\t\ttree._callHook(\"nodeRenderTitle\", firstChild);\n\t\t\t\t} else {\n\t\t\t\t\tnode._setChildren([data]);\n\t\t\t\t\tnode.children[0].statusNodeType = type;\n\t\t\t\t\ttree.render();\n\t\t\t\t}\n\t\t\t\treturn node.children[0];\n\t\t\t}\n\n\t\t\tswitch (status) {\n\t\t\t\tcase \"ok\":\n\t\t\t\t\t_clearStatusNode();\n\t\t\t\t\tnode._isLoading = false;\n\t\t\t\t\tnode._error = null;\n\t\t\t\t\tnode.renderStatus();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"loading\":\n\t\t\t\t\tif (!node.parent) {\n\t\t\t\t\t\t_setStatusNode({\n\t\t\t\t\t\t\ttitle: tree.options.strings.loading + (message ? \" (\" + message + \")\" : \"\"),\n\t\t\t\t\t\t\t// icon: true,  // needed for 'loding' icon\n\t\t\t\t\t\t\tcheckbox: false,\n\t\t\t\t\t\t\ttooltip: details\n\t\t\t\t\t\t}, status);\n\t\t\t\t\t}\n\t\t\t\t\tnode._isLoading = true;\n\t\t\t\t\tnode._error = null;\n\t\t\t\t\tnode.renderStatus();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\t_setStatusNode({\n\t\t\t\t\t\ttitle: tree.options.strings.loadError + (message ? \" (\" + message + \")\" : \"\"),\n\t\t\t\t\t\t// icon: false,\n\t\t\t\t\t\tcheckbox: false,\n\t\t\t\t\t\ttooltip: details\n\t\t\t\t\t}, status);\n\t\t\t\t\tnode._isLoading = false;\n\t\t\t\t\tnode._error = { message: message, details: details };\n\t\t\t\t\tnode.renderStatus();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"nodata\":\n\t\t\t\t\t_setStatusNode({\n\t\t\t\t\t\ttitle: tree.options.strings.noData,\n\t\t\t\t\t\t// icon: false,\n\t\t\t\t\t\tcheckbox: false,\n\t\t\t\t\t\ttooltip: details\n\t\t\t\t\t}, status);\n\t\t\t\t\tnode._isLoading = false;\n\t\t\t\t\tnode._error = null;\n\t\t\t\t\tnode.renderStatus();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t$.error(\"invalid node status \" + status);\n\t\t\t}\n\t\t},\n\t\t/**\n   *\n   * @param {EventData} ctx\n   */\n\t\tnodeToggleExpanded: function nodeToggleExpanded(ctx) {\n\t\t\treturn this.nodeSetExpanded(ctx, !ctx.node.expanded);\n\t\t},\n\t\t/**\n   * @param {EventData} ctx\n   */\n\t\tnodeToggleSelected: function nodeToggleSelected(ctx) {\n\t\t\treturn this.nodeSetSelected(ctx, !ctx.node.selected);\n\t\t},\n\t\t/** Remove all nodes.\n   * @param {EventData} ctx\n   */\n\t\ttreeClear: function treeClear(ctx) {\n\t\t\tvar tree = ctx.tree;\n\t\t\ttree.activeNode = null;\n\t\t\ttree.focusNode = null;\n\t\t\ttree.$div.find(\">ul.fancytree-container\").empty();\n\t\t\t// TODO: call destructors and remove reference loops\n\t\t\ttree.rootNode.children = null;\n\t\t},\n\t\t/** Widget was created (called only once, even it re-initialized).\n   * @param {EventData} ctx\n   */\n\t\ttreeCreate: function treeCreate(ctx) {},\n\t\t/** Widget was destroyed.\n   * @param {EventData} ctx\n   */\n\t\ttreeDestroy: function treeDestroy(ctx) {\n\t\t\tthis.$div.find(\">ul.fancytree-container\").remove();\n\t\t\tthis.$source && this.$source.removeClass(\"ui-helper-hidden\");\n\t\t},\n\t\t/** Widget was (re-)initialized.\n   * @param {EventData} ctx\n   */\n\t\ttreeInit: function treeInit(ctx) {\n\t\t\t//this.debug(\"Fancytree.treeInit()\");\n\t\t\tthis.treeLoad(ctx);\n\t\t},\n\t\t/** Parse Fancytree from source, as configured in the options.\n   * @param {EventData} ctx\n   * @param {object} [source] optional new source (use last data otherwise)\n   */\n\t\ttreeLoad: function treeLoad(ctx, source) {\n\t\t\tvar metaData,\n\t\t\t    type,\n\t\t\t    $ul,\n\t\t\t    tree = ctx.tree,\n\t\t\t    $container = ctx.widget.element,\n\t\t\t    dfd,\n\n\t\t\t// calling context for root node\n\t\t\trootCtx = $.extend({}, ctx, { node: this.rootNode });\n\n\t\t\tif (tree.rootNode.children) {\n\t\t\t\tthis.treeClear(ctx);\n\t\t\t}\n\t\t\tsource = source || this.options.source;\n\n\t\t\tif (!source) {\n\t\t\t\ttype = $container.data(\"type\") || \"html\";\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase \"html\":\n\t\t\t\t\t\t$ul = $container.find(\">ul:first\");\n\t\t\t\t\t\t$ul.addClass(\"ui-fancytree-source ui-helper-hidden\");\n\t\t\t\t\t\tsource = $.ui.fancytree.parseHtml($ul);\n\t\t\t\t\t\t// allow to init tree.data.foo from <ul data-foo=''>\n\t\t\t\t\t\tthis.data = $.extend(this.data, _getElementDataAsDict($ul));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"json\":\n\t\t\t\t\t\tsource = $.parseJSON($container.text());\n\t\t\t\t\t\t// $container already contains the <ul>, but we remove the plain (json) text\n\t\t\t\t\t\t// $container.empty();\n\t\t\t\t\t\t$container.contents().filter(function () {\n\t\t\t\t\t\t\treturn this.nodeType === 3;\n\t\t\t\t\t\t}).remove();\n\t\t\t\t\t\tif ($.isPlainObject(source)) {\n\t\t\t\t\t\t\t// We got {foo: 'abc', children: [...]}\n\t\t\t\t\t\t\t// Copy extra properties to tree.data.foo\n\t\t\t\t\t\t\t_assert($.isArray(source.children), \"if an object is passed as source, it must contain a 'children' array (all other properties are added to 'tree.data')\");\n\t\t\t\t\t\t\tmetaData = source;\n\t\t\t\t\t\t\tsource = source.children;\n\t\t\t\t\t\t\tdelete metaData.children;\n\t\t\t\t\t\t\t$.extend(tree.data, metaData);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$.error(\"Invalid data-type: \" + type);\n\t\t\t\t}\n\t\t\t} else if (typeof source === \"string\") {\n\t\t\t\t// TODO: source is an element ID\n\t\t\t\t$.error(\"Not implemented\");\n\t\t\t}\n\n\t\t\t// Trigger fancytreeinit after nodes have been loaded\n\t\t\tdfd = this.nodeLoadChildren(rootCtx, source).done(function () {\n\t\t\t\ttree.render();\n\t\t\t\tif (ctx.options.selectMode === 3) {\n\t\t\t\t\ttree.rootNode.fixSelection3FromEndNodes();\n\t\t\t\t}\n\t\t\t\tif (tree.activeNode && tree.options.activeVisible) {\n\t\t\t\t\ttree.activeNode.makeVisible();\n\t\t\t\t}\n\t\t\t\ttree._triggerTreeEvent(\"init\", null, { status: true });\n\t\t\t}).fail(function () {\n\t\t\t\ttree.render();\n\t\t\t\ttree._triggerTreeEvent(\"init\", null, { status: false });\n\t\t\t});\n\t\t\treturn dfd;\n\t\t},\n\t\t/** Node was inserted into or removed from the tree.\n   * @param {EventData} ctx\n   * @param {boolean} add\n   * @param {FancytreeNode} node\n   */\n\t\ttreeRegisterNode: function treeRegisterNode(ctx, add, node) {},\n\t\t/** Widget got focus.\n   * @param {EventData} ctx\n   * @param {boolean} [flag=true]\n   */\n\t\ttreeSetFocus: function treeSetFocus(ctx, flag, callOpts) {\n\t\t\tflag = flag !== false;\n\n\t\t\t// this.debug(\"treeSetFocus(\" + flag + \"), callOpts: \", callOpts, this.hasFocus());\n\t\t\t// this.debug(\"    focusNode: \" + this.focusNode);\n\t\t\t// this.debug(\"    activeNode: \" + this.activeNode);\n\t\t\tif (flag !== this.hasFocus()) {\n\t\t\t\tthis._hasFocus = flag;\n\t\t\t\tif (!flag && this.focusNode) {\n\t\t\t\t\t// Node also looses focus if widget blurs\n\t\t\t\t\tthis.focusNode.setFocus(false);\n\t\t\t\t} else if (flag && (!callOpts || !callOpts.calledByNode)) {\n\t\t\t\t\t$(this.$container).focus();\n\t\t\t\t}\n\t\t\t\tthis.$container.toggleClass(\"fancytree-treefocus\", flag);\n\t\t\t\tthis._triggerTreeEvent(flag ? \"focusTree\" : \"blurTree\");\n\t\t\t\tif (flag && !this.activeNode) {\n\t\t\t\t\tthis.getFirstChild() && this.getFirstChild().setFocus();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/** Widget option was set using `$().fancytree(\"option\", \"foo\", \"bar\")`.\n   * @param {EventData} ctx\n   * @param {string} key option name\n   * @param {any} value option value\n   */\n\t\ttreeSetOption: function treeSetOption(ctx, key, value) {\n\t\t\tvar tree = ctx.tree,\n\t\t\t    callDefault = true,\n\t\t\t    rerender = false;\n\n\t\t\tswitch (key) {\n\t\t\t\tcase \"aria\":\n\t\t\t\tcase \"checkbox\":\n\t\t\t\tcase \"icon\":\n\t\t\t\tcase \"minExpandLevel\":\n\t\t\t\tcase \"tabindex\":\n\t\t\t\t\ttree._callHook(\"treeCreate\", tree);\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"escapeTitles\":\n\t\t\t\tcase \"tooltip\":\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"rtl\":\n\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\ttree.$container.attr(\"DIR\", null).removeClass(\"fancytree-rtl\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttree.$container.attr(\"DIR\", \"RTL\").addClass(\"fancytree-rtl\");\n\t\t\t\t\t}\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"source\":\n\t\t\t\t\tcallDefault = false;\n\t\t\t\t\ttree._callHook(\"treeLoad\", tree, value);\n\t\t\t\t\trerender = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttree.debug(\"set option \" + key + \"=\" + value + \" <\" + (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) + \">\");\n\t\t\tif (callDefault) {\n\t\t\t\tif (this.widget._super) {\n\t\t\t\t\t// jQuery UI 1.9+\n\t\t\t\t\tthis.widget._super.call(this.widget, key, value);\n\t\t\t\t} else {\n\t\t\t\t\t// jQuery UI <= 1.8, we have to manually invoke the _setOption method from the base widget\n\t\t\t\t\t$.Widget.prototype._setOption.call(this.widget, key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rerender) {\n\t\t\t\ttree.render(true, false); // force, not-deep\n\t\t\t}\n\t\t}\n\t});\n\n\t/* ******************************************************************************\n  * jQuery UI widget boilerplate\n  */\n\n\t/**\n  * The plugin (derrived from <a href=\" http://api.jqueryui.com/jQuery.widget/\">jQuery.Widget</a>).<br>\n  * This constructor is not called directly. Use `$(selector).fancytree({})`\n  * to initialize the plugin instead.<br>\n  * <pre class=\"sh_javascript sunlight-highlight-javascript\">// Access widget methods and members:\n  * var tree = $(\"#tree\").fancytree(\"getTree\");\n  * var node = $(\"#tree\").fancytree(\"getActiveNode\", \"1234\");\n  * </pre>\n  *\n  * @mixin Fancytree_Widget\n  */\n\n\t$.widget(\"ui.fancytree\",\n\t/** @lends Fancytree_Widget# */\n\t{\n\t\t/**These options will be used as defaults\n   * @type {FancytreeOptions}\n   */\n\t\toptions: {\n\t\t\tactiveVisible: true,\n\t\t\tajax: {\n\t\t\t\ttype: \"GET\",\n\t\t\t\tcache: false, // false: Append random '_' argument to the request url to prevent caching.\n\t\t\t\t//          timeout: 0, // >0: Make sure we get an ajax error if server is unreachable\n\t\t\t\tdataType: \"json\" // Expect json format and pass json object to callbacks.\n\t\t\t}, //\n\t\t\taria: false,\n\t\t\tautoActivate: true,\n\t\t\tautoCollapse: false,\n\t\t\tautoScroll: false,\n\t\t\tcheckbox: false,\n\t\t\tclickFolderMode: 4,\n\t\t\tdebugLevel: null, // 0..2 (null: use global setting $.ui.fancytree.debugInfo)\n\t\t\tdisabled: false, // TODO: required anymore?\n\t\t\tenableAspx: true, // TODO: document\n\t\t\tescapeTitles: false,\n\t\t\textensions: [],\n\t\t\t// fx: { height: \"toggle\", duration: 200 },\n\t\t\t// toggleEffect: { effect: \"drop\", options: {direction: \"left\"}, duration: 200 },\n\t\t\t// toggleEffect: { effect: \"slide\", options: {direction: \"up\"}, duration: 200 },\n\t\t\ttoggleEffect: { effect: \"blind\", options: { direction: \"vertical\", scale: \"box\" }, duration: 200 },\n\t\t\tgenerateIds: false,\n\t\t\ticon: true,\n\t\t\tidPrefix: \"ft_\",\n\t\t\tfocusOnSelect: false,\n\t\t\tkeyboard: true,\n\t\t\tkeyPathSeparator: \"/\",\n\t\t\tminExpandLevel: 1,\n\t\t\tquicksearch: false,\n\t\t\trtl: false,\n\t\t\tscrollOfs: { top: 0, bottom: 0 },\n\t\t\tscrollParent: null,\n\t\t\tselectMode: 2,\n\t\t\tstrings: {\n\t\t\t\tloading: \"Loading&#8230;\",\n\t\t\t\tloadError: \"Load error!\",\n\t\t\t\tmoreData: \"More&#8230;\",\n\t\t\t\tnoData: \"No data.\"\n\t\t\t},\n\t\t\ttabindex: \"0\",\n\t\t\ttitlesTabbable: false,\n\t\t\ttooltip: false,\n\t\t\t_classNames: {\n\t\t\t\tnode: \"fancytree-node\",\n\t\t\t\tfolder: \"fancytree-folder\",\n\t\t\t\tcombinedExpanderPrefix: \"fancytree-exp-\",\n\t\t\t\tcombinedIconPrefix: \"fancytree-ico-\",\n\t\t\t\thasChildren: \"fancytree-has-children\",\n\t\t\t\tactive: \"fancytree-active\",\n\t\t\t\tselected: \"fancytree-selected\",\n\t\t\t\texpanded: \"fancytree-expanded\",\n\t\t\t\tlazy: \"fancytree-lazy\",\n\t\t\t\tfocused: \"fancytree-focused\",\n\t\t\t\tpartload: \"fancytree-partload\",\n\t\t\t\tpartsel: \"fancytree-partsel\",\n\t\t\t\tunselectable: \"fancytree-unselectable\",\n\t\t\t\tlastsib: \"fancytree-lastsib\",\n\t\t\t\tloading: \"fancytree-loading\",\n\t\t\t\terror: \"fancytree-error\",\n\t\t\t\tstatusNodePrefix: \"fancytree-statusnode-\"\n\t\t\t},\n\t\t\t// events\n\t\t\tlazyLoad: null,\n\t\t\tpostProcess: null\n\t\t},\n\t\t/* Set up the widget, Called on first $().fancytree() */\n\t\t_create: function _create() {\n\t\t\tthis.tree = new Fancytree(this);\n\n\t\t\tthis.$source = this.source || this.element.data(\"type\") === \"json\" ? this.element : this.element.find(\">ul:first\");\n\t\t\t// Subclass Fancytree instance with all enabled extensions\n\t\t\tvar extension,\n\t\t\t    extName,\n\t\t\t    i,\n\t\t\t    opts = this.options,\n\t\t\t    extensions = opts.extensions,\n\t\t\t    base = this.tree;\n\n\t\t\tfor (i = 0; i < extensions.length; i++) {\n\t\t\t\textName = extensions[i];\n\t\t\t\textension = $.ui.fancytree._extensions[extName];\n\t\t\t\tif (!extension) {\n\t\t\t\t\t$.error(\"Could not apply extension '\" + extName + \"' (it is not registered, did you forget to include it?)\");\n\t\t\t\t}\n\t\t\t\t// Add extension options as tree.options.EXTENSION\n\t\t\t\t//\t\t\t_assert(!this.tree.options[extName], \"Extension name must not exist as option name: \" + extName);\n\t\t\t\tthis.tree.options[extName] = $.extend(true, {}, extension.options, this.tree.options[extName]);\n\t\t\t\t// Add a namespace tree.ext.EXTENSION, to hold instance data\n\t\t\t\t_assert(this.tree.ext[extName] === undefined, \"Extension name must not exist as Fancytree.ext attribute: '\" + extName + \"'\");\n\t\t\t\t//\t\t\tthis.tree[extName] = extension;\n\t\t\t\tthis.tree.ext[extName] = {};\n\t\t\t\t// Subclass Fancytree methods using proxies.\n\t\t\t\t_subclassObject(this.tree, base, extension, extName);\n\t\t\t\t// current extension becomes base for the next extension\n\t\t\t\tbase = extension;\n\t\t\t}\n\t\t\t//\n\t\t\tif (opts.icons !== undefined) {\n\t\t\t\t// 2015-11-16\n\t\t\t\tif (opts.icon !== true) {\n\t\t\t\t\t$.error(\"'icons' tree option is deprecated since v2.14.0: use 'icon' only instead\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.tree.warn(\"'icons' tree option is deprecated since v2.14.0: use 'icon' instead\");\n\t\t\t\t\topts.icon = opts.icons;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.iconClass !== undefined) {\n\t\t\t\t// 2015-11-16\n\t\t\t\tif (opts.icon) {\n\t\t\t\t\t$.error(\"'iconClass' tree option is deprecated since v2.14.0: use 'icon' only instead\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.tree.warn(\"'iconClass' tree option is deprecated since v2.14.0: use 'icon' instead\");\n\t\t\t\t\topts.icon = opts.iconClass;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.tabbable !== undefined) {\n\t\t\t\t// 2016-04-04\n\t\t\t\topts.tabindex = opts.tabbable ? \"0\" : \"-1\";\n\t\t\t\tthis.tree.warn(\"'tabbable' tree option is deprecated since v2.17.0: use 'tabindex='\" + opts.tabindex + \"' instead\");\n\t\t\t}\n\t\t\t//\n\t\t\tthis.tree._callHook(\"treeCreate\", this.tree);\n\t\t\t// Note: 'fancytreecreate' event is fired by widget base class\n\t\t\t//        this.tree._triggerTreeEvent(\"create\");\n\t\t},\n\n\t\t/* Called on every $().fancytree() */\n\t\t_init: function _init() {\n\t\t\tthis.tree._callHook(\"treeInit\", this.tree);\n\t\t\t// TODO: currently we call bind after treeInit, because treeInit\n\t\t\t// might change tree.$container.\n\t\t\t// It would be better, to move ebent binding into hooks altogether\n\t\t\tthis._bind();\n\t\t},\n\n\t\t/* Use the _setOption method to respond to changes to options */\n\t\t_setOption: function _setOption(key, value) {\n\t\t\treturn this.tree._callHook(\"treeSetOption\", this.tree, key, value);\n\t\t},\n\n\t\t/** Use the destroy method to clean up any modifications your widget has made to the DOM */\n\t\tdestroy: function destroy() {\n\t\t\tthis._unbind();\n\t\t\tthis.tree._callHook(\"treeDestroy\", this.tree);\n\t\t\t// In jQuery UI 1.8, you must invoke the destroy method from the base widget\n\t\t\t$.Widget.prototype.destroy.call(this);\n\t\t\t// TODO: delete tree and nodes to make garbage collect easier?\n\t\t\t// TODO: In jQuery UI 1.9 and above, you would define _destroy instead of destroy and not call the base method\n\t\t},\n\n\t\t// -------------------------------------------------------------------------\n\n\t\t/* Remove all event handlers for our namespace */\n\t\t_unbind: function _unbind() {\n\t\t\tvar ns = this.tree._ns;\n\t\t\tthis.element.unbind(ns);\n\t\t\tthis.tree.$container.unbind(ns);\n\t\t\t$(document).unbind(ns);\n\t\t},\n\t\t/* Add mouse and kyboard handlers to the container */\n\t\t_bind: function _bind() {\n\t\t\tvar that = this,\n\t\t\t    opts = this.options,\n\t\t\t    tree = this.tree,\n\t\t\t    ns = tree._ns\n\t\t\t// selstartEvent = ( $.support.selectstart ? \"selectstart\" : \"mousedown\" )\n\t\t\t;\n\n\t\t\t// Remove all previuous handlers for this tree\n\t\t\tthis._unbind();\n\n\t\t\t//alert(\"keydown\" + ns + \"foc=\" + tree.hasFocus() + tree.$container);\n\t\t\t// tree.debug(\"bind events; container: \", tree.$container);\n\t\t\ttree.$container.on(\"focusin\" + ns + \" focusout\" + ns, function (event) {\n\t\t\t\tvar node = FT.getNode(event),\n\t\t\t\t    flag = event.type === \"focusin\";\n\t\t\t\t// tree.debug(\"Tree container got event \" + event.type, node, event);\n\t\t\t\t// tree.treeOnFocusInOut.call(tree, event);\n\t\t\t\tif (node) {\n\t\t\t\t\t// For example clicking into an <input> that is part of a node\n\t\t\t\t\ttree._callHook(\"nodeSetFocus\", tree._makeHookContext(node, event), flag);\n\t\t\t\t\t// tree._callHook(\"nodeSetFocus\", node, flag);\n\t\t\t\t} else {\n\t\t\t\t\ttree._callHook(\"treeSetFocus\", tree, flag);\n\t\t\t\t}\n\t\t\t}).on(\"selectstart\" + ns, \"span.fancytree-title\", function (event) {\n\t\t\t\t// prevent mouse-drags to select text ranges\n\t\t\t\t// tree.debug(\"<span title> got event \" + event.type);\n\t\t\t\tevent.preventDefault();\n\t\t\t}).on(\"keydown\" + ns, function (event) {\n\t\t\t\t// TODO: also bind keyup and keypress\n\t\t\t\t// tree.debug(\"got event \" + event.type + \", hasFocus:\" + tree.hasFocus());\n\t\t\t\t// if(opts.disabled || opts.keyboard === false || !tree.hasFocus() ){\n\t\t\t\tif (opts.disabled || opts.keyboard === false) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar res,\n\t\t\t\t    node = tree.focusNode,\n\t\t\t\t    // node may be null\n\t\t\t\tctx = tree._makeHookContext(node || tree, event),\n\t\t\t\t    prevPhase = tree.phase;\n\n\t\t\t\ttry {\n\t\t\t\t\ttree.phase = \"userEvent\";\n\t\t\t\t\t// If a 'fancytreekeydown' handler returns false, skip the default\n\t\t\t\t\t// handling (implemented by tree.nodeKeydown()).\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tres = tree._triggerNodeEvent(\"keydown\", node, event);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres = tree._triggerTreeEvent(\"keydown\", event);\n\t\t\t\t\t}\n\t\t\t\t\tif (res === \"preventNav\") {\n\t\t\t\t\t\tres = true; // prevent keyboard navigation, but don't prevent default handling of embedded input controls\n\t\t\t\t\t} else if (res !== false) {\n\t\t\t\t\t\tres = tree._callHook(\"nodeKeydown\", ctx);\n\t\t\t\t\t}\n\t\t\t\t\treturn res;\n\t\t\t\t} finally {\n\t\t\t\t\ttree.phase = prevPhase;\n\t\t\t\t}\n\t\t\t}).on(\"click\" + ns + \" dblclick\" + ns, function (event) {\n\t\t\t\t// that.tree.debug(\"event(\" + event + \"): !\");\n\t\t\t\tif (opts.disabled) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar ctx,\n\t\t\t\t    et = FT.getEventTarget(event),\n\t\t\t\t    node = et.node,\n\t\t\t\t    tree = that.tree,\n\t\t\t\t    prevPhase = tree.phase;\n\n\t\t\t\t// that.tree.debug(\"event(\" + event.type + \"): node: \", node);\n\t\t\t\tif (!node) {\n\t\t\t\t\treturn true; // Allow bubbling of other events\n\t\t\t\t}\n\t\t\t\tctx = tree._makeHookContext(node, event);\n\t\t\t\t// that.tree.debug(\"event(\" + event.type + \"): node: \", node);\n\t\t\t\ttry {\n\t\t\t\t\ttree.phase = \"userEvent\";\n\t\t\t\t\tswitch (event.type) {\n\t\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\t\tctx.targetType = et.type;\n\t\t\t\t\t\t\tif (node.isPagingNode()) {\n\t\t\t\t\t\t\t\treturn tree._triggerNodeEvent(\"clickPaging\", ctx, event) === true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn tree._triggerNodeEvent(\"click\", ctx, event) === false ? false : tree._callHook(\"nodeClick\", ctx);\n\t\t\t\t\t\tcase \"dblclick\":\n\t\t\t\t\t\t\tctx.targetType = et.type;\n\t\t\t\t\t\t\treturn tree._triggerNodeEvent(\"dblclick\", ctx, event) === false ? false : tree._callHook(\"nodeDblclick\", ctx);\n\t\t\t\t\t}\n\t\t\t\t\t//             } catch(e) {\n\t\t\t\t\t// //                var _ = null; // DT issue 117 // TODO\n\t\t\t\t\t//                 $.error(e);\n\t\t\t\t} finally {\n\t\t\t\t\ttree.phase = prevPhase;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t/** Return the active node or null.\n   * @returns {FancytreeNode}\n   */\n\t\tgetActiveNode: function getActiveNode() {\n\t\t\treturn this.tree.activeNode;\n\t\t},\n\t\t/** Return the matching node or null.\n   * @param {string} key\n   * @returns {FancytreeNode}\n   */\n\t\tgetNodeByKey: function getNodeByKey(key) {\n\t\t\treturn this.tree.getNodeByKey(key);\n\t\t},\n\t\t/** Return the invisible system root node.\n   * @returns {FancytreeNode}\n   */\n\t\tgetRootNode: function getRootNode() {\n\t\t\treturn this.tree.rootNode;\n\t\t},\n\t\t/** Return the current tree instance.\n   * @returns {Fancytree}\n   */\n\t\tgetTree: function getTree() {\n\t\t\treturn this.tree;\n\t\t}\n\t});\n\n\t// $.ui.fancytree was created by the widget factory. Create a local shortcut:\n\tFT = $.ui.fancytree;\n\n\t/**\n  * Static members in the `$.ui.fancytree` namespace.<br>\n  * <br>\n  * <pre class=\"sh_javascript sunlight-highlight-javascript\">// Access static members:\n  * var node = $.ui.fancytree.getNode(element);\n  * alert($.ui.fancytree.version);\n  * </pre>\n  *\n  * @mixin Fancytree_Static\n  */\n\t$.extend($.ui.fancytree,\n\t/** @lends Fancytree_Static# */\n\t{\n\t\t/** @type {string} */\n\t\tversion: \"2.21.0\", // Set to semver by 'grunt release'\n\t\t/** @type {string} */\n\t\tbuildType: \"production\", // Set to 'production' by 'grunt build'\n\t\t/** @type {int} */\n\t\tdebugLevel: 1, // Set to 1 by 'grunt build'\n\t\t// Used by $.ui.fancytree.debug() and as default for tree.options.debugLevel\n\n\t\t_nextId: 1,\n\t\t_nextNodeKey: 1,\n\t\t_extensions: {},\n\t\t// focusTree: null,\n\n\t\t/** Expose class object as $.ui.fancytree._FancytreeClass */\n\t\t_FancytreeClass: Fancytree,\n\t\t/** Expose class object as $.ui.fancytree._FancytreeNodeClass */\n\t\t_FancytreeNodeClass: FancytreeNode,\n\t\t/* Feature checks to provide backwards compatibility */\n\t\tjquerySupports: {\n\t\t\t// http://jqueryui.com/upgrade-guide/1.9/#deprecated-offset-option-merged-into-my-and-at\n\t\t\tpositionMyOfs: isVersionAtLeast($.ui.version, 1, 9)\n\t\t},\n\t\t/** Throw an error if condition fails (debug method).\n   * @param {boolean} cond\n   * @param {string} msg\n   */\n\t\tassert: function assert(cond, msg) {\n\t\t\treturn _assert(cond, msg);\n\t\t},\n\t\t/** Return a function that executes *fn* at most every *timeout* ms.\n   * @param {integer} timeout\n   * @param {function} fn\n   * @param {boolean} [invokeAsap=false]\n   * @param {any} [ctx]\n   */\n\t\tdebounce: function debounce(timeout, fn, invokeAsap, ctx) {\n\t\t\tvar timer;\n\t\t\tif (arguments.length === 3 && typeof invokeAsap !== \"boolean\") {\n\t\t\t\tctx = invokeAsap;\n\t\t\t\tinvokeAsap = false;\n\t\t\t}\n\t\t\treturn function () {\n\t\t\t\tvar args = arguments;\n\t\t\t\tctx = ctx || this;\n\t\t\t\tinvokeAsap && !timer && fn.apply(ctx, args);\n\t\t\t\tclearTimeout(timer);\n\t\t\t\ttimer = setTimeout(function () {\n\t\t\t\t\tinvokeAsap || fn.apply(ctx, args);\n\t\t\t\t\ttimer = null;\n\t\t\t\t}, timeout);\n\t\t\t};\n\t\t},\n\t\t/** Write message to console if debugLevel >= 2\n   * @param {string} msg\n   */\n\t\tdebug: function debug(msg) {\n\t\t\t/*jshint expr:true */\n\t\t\t$.ui.fancytree.debugLevel >= 2 && consoleApply(\"log\", arguments);\n\t\t},\n\t\t/** Write error message to console.\n   * @param {string} msg\n   */\n\t\terror: function error(msg) {\n\t\t\tconsoleApply(\"error\", arguments);\n\t\t},\n\t\t/** Convert &lt;, &gt;, &amp;, &quot;, &#39;, &#x2F; to the equivalent entities.\n   *\n   * @param {string} s\n   * @returns {string}\n   */\n\t\tescapeHtml: _escapeHtml,\n\t\t/** Make jQuery.position() arguments backwards compatible, i.e. if\n   * jQuery UI version <= 1.8, convert\n   *   { my: \"left+3 center\", at: \"left bottom\", of: $target }\n   * to\n   *   { my: \"left center\", at: \"left bottom\", of: $target, offset: \"3  0\" }\n   *\n   * See http://jqueryui.com/upgrade-guide/1.9/#deprecated-offset-option-merged-into-my-and-at\n   * and http://jsfiddle.net/mar10/6xtu9a4e/\n   */\n\t\tfixPositionOptions: function fixPositionOptions(opts) {\n\t\t\tif (opts.offset || (\"\" + opts.my + opts.at).indexOf(\"%\") >= 0) {\n\t\t\t\t$.error(\"expected new position syntax (but '%' is not supported)\");\n\t\t\t}\n\t\t\tif (!$.ui.fancytree.jquerySupports.positionMyOfs) {\n\t\t\t\tvar // parse 'left+3 center' into ['left+3 center', 'left', '+3', 'center', undefined]\n\t\t\t\tmyParts = /(\\w+)([+-]?\\d+)?\\s+(\\w+)([+-]?\\d+)?/.exec(opts.my),\n\t\t\t\t    atParts = /(\\w+)([+-]?\\d+)?\\s+(\\w+)([+-]?\\d+)?/.exec(opts.at),\n\n\t\t\t\t// convert to numbers\n\t\t\t\tdx = (myParts[2] ? +myParts[2] : 0) + (atParts[2] ? +atParts[2] : 0),\n\t\t\t\t    dy = (myParts[4] ? +myParts[4] : 0) + (atParts[4] ? +atParts[4] : 0);\n\n\t\t\t\topts = $.extend({}, opts, { // make a copy and overwrite\n\t\t\t\t\tmy: myParts[1] + \" \" + myParts[3],\n\t\t\t\t\tat: atParts[1] + \" \" + atParts[3]\n\t\t\t\t});\n\t\t\t\tif (dx || dy) {\n\t\t\t\t\topts.offset = \"\" + dx + \" \" + dy;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opts;\n\t\t},\n\t\t/** Return a {node: FancytreeNode, type: TYPE} object for a mouse event.\n   *\n   * @param {Event} event Mouse event, e.g. click, ...\n   * @returns {string} 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined\n   */\n\t\tgetEventTargetType: function getEventTargetType(event) {\n\t\t\treturn this.getEventTarget(event).type;\n\t\t},\n\t\t/** Return a {node: FancytreeNode, type: TYPE} object for a mouse event.\n   *\n   * @param {Event} event Mouse event, e.g. click, ...\n   * @returns {object} Return a {node: FancytreeNode, type: TYPE} object\n   *     TYPE: 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined\n   */\n\t\tgetEventTarget: function getEventTarget(event) {\n\t\t\tvar tcn = event && event.target ? event.target.className : \"\",\n\t\t\t    res = { node: this.getNode(event.target), type: undefined };\n\t\t\t// We use a fast version of $(res.node).hasClass()\n\t\t\t// See http://jsperf.com/test-for-classname/2\n\t\t\tif (/\\bfancytree-title\\b/.test(tcn)) {\n\t\t\t\tres.type = \"title\";\n\t\t\t} else if (/\\bfancytree-expander\\b/.test(tcn)) {\n\t\t\t\tres.type = res.node.hasChildren() === false ? \"prefix\" : \"expander\";\n\t\t\t} else if (/\\bfancytree-checkbox\\b/.test(tcn) || /\\bfancytree-radio\\b/.test(tcn)) {\n\t\t\t\tres.type = \"checkbox\";\n\t\t\t} else if (/\\bfancytree-icon\\b/.test(tcn)) {\n\t\t\t\tres.type = \"icon\";\n\t\t\t} else if (/\\bfancytree-node\\b/.test(tcn)) {\n\t\t\t\t// Somewhere near the title\n\t\t\t\tres.type = \"title\";\n\t\t\t} else if (event && event.target && $(event.target).closest(\".fancytree-title\").length) {\n\t\t\t\t// #228: clicking an embedded element inside a title\n\t\t\t\tres.type = \"title\";\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\t/** Return a FancytreeNode instance from element, event, or jQuery object.\n   *\n   * @param {Element | jQueryObject | Event} el\n   * @returns {FancytreeNode} matching node or null\n   */\n\t\tgetNode: function getNode(el) {\n\t\t\tif (el instanceof FancytreeNode) {\n\t\t\t\treturn el; // el already was a FancytreeNode\n\t\t\t} else if (el.selector !== undefined) {\n\t\t\t\tel = el[0]; // el was a jQuery object: use the DOM element\n\t\t\t} else if (el.originalEvent !== undefined) {\n\t\t\t\tel = el.target; // el was an Event\n\t\t\t}\n\t\t\twhile (el) {\n\t\t\t\tif (el.ftnode) {\n\t\t\t\t\treturn el.ftnode;\n\t\t\t\t}\n\t\t\t\tel = el.parentNode;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/** Return a Fancytree instance, from element, index, event, or jQueryObject.\n   *\n   * @param {Element | jQueryObject | Event | integer | string} [el]\n   * @returns {Fancytree} matching tree or null\n   * @example\n   * $.ui.fancytree.getTree();   // Get first Fancytree instance on page\n   * $.ui.fancytree.getTree(1);  // Get second Fancytree instance on page\n   * $.ui.fancytree.getTree(\"#tree\"); // Get tree for this matching element\n   *\n   * @since 2.13\n   */\n\t\tgetTree: function getTree(el) {\n\t\t\tvar widget;\n\n\t\t\tif (el instanceof Fancytree) {\n\t\t\t\treturn el; // el already was a Fancytree\n\t\t\t}\n\t\t\tif (el === undefined) {\n\t\t\t\tel = 0; // get first tree\n\t\t\t}\n\t\t\tif (typeof el === \"number\") {\n\t\t\t\tel = $(\".fancytree-container\").eq(el); // el was an integer: return nth instance\n\t\t\t} else if (typeof el === \"string\") {\n\t\t\t\tel = $(el).eq(0); // el was a selector: use first match\n\t\t\t} else if (el.selector !== undefined) {\n\t\t\t\tel = el.eq(0); // el was a jQuery object: use the first DOM element\n\t\t\t} else if (el.originalEvent !== undefined) {\n\t\t\t\tel = $(el.target); // el was an Event\n\t\t\t}\n\t\t\tel = el.closest(\":ui-fancytree\");\n\t\t\twidget = el.data(\"ui-fancytree\") || el.data(\"fancytree\"); // the latter is required by jQuery <= 1.8\n\t\t\treturn widget ? widget.tree : null;\n\t\t},\n\t\t/** Convert a keydown or mouse event to a canonical string like 'ctrl+a', 'ctrl+shift+f2', 'shift+leftdblclick'.\n   * This is especially handy for switch-statements in event handlers.\n   * @param {event}\n   * @returns {string}\n   */\n\t\teventToString: function eventToString(event) {\n\t\t\t// Poor-man's hotkeys. See here for a complete implementation:\n\t\t\t//   https://github.com/jeresig/jquery.hotkeys\n\t\t\tvar which = event.which,\n\t\t\t    et = event.type,\n\t\t\t    s = [];\n\n\t\t\tif (event.altKey) {\n\t\t\t\ts.push(\"alt\");\n\t\t\t}\n\t\t\tif (event.ctrlKey) {\n\t\t\t\ts.push(\"ctrl\");\n\t\t\t}\n\t\t\tif (event.metaKey) {\n\t\t\t\ts.push(\"meta\");\n\t\t\t}\n\t\t\tif (event.shiftKey) {\n\t\t\t\ts.push(\"shift\");\n\t\t\t}\n\n\t\t\tif (et === \"click\" || et === \"dblclick\") {\n\t\t\t\ts.push(MOUSE_BUTTONS[event.button] + et);\n\t\t\t} else {\n\t\t\t\tif (!IGNORE_KEYCODES[which]) {\n\t\t\t\t\ts.push(SPECIAL_KEYCODES[which] || String.fromCharCode(which).toLowerCase());\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s.join(\"+\");\n\t\t},\n\t\t/** Write message to console if debugLevel >= 1\n   * @param {string} msg\n   */\n\t\tinfo: function info(msg) {\n\t\t\t/*jshint expr:true */\n\t\t\t$.ui.fancytree.debugLevel >= 1 && consoleApply(\"info\", arguments);\n\t\t},\n\t\t/* @deprecated: use eventToString(event) instead.\n   */\n\t\tkeyEventToString: function keyEventToString(event) {\n\t\t\tthis.warn(\"keyEventToString() is deprecated: use eventToString()\");\n\t\t\treturn this.eventToString(event);\n\t\t},\n\t\t/** Return a wrapped handler method, that provides `this.super`.\n   *\n   * @example\n  \t// Implement `opts.createNode` event to add the 'draggable' attribute\n  \t$.ui.fancytree.overrideMethod(ctx.options, \"createNode\", function(event, data) {\n  \t\t// Default processing if any\n  \t\tthis._super.apply(this, arguments);\n  \t\t// Add 'draggable' attribute\n  \t\tdata.node.span.draggable = true;\n  \t});\n   *\n   * @param {object} instance\n   * @param {string} methodName\n   * @param {function} handler\n   */\n\t\toverrideMethod: function overrideMethod(instance, methodName, handler) {\n\t\t\tvar prevSuper,\n\t\t\t    _super = instance[methodName] || $.noop;\n\n\t\t\t// context = context || this;\n\n\t\t\tinstance[methodName] = function () {\n\t\t\t\ttry {\n\t\t\t\t\tprevSuper = this._super;\n\t\t\t\t\tthis._super = _super;\n\t\t\t\t\treturn handler.apply(this, arguments);\n\t\t\t\t} finally {\n\t\t\t\t\tthis._super = prevSuper;\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\t\t/**\n   * Parse tree data from HTML <ul> markup\n   *\n   * @param {jQueryObject} $ul\n   * @returns {NodeData[]}\n   */\n\t\tparseHtml: function parseHtml($ul) {\n\t\t\t// TODO: understand this:\n\t\t\t/*jshint validthis:true */\n\t\t\tvar classes,\n\t\t\t    className,\n\t\t\t    extraClasses,\n\t\t\t    i,\n\t\t\t    iPos,\n\t\t\t    l,\n\t\t\t    tmp,\n\t\t\t    tmp2,\n\t\t\t    $children = $ul.find(\">li\"),\n\t\t\t    children = [];\n\n\t\t\t$children.each(function () {\n\t\t\t\tvar allData,\n\t\t\t\t    lowerCaseAttr,\n\t\t\t\t    $li = $(this),\n\t\t\t\t    $liSpan = $li.find(\">span:first\", this),\n\t\t\t\t    $liA = $liSpan.length ? null : $li.find(\">a:first\"),\n\t\t\t\t    d = { tooltip: null, data: {} };\n\n\t\t\t\tif ($liSpan.length) {\n\t\t\t\t\td.title = $liSpan.html();\n\t\t\t\t} else if ($liA && $liA.length) {\n\t\t\t\t\t// If a <li><a> tag is specified, use it literally and extract href/target.\n\t\t\t\t\td.title = $liA.html();\n\t\t\t\t\td.data.href = $liA.attr(\"href\");\n\t\t\t\t\td.data.target = $liA.attr(\"target\");\n\t\t\t\t\td.tooltip = $liA.attr(\"title\");\n\t\t\t\t} else {\n\t\t\t\t\t// If only a <li> tag is specified, use the trimmed string up to\n\t\t\t\t\t// the next child <ul> tag.\n\t\t\t\t\td.title = $li.html();\n\t\t\t\t\tiPos = d.title.search(/<ul/i);\n\t\t\t\t\tif (iPos >= 0) {\n\t\t\t\t\t\td.title = d.title.substring(0, iPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td.title = $.trim(d.title);\n\n\t\t\t\t// Make sure all fields exist\n\t\t\t\tfor (i = 0, l = CLASS_ATTRS.length; i < l; i++) {\n\t\t\t\t\td[CLASS_ATTRS[i]] = undefined;\n\t\t\t\t}\n\t\t\t\t// Initialize to `true`, if class is set and collect extraClasses\n\t\t\t\tclasses = this.className.split(\" \");\n\t\t\t\textraClasses = [];\n\t\t\t\tfor (i = 0, l = classes.length; i < l; i++) {\n\t\t\t\t\tclassName = classes[i];\n\t\t\t\t\tif (CLASS_ATTR_MAP[className]) {\n\t\t\t\t\t\td[className] = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\textraClasses.push(className);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td.extraClasses = extraClasses.join(\" \");\n\n\t\t\t\t// Parse node options from ID, title and class attributes\n\t\t\t\ttmp = $li.attr(\"title\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\td.tooltip = tmp; // overrides <a title='...'>\n\t\t\t\t}\n\t\t\t\ttmp = $li.attr(\"id\");\n\t\t\t\tif (tmp) {\n\t\t\t\t\td.key = tmp;\n\t\t\t\t}\n\t\t\t\t// Add <li data-NAME='...'> as node.data.NAME\n\t\t\t\tallData = _getElementDataAsDict($li);\n\t\t\t\tif (allData && !$.isEmptyObject(allData)) {\n\t\t\t\t\t// #507: convert data-hidecheckbox (lower case) to hideCheckbox\n\t\t\t\t\tfor (lowerCaseAttr in NODE_ATTR_LOWERCASE_MAP) {\n\t\t\t\t\t\tif (allData.hasOwnProperty(lowerCaseAttr)) {\n\t\t\t\t\t\t\tallData[NODE_ATTR_LOWERCASE_MAP[lowerCaseAttr]] = allData[lowerCaseAttr];\n\t\t\t\t\t\t\tdelete allData[lowerCaseAttr];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// #56: Allow to set special node.attributes from data-...\n\t\t\t\t\tfor (i = 0, l = NODE_ATTRS.length; i < l; i++) {\n\t\t\t\t\t\ttmp = NODE_ATTRS[i];\n\t\t\t\t\t\ttmp2 = allData[tmp];\n\t\t\t\t\t\tif (tmp2 != null) {\n\t\t\t\t\t\t\tdelete allData[tmp];\n\t\t\t\t\t\t\td[tmp] = tmp2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// All other data-... goes to node.data...\n\t\t\t\t\t$.extend(d.data, allData);\n\t\t\t\t}\n\t\t\t\t// Recursive reading of child nodes, if LI tag contains an UL tag\n\t\t\t\t$ul = $li.find(\">ul:first\");\n\t\t\t\tif ($ul.length) {\n\t\t\t\t\td.children = $.ui.fancytree.parseHtml($ul);\n\t\t\t\t} else {\n\t\t\t\t\td.children = d.lazy ? undefined : null;\n\t\t\t\t}\n\t\t\t\tchildren.push(d);\n\t\t\t\t//            FT.debug(\"parse \", d, children);\n\t\t\t});\n\t\t\treturn children;\n\t\t},\n\t\t/** Add Fancytree extension definition to the list of globally available extensions.\n   *\n   * @param {object} definition\n   */\n\t\tregisterExtension: function registerExtension(definition) {\n\t\t\t_assert(definition.name != null, \"extensions must have a `name` property.\");\n\t\t\t_assert(definition.version != null, \"extensions must have a `version` property.\");\n\t\t\t$.ui.fancytree._extensions[definition.name] = definition;\n\t\t},\n\t\t/** Inverse of escapeHtml().\n   *\n   * @param {string} s\n   * @returns {string}\n   */\n\t\tunescapeHtml: function unescapeHtml(s) {\n\t\t\tvar e = document.createElement(\"div\");\n\t\t\te.innerHTML = s;\n\t\t\treturn e.childNodes.length === 0 ? \"\" : e.childNodes[0].nodeValue;\n\t\t},\n\t\t/** Write warning message to console.\n   * @param {string} msg\n   */\n\t\twarn: function warn(msg) {\n\t\t\tconsoleApply(\"warn\", arguments);\n\t\t}\n\t});\n})(jQuery, window, document);\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/bower_components/fancytree/dist/src/jquery.fancytree.js?");

/***/ }),

/***/ "../../../node_modules/core-js/es6/map.js":
/*!*******************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/es6/map.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ../modules/es6.object.to-string */ \"../../../node_modules/core-js/modules/es6.object.to-string.js\");\n__webpack_require__(/*! ../modules/es6.string.iterator */ \"../../../node_modules/core-js/modules/es6.string.iterator.js\");\n__webpack_require__(/*! ../modules/web.dom.iterable */ \"../../../node_modules/core-js/modules/web.dom.iterable.js\");\n__webpack_require__(/*! ../modules/es6.map */ \"../../../node_modules/core-js/modules/es6.map.js\");\nmodule.exports = __webpack_require__(/*! ../modules/$.core */ \"../../../node_modules/core-js/modules/$.core.js\").Map;\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/es6/map.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.a-function.js":
/*!********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.a-function.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.a-function.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.add-to-unscopables.js":
/*!****************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.add-to-unscopables.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('unscopables')\n  , ArrayProto  = Array.prototype;\nif(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function(key){\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.add-to-unscopables.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.an-object.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.an-object.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ./$.is-object */ \"../../../node_modules/core-js/modules/$.is-object.js\");\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.an-object.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.classof.js":
/*!*****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.classof.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(/*! ./$.cof */ \"../../../node_modules/core-js/modules/$.cof.js\")\n  , TAG = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.classof.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.cof.js":
/*!*************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.cof.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.cof.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.collection-strong.js":
/*!***************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.collection-strong.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar $            = __webpack_require__(/*! ./$ */ \"../../../node_modules/core-js/modules/$.js\")\n  , hide         = __webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")\n  , redefineAll  = __webpack_require__(/*! ./$.redefine-all */ \"../../../node_modules/core-js/modules/$.redefine-all.js\")\n  , ctx          = __webpack_require__(/*! ./$.ctx */ \"../../../node_modules/core-js/modules/$.ctx.js\")\n  , strictNew    = __webpack_require__(/*! ./$.strict-new */ \"../../../node_modules/core-js/modules/$.strict-new.js\")\n  , defined      = __webpack_require__(/*! ./$.defined */ \"../../../node_modules/core-js/modules/$.defined.js\")\n  , forOf        = __webpack_require__(/*! ./$.for-of */ \"../../../node_modules/core-js/modules/$.for-of.js\")\n  , $iterDefine  = __webpack_require__(/*! ./$.iter-define */ \"../../../node_modules/core-js/modules/$.iter-define.js\")\n  , step         = __webpack_require__(/*! ./$.iter-step */ \"../../../node_modules/core-js/modules/$.iter-step.js\")\n  , ID           = __webpack_require__(/*! ./$.uid */ \"../../../node_modules/core-js/modules/$.uid.js\")('id')\n  , $has         = __webpack_require__(/*! ./$.has */ \"../../../node_modules/core-js/modules/$.has.js\")\n  , isObject     = __webpack_require__(/*! ./$.is-object */ \"../../../node_modules/core-js/modules/$.is-object.js\")\n  , setSpecies   = __webpack_require__(/*! ./$.set-species */ \"../../../node_modules/core-js/modules/$.set-species.js\")\n  , DESCRIPTORS  = __webpack_require__(/*! ./$.descriptors */ \"../../../node_modules/core-js/modules/$.descriptors.js\")\n  , isExtensible = Object.isExtensible || isObject\n  , SIZE         = DESCRIPTORS ? '_s' : 'size'\n  , id           = 0;\n\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!$has(it, ID)){\n    // can't set id to frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add id\n    if(!create)return 'E';\n    // add missing object id\n    hide(it, ID, ++id);\n  // return object id with prefix\n  } return 'O' + it[ID];\n};\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      strictNew(that, C, NAME);\n      that._i = $.create(null); // index\n      that._f = undefined;      // first entry\n      that._l = undefined;      // last entry\n      that[SIZE] = 0;           // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)$.setDesc(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.collection-strong.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.collection.js":
/*!********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.collection.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar global         = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\")\n  , $export        = __webpack_require__(/*! ./$.export */ \"../../../node_modules/core-js/modules/$.export.js\")\n  , redefine       = __webpack_require__(/*! ./$.redefine */ \"../../../node_modules/core-js/modules/$.redefine.js\")\n  , redefineAll    = __webpack_require__(/*! ./$.redefine-all */ \"../../../node_modules/core-js/modules/$.redefine-all.js\")\n  , forOf          = __webpack_require__(/*! ./$.for-of */ \"../../../node_modules/core-js/modules/$.for-of.js\")\n  , strictNew      = __webpack_require__(/*! ./$.strict-new */ \"../../../node_modules/core-js/modules/$.strict-new.js\")\n  , isObject       = __webpack_require__(/*! ./$.is-object */ \"../../../node_modules/core-js/modules/$.is-object.js\")\n  , fails          = __webpack_require__(/*! ./$.fails */ \"../../../node_modules/core-js/modules/$.fails.js\")\n  , $iterDetect    = __webpack_require__(/*! ./$.iter-detect */ \"../../../node_modules/core-js/modules/$.iter-detect.js\")\n  , setToStringTag = __webpack_require__(/*! ./$.set-to-string-tag */ \"../../../node_modules/core-js/modules/$.set-to-string-tag.js\");\n\nmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n  var Base  = global[NAME]\n    , C     = Base\n    , ADDER = IS_MAP ? 'set' : 'add'\n    , proto = C && C.prototype\n    , O     = {};\n  var fixMethod = function(KEY){\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a){\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n    new C().entries().next();\n  }))){\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n  } else {\n    var instance             = new C\n      // early implementations not supports chaining\n      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance\n      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })\n      // most early implementations doesn't supports iterables, most modern - not close it correctly\n      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new\n      // for early implementations -0 and +0 not the same\n      , BUGGY_ZERO;\n    if(!ACCEPT_ITERABLES){ \n      C = wrapper(function(target, iterable){\n        strictNew(target, C, NAME);\n        var that = new Base;\n        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    IS_WEAK || instance.forEach(function(val, key){\n      BUGGY_ZERO = 1 / key === -Infinity;\n    });\n    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if(IS_WEAK && proto.clear)delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.collection.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.core.js":
/*!**************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.core.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var core = module.exports = {version: '1.2.6'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.core.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.ctx.js":
/*!*************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.ctx.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// optional / simple context binding\nvar aFunction = __webpack_require__(/*! ./$.a-function */ \"../../../node_modules/core-js/modules/$.a-function.js\");\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.ctx.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.defined.js":
/*!*****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.defined.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.defined.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.descriptors.js":
/*!*********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.descriptors.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(/*! ./$.fails */ \"../../../node_modules/core-js/modules/$.fails.js\")(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.descriptors.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.export.js":
/*!****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.export.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global    = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\")\n  , core      = __webpack_require__(/*! ./$.core */ \"../../../node_modules/core-js/modules/$.core.js\")\n  , hide      = __webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")\n  , redefine  = __webpack_require__(/*! ./$.redefine */ \"../../../node_modules/core-js/modules/$.redefine.js\")\n  , ctx       = __webpack_require__(/*! ./$.ctx */ \"../../../node_modules/core-js/modules/$.ctx.js\")\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})\n    , key, own, out, exp;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if(target && !own)redefine(target, key, out);\n    // export\n    if(exports[key] != out)hide(exports, key, exp);\n    if(IS_PROTO && expProto[key] != out)expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;  // forced\n$export.G = 2;  // global\n$export.S = 4;  // static\n$export.P = 8;  // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.export.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.fails.js":
/*!***************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.fails.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.fails.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.for-of.js":
/*!****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.for-of.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ctx         = __webpack_require__(/*! ./$.ctx */ \"../../../node_modules/core-js/modules/$.ctx.js\")\n  , call        = __webpack_require__(/*! ./$.iter-call */ \"../../../node_modules/core-js/modules/$.iter-call.js\")\n  , isArrayIter = __webpack_require__(/*! ./$.is-array-iter */ \"../../../node_modules/core-js/modules/$.is-array-iter.js\")\n  , anObject    = __webpack_require__(/*! ./$.an-object */ \"../../../node_modules/core-js/modules/$.an-object.js\")\n  , toLength    = __webpack_require__(/*! ./$.to-length */ \"../../../node_modules/core-js/modules/$.to-length.js\")\n  , getIterFn   = __webpack_require__(/*! ./core.get-iterator-method */ \"../../../node_modules/core-js/modules/core.get-iterator-method.js\");\nmodule.exports = function(iterable, entries, fn, that){\n  var iterFn = getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    call(iterator, f, step.value, entries);\n  }\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.for-of.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.global.js":
/*!****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.global.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.global.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.has.js":
/*!*************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.has.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.has.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.hide.js":
/*!**************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.hide.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var $          = __webpack_require__(/*! ./$ */ \"../../../node_modules/core-js/modules/$.js\")\n  , createDesc = __webpack_require__(/*! ./$.property-desc */ \"../../../node_modules/core-js/modules/$.property-desc.js\");\nmodule.exports = __webpack_require__(/*! ./$.descriptors */ \"../../../node_modules/core-js/modules/$.descriptors.js\") ? function(object, key, value){\n  return $.setDesc(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.hide.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iobject.js":
/*!*****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iobject.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(/*! ./$.cof */ \"../../../node_modules/core-js/modules/$.cof.js\");\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iobject.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.is-array-iter.js":
/*!***********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.is-array-iter.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// check on default Array iterator\nvar Iterators  = __webpack_require__(/*! ./$.iterators */ \"../../../node_modules/core-js/modules/$.iterators.js\")\n  , ITERATOR   = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.is-array-iter.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.is-object.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.is-object.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.is-object.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iter-call.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-call.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(/*! ./$.an-object */ \"../../../node_modules/core-js/modules/$.an-object.js\");\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-call.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iter-create.js":
/*!*********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-create.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar $              = __webpack_require__(/*! ./$ */ \"../../../node_modules/core-js/modules/$.js\")\n  , descriptor     = __webpack_require__(/*! ./$.property-desc */ \"../../../node_modules/core-js/modules/$.property-desc.js\")\n  , setToStringTag = __webpack_require__(/*! ./$.set-to-string-tag */ \"../../../node_modules/core-js/modules/$.set-to-string-tag.js\")\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")(IteratorPrototype, __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-create.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iter-define.js":
/*!*********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-define.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar LIBRARY        = __webpack_require__(/*! ./$.library */ \"../../../node_modules/core-js/modules/$.library.js\")\n  , $export        = __webpack_require__(/*! ./$.export */ \"../../../node_modules/core-js/modules/$.export.js\")\n  , redefine       = __webpack_require__(/*! ./$.redefine */ \"../../../node_modules/core-js/modules/$.redefine.js\")\n  , hide           = __webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")\n  , has            = __webpack_require__(/*! ./$.has */ \"../../../node_modules/core-js/modules/$.has.js\")\n  , Iterators      = __webpack_require__(/*! ./$.iterators */ \"../../../node_modules/core-js/modules/$.iterators.js\")\n  , $iterCreate    = __webpack_require__(/*! ./$.iter-create */ \"../../../node_modules/core-js/modules/$.iter-create.js\")\n  , setToStringTag = __webpack_require__(/*! ./$.set-to-string-tag */ \"../../../node_modules/core-js/modules/$.set-to-string-tag.js\")\n  , getProto       = __webpack_require__(/*! ./$ */ \"../../../node_modules/core-js/modules/$.js\").getProto\n  , ITERATOR       = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , methods, key;\n  // Fix native\n  if($native){\n    var IteratorPrototype = getProto($default.call(new Base));\n    // Set @@toStringTag to native iterators\n    setToStringTag(IteratorPrototype, TAG, true);\n    // FF fix\n    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    // fix Array#{values, @@iterator}.name in V8 / FF\n    if(DEF_VALUES && $native.name !== VALUES){\n      VALUES_BUG = true;\n      $default = function values(){ return $native.call(this); };\n    }\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n      keys:    IS_SET      ? $default : getMethod(KEYS),\n      entries: !DEF_VALUES ? $default : getMethod('entries')\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-define.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iter-detect.js":
/*!*********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-detect.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ITERATOR     = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-detect.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iter-step.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-step.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iter-step.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.iterators.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iterators.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.iterators.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.js":
/*!*********************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.library.js":
/*!*****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.library.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = false;\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.library.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.property-desc.js":
/*!***********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.property-desc.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.property-desc.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.redefine-all.js":
/*!**********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.redefine-all.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var redefine = __webpack_require__(/*! ./$.redefine */ \"../../../node_modules/core-js/modules/$.redefine.js\");\nmodule.exports = function(target, src){\n  for(var key in src)redefine(target, key, src[key]);\n  return target;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.redefine-all.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.redefine.js":
/*!******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.redefine.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// add fake Function#toString\n// for correct work wrapped methods / constructors with methods like LoDash isNative\nvar global    = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\")\n  , hide      = __webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")\n  , SRC       = __webpack_require__(/*! ./$.uid */ \"../../../node_modules/core-js/modules/$.uid.js\")('src')\n  , TO_STRING = 'toString'\n  , $toString = Function[TO_STRING]\n  , TPL       = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(/*! ./$.core */ \"../../../node_modules/core-js/modules/$.core.js\").inspectSource = function(it){\n  return $toString.call(it);\n};\n\n(module.exports = function(O, key, val, safe){\n  if(typeof val == 'function'){\n    val.hasOwnProperty(SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n    val.hasOwnProperty('name') || hide(val, 'name', key);\n  }\n  if(O === global){\n    O[key] = val;\n  } else {\n    if(!safe)delete O[key];\n    hide(O, key, val);\n  }\n})(Function.prototype, TO_STRING, function toString(){\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.redefine.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.set-species.js":
/*!*********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.set-species.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar global      = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\")\n  , $           = __webpack_require__(/*! ./$ */ \"../../../node_modules/core-js/modules/$.js\")\n  , DESCRIPTORS = __webpack_require__(/*! ./$.descriptors */ \"../../../node_modules/core-js/modules/$.descriptors.js\")\n  , SPECIES     = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('species');\n\nmodule.exports = function(KEY){\n  var C = global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])$.setDesc(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.set-species.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.set-to-string-tag.js":
/*!***************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.set-to-string-tag.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var def = __webpack_require__(/*! ./$ */ \"../../../node_modules/core-js/modules/$.js\").setDesc\n  , has = __webpack_require__(/*! ./$.has */ \"../../../node_modules/core-js/modules/$.has.js\")\n  , TAG = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.set-to-string-tag.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.shared.js":
/*!****************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.shared.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\")\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.shared.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.strict-new.js":
/*!********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.strict-new.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(it, Constructor, name){\n  if(!(it instanceof Constructor))throw TypeError(name + \": use the 'new' operator!\");\n  return it;\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.strict-new.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.string-at.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.string-at.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toInteger = __webpack_require__(/*! ./$.to-integer */ \"../../../node_modules/core-js/modules/$.to-integer.js\")\n  , defined   = __webpack_require__(/*! ./$.defined */ \"../../../node_modules/core-js/modules/$.defined.js\");\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.string-at.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.to-integer.js":
/*!********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.to-integer.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.to-integer.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.to-iobject.js":
/*!********************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.to-iobject.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(/*! ./$.iobject */ \"../../../node_modules/core-js/modules/$.iobject.js\")\n  , defined = __webpack_require__(/*! ./$.defined */ \"../../../node_modules/core-js/modules/$.defined.js\");\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.to-iobject.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.to-length.js":
/*!*******************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.to-length.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(/*! ./$.to-integer */ \"../../../node_modules/core-js/modules/$.to-integer.js\")\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.to-length.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.uid.js":
/*!*************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.uid.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.uid.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/$.wks.js":
/*!*************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.wks.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var store  = __webpack_require__(/*! ./$.shared */ \"../../../node_modules/core-js/modules/$.shared.js\")('wks')\n  , uid    = __webpack_require__(/*! ./$.uid */ \"../../../node_modules/core-js/modules/$.uid.js\")\n  , Symbol = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\").Symbol;\nmodule.exports = function(name){\n  return store[name] || (store[name] =\n    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/$.wks.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/core.get-iterator-method.js":
/*!********************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/core.get-iterator-method.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var classof   = __webpack_require__(/*! ./$.classof */ \"../../../node_modules/core-js/modules/$.classof.js\")\n  , ITERATOR  = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('iterator')\n  , Iterators = __webpack_require__(/*! ./$.iterators */ \"../../../node_modules/core-js/modules/$.iterators.js\");\nmodule.exports = __webpack_require__(/*! ./$.core */ \"../../../node_modules/core-js/modules/$.core.js\").getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/core.get-iterator-method.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/es6.array.iterator.js":
/*!**************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.array.iterator.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar addToUnscopables = __webpack_require__(/*! ./$.add-to-unscopables */ \"../../../node_modules/core-js/modules/$.add-to-unscopables.js\")\n  , step             = __webpack_require__(/*! ./$.iter-step */ \"../../../node_modules/core-js/modules/$.iter-step.js\")\n  , Iterators        = __webpack_require__(/*! ./$.iterators */ \"../../../node_modules/core-js/modules/$.iterators.js\")\n  , toIObject        = __webpack_require__(/*! ./$.to-iobject */ \"../../../node_modules/core-js/modules/$.to-iobject.js\");\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(/*! ./$.iter-define */ \"../../../node_modules/core-js/modules/$.iter-define.js\")(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.array.iterator.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/es6.map.js":
/*!***************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.map.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar strong = __webpack_require__(/*! ./$.collection-strong */ \"../../../node_modules/core-js/modules/$.collection-strong.js\");\n\n// 23.1 Map Objects\n__webpack_require__(/*! ./$.collection */ \"../../../node_modules/core-js/modules/$.collection.js\")('Map', function(get){\n  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key){\n    var entry = strong.getEntry(this, key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value){\n    return strong.def(this, key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.map.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/es6.object.to-string.js":
/*!****************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.object.to-string.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// 19.1.3.6 Object.prototype.toString()\nvar classof = __webpack_require__(/*! ./$.classof */ \"../../../node_modules/core-js/modules/$.classof.js\")\n  , test    = {};\ntest[__webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('toStringTag')] = 'z';\nif(test + '' != '[object z]'){\n  __webpack_require__(/*! ./$.redefine */ \"../../../node_modules/core-js/modules/$.redefine.js\")(Object.prototype, 'toString', function toString(){\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.object.to-string.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/es6.string.iterator.js":
/*!***************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.string.iterator.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar $at  = __webpack_require__(/*! ./$.string-at */ \"../../../node_modules/core-js/modules/$.string-at.js\")(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(/*! ./$.iter-define */ \"../../../node_modules/core-js/modules/$.iter-define.js\")(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/es6.string.iterator.js?");

/***/ }),

/***/ "../../../node_modules/core-js/modules/web.dom.iterable.js":
/*!************************************************************************************************************!*\
  !*** /home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/web.dom.iterable.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./es6.array.iterator */ \"../../../node_modules/core-js/modules/es6.array.iterator.js\");\nvar global      = __webpack_require__(/*! ./$.global */ \"../../../node_modules/core-js/modules/$.global.js\")\n  , hide        = __webpack_require__(/*! ./$.hide */ \"../../../node_modules/core-js/modules/$.hide.js\")\n  , Iterators   = __webpack_require__(/*! ./$.iterators */ \"../../../node_modules/core-js/modules/$.iterators.js\")\n  , ITERATOR    = __webpack_require__(/*! ./$.wks */ \"../../../node_modules/core-js/modules/$.wks.js\")('iterator')\n  , NL          = global.NodeList\n  , HTC         = global.HTMLCollection\n  , NLProto     = NL && NL.prototype\n  , HTCProto    = HTC && HTC.prototype\n  , ArrayValues = Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\nif(NLProto && !NLProto[ITERATOR])hide(NLProto, ITERATOR, ArrayValues);\nif(HTCProto && !HTCProto[ITERATOR])hide(HTCProto, ITERATOR, ArrayValues);\n\n//# sourceURL=webpack:////home/maximilian/OpenSource/Cmf/tree-browser-bundle/node_modules/core-js/modules/web.dom.iterable.js?");

/***/ }),

/***/ "./css/fontawesome-style.css":
/*!***********************************!*\
  !*** ./css/fontawesome-style.css ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./css/fontawesome-style.css?");

/***/ }),

/***/ "./js/adapter/fancytree.js":
/*!*********************************!*\
  !*** ./js/adapter/fancytree.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.FancytreeAdapter = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n    function defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }return function (Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n    };\n}(); /*\n      * This file is part of the Symfony CMF package.\n      *\n      * (c) 2011-2017 Symfony CMF\n      *\n      * For the full copyright and license information, please view the LICENSE\n      * file that was distributed with this source code.\n      */\n\nvar _map = __webpack_require__(/*! core-js/es6/map */ \"../../../node_modules/core-js/es6/map.js\");\n\nvar _map2 = _interopRequireDefault(_map);\n\n__webpack_require__(/*! ../jquery.cmf_context_menu */ \"./js/jquery.cmf_context_menu.js\");\n\n__webpack_require__(/*! fancytree/src/jquery.fancytree.js */ \"../../../bower_components/fancytree/dist/src/jquery.fancytree.js\");\n\n__webpack_require__(/*! fancytree/src/jquery.fancytree.dnd.js */ \"../../../bower_components/fancytree/dist/src/jquery.fancytree.dnd.js\");\n\n__webpack_require__(/*! fancytree/skin-win8/ui.fancytree.css */ \"../../../bower_components/fancytree/dist/skin-win8/ui.fancytree.css\");\n\n__webpack_require__(/*! ../../css/fontawesome-style.css */ \"./css/fontawesome-style.css\");\n\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\n\nvar cache = new _map2.default();\n\nfunction getPropertyFromString(name, list) {\n    var isOptional = name.substr(0, 1) === '?';\n    var nameWithoutPrefix = isOptional ? name.substr(1) : name;\n\n    if (undefined === list[nameWithoutPrefix]) {\n        if (isOptional) {\n            return undefined;\n        }\n\n        throw 'Attribute \"' + props[prop] + '\" does not exists';\n    }\n\n    return list[nameWithoutPrefix];\n}\n\n/**\n * A tree browser adapter for the Fancytree library.\n *\n * @author Wouter J <wouter@wouterj.nl>\n * @see https://github.com/mar10/fancytree\n */\n\nvar FancytreeAdapter = exports.FancytreeAdapter = function () {\n    function FancytreeAdapter(options) {\n        _classCallCheck(this, FancytreeAdapter);\n\n        if (!window.jQuery || !jQuery.fn.fancytree) {\n            throw 'The FancytreeAdapter requires both jQuery and the FancyTree library.';\n        }\n\n        if (!options.request) {\n            throw 'The FancytreeAdapter requires a request option.';\n        }\n\n        this.requestData = options.request;\n        this.rootNode = options.root_node || '/';\n        this.useCache = undefined === options.use_cache ? true : options.use_cache;\n        this.boundToInput = false;\n        this.sortableBy = undefined == options.sortableBy ? false : options.sortableBy;\n\n        if (options.dnd && undefined == options.dnd.enabled) {\n            options.dnd.enabled = true;\n        }\n        var alwaysTrueFunction = function alwaysTrueFunction() {\n            return true;\n        };\n        this.dndOptions = jQuery.extend({\n            enabled: false,\n            isNodeDraggable: alwaysTrueFunction,\n            nodeAcceptsDraggable: alwaysTrueFunction\n        }, options.dnd);\n\n        if (this.dndOptions.enabled && !options.request.move) {\n            throw 'The move request needs to be configured when drag \\'n drop is enabled, pass it using the `request.move` option.';\n        }\n        this.dndOptions.request = options.request.move;\n\n        // available actions (array)\n        this.actions = new Array();\n        // the Fancytree instance (FancytreeTree)\n        this.tree = null;\n        // the tree element (jQuery)\n        this.$tree = null;\n        // a map of path and related keys\n        this.pathKeyMap = {};\n    }\n\n    _createClass(FancytreeAdapter, [{\n        key: 'bindToElement',\n        value: function bindToElement($elem) {\n            var _this = this;\n\n            if (this.$tree) {\n                throw 'Cannot bind to multiple elements.';\n            }\n\n            if (!$elem instanceof jQuery) {\n                throw 'FancytreeAdapter can only be adapted to a jQuery object.';\n            }\n\n            this.$tree = $elem;\n            var actions = this.actions;\n            var parseUrl = function parseUrl(url, node) {\n                if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) == 'object' && url.hasOwnProperty('data')) {\n                    return getPropertyFromString(url.data, node.descriptors);\n                }\n\n                if (typeof url == 'function') {\n                    return url(requestNode);\n                }\n\n                if (typeof url == 'string') {\n                    return url;\n                }\n            };\n            var requestNodeToFancytreeNode = function requestNodeToFancytreeNode(requestNode) {\n                if (requestNode.length === 0) {\n                    return;\n                }\n\n                if ('//' == requestNode.path || '/' == requestNode.path) {\n                    return requestNodeToFancytreeNode(requestNode.children[Object.keys(requestNode.children)[0]]);\n                }\n\n                var refPath = requestNode.path.replace('\\/', '/').replace('//', '/');\n                var key = _this.pathKeyMap[refPath] || \"\" + jQuery.ui.fancytree._nextNodeKey++;\n                var fancytreeNode = {\n                    title: requestNode.label,\n                    key: key,\n                    children: [],\n                    actions: {},\n                    refPath: refPath,\n                    type: requestNode.payload_type,\n                    unselectable: true\n                };\n\n                _this.pathKeyMap[refPath] = key;\n\n                if (requestNode.descriptors.hasOwnProperty('icon')) {\n                    fancytreeNode.icon = requestNode.descriptors.icon;\n                }\n\n                if (requestNode.descriptors.hasOwnProperty('position')) {\n                    fancytreeNode.position = requestNode.descriptors.position;\n                }\n\n                for (var actionName in actions) {\n                    var action = actions[actionName];\n                    var url = parseUrl(action.url, requestNode);\n\n                    if (url === undefined) {\n                        continue;\n                    }\n                    fancytreeNode['actions'][actionName] = { label: actionName, iconClass: action.icon, url: url };\n                }\n\n                var childrenCount = 0;\n                for (name in requestNode.children) {\n                    if (!requestNode.children.hasOwnProperty(name)) {\n                        continue;\n                    }\n\n                    var child = requestNodeToFancytreeNode(requestNode.children[name]);\n                    if (child) {\n                        fancytreeNode.children.push(child);\n                    }\n                    childrenCount++;\n                }\n\n                if (0 != childrenCount) {\n                    fancytreeNode.folder = true;\n                    fancytreeNode.lazy = true;\n\n                    if (0 === fancytreeNode.children.length) {\n                        fancytreeNode.children = null;\n                    }\n                }\n\n                return fancytreeNode;\n            };\n\n            var requestData = this.requestData;\n            var useCache = this.useCache;\n            var fancytreeOptions = {\n                // the start data (root node + children)\n                source: useCache && cache.has(this.rootNode) ? cache.get(this.rootNode) : requestData.load(this.rootNode),\n\n                // lazy load the children when a node is collapsed\n                lazyLoad: function lazyLoad(event, data) {\n                    var path = data.node.data.refPath;\n                    if (useCache && cache.has(path)) {\n                        data.result = cache.get(path);\n                    } else {\n                        var loadData = requestData.load(path);\n\n                        if (Array.isArray(loadData)) {\n                            data.result = loadData;\n                        } else {\n                            data.result = jQuery.extend({\n                                data: {}\n                            }, loadData);\n                        }\n                    }\n                },\n\n                // transform the JSON response into a data structure that's supported by FancyTree\n                postProcess: function postProcess(event, data) {\n                    if (data.hasOwnProperty('error') && null != data.error) {\n                        data.result = {\n                            // todo: maybe use a more admin friendly error message in prod?\n                            error: 'An error occured while retrieving the nodes: ' + data.error\n                        };\n\n                        return;\n                    }\n\n                    var result = requestNodeToFancytreeNode(data.response);\n                    var nodeIsDuplicate = function nodeIsDuplicate(node, parentPath) {\n                        return parentPath == node.refPath;\n                    };\n\n                    if (nodeIsDuplicate(result, data.node.data.refPath)) {\n                        result = result.children;\n                    } else {\n                        result = [result];\n                    }\n\n                    if (result.length == 1 && undefined !== result[0].folder) {\n                        result[0].expanded = true;\n                    }\n\n                    data.result = result;\n                    if (useCache) {\n                        cache.set(data.node.data.refPath, result);\n                    }\n                },\n\n                // always show the active node\n                activeVisible: true\n            };\n\n            if (this.sortableBy) {\n                fancytreeOptions.sortChildren = function (a, b) {\n                    var current = a.data[_this.sortableBy];\n                    var next = b.data[_this.sortableBy];\n                    if (current == next) {\n                        return 0;\n                    } else if (current < next) {\n                        return -1;\n                    } else {\n                        return 1;\n                    }\n                };\n            }\n\n            if (this.dndOptions.enabled) {\n                fancytreeOptions.extensions = ['dnd'];\n                fancytreeOptions.dnd = {\n                    dragStart: function dragStart(node, data) {\n                        return _this.dndOptions.isNodeDraggable(node, data);\n                    },\n                    dragEnter: function dragEnter(node, data) {\n                        return _this.dndOptions.nodeAcceptsDraggable(node, data);\n                    },\n                    dragExpand: function dragExpand(node, data) {\n                        return true;\n                    },\n                    dragDrop: function dragDrop(node, data) {\n                        var dropedNode = data.otherNode;\n                        var dropedAtNode = data.node;\n\n                        var dropNodePath = dropedNode.data.refPath;\n                        var dropedAtPath = dropedAtNode.data.refPath;\n                        var positionBefore = 'over' != data.hitMode && 'child' != data.hitMode;\n                        var parentNode = positionBefore ? dropedAtNode.parent : dropedAtNode;\n                        var parenPath = parentNode.data.refPath;\n                        var targetPath = parenPath + '/' + dropNodePath.substr(1 + dropNodePath.lastIndexOf('/'));\n\n                        var formerIcon = dropedNode.icon;\n\n                        var moveNodeInTree = function moveNodeInTree(responseData) {\n                            dropedNode.remove();\n                            if (positionBefore) {\n                                parentNode.children.forEach(function (node) {\n                                    if (node.data.position >= responseData.descriptors.position) {\n                                        node.data.position++;\n                                    }\n                                });\n                            }\n                            parentNode.addChildren(requestNodeToFancytreeNode(responseData));\n                        };\n\n                        var setIcon = function setIcon(nodeToSetOn, icon) {\n                            nodeToSetOn.icon = icon;\n                            dropedNode.renderTitle();\n                        };\n\n                        setIcon(dropedNode, 'fa fa-spinner fa-spin');\n\n                        var onError = function onError(jqxhr) {\n                            var message = 'Failed to move node';\n                            var formerLabel = dropedNode.title;\n                            if (jqxhr.hasOwnProperty('responseJSON') && jqxhr.responseJSON.hasOwnProperty('message')) {\n                                message += ': ' + jqxhr.responseJSON.message;\n                            }\n                            var details = null;\n                            if (jqxhr.hasOwnProperty('responseJSON')) {\n                                details = jqxhr.responseJSON;\n                            }\n                            dropedNode._error = { message: message, details: details };\n                            dropedNode.renderStatus();\n\n                            dropedNode.title += '[' + message + ']';\n                            dropedNode.renderTitle();\n\n                            console.error(message);\n                            setIcon(dropedNode, formerIcon);\n\n                            setTimeout(function () {\n                                dropedNode._error = null;\n                                dropedNode.title = formerLabel;\n                                dropedNode.renderTitle();\n                                dropedNode.renderStatus();\n                            }, 1000);\n                        };\n                        _this.requestData.move(dropNodePath, targetPath).done(function (responseData) {\n                            if (positionBefore && _this.dndOptions.reorder) {\n                                _this.requestData.reorder(parenPath, dropedAtPath, targetPath, data.hitMode).done(function (responseData) {\n                                    moveNodeInTree(responseData);\n                                    if (fancytreeOptions.hasOwnProperty('sortChildren')) {\n                                        parentNode.sortChildren(fancytreeOptions.sortChildren, true);\n                                    }\n                                    setIcon(dropedNode, formerIcon);\n                                }).fail(function (jqxhr) {\n                                    onError(jqxhr);\n                                    setTimeout(function () {\n                                        _this.requestData.move(targetPath, dropNodePath).done(function (responseData) {\n                                            if (fancytreeOptions.hasOwnProperty('sortChildren')) {\n                                                parentNode.sortChildren(fancytreeOptions.sortChildren, true);\n                                            }\n                                            setIcon(dropedNode, formerIcon);\n                                        });\n                                    }, 1000);\n                                });\n                            } else {\n                                dropedNode.icon = formerIcon;\n                                moveNodeInTree(responseData);\n                            }\n                        }).fail(onError);\n                    }\n                };\n            }\n\n            this.$tree.fancytree(fancytreeOptions);\n\n            if (this.actions) {\n                this.$tree.cmfContextMenu({\n                    delegate: 'span.fancytree-title',\n                    wrapperTemplate: '<ul class=\"dropdown-menu\" style=\"display:block;\"></ul>',\n                    actionTemplate: '<li role=\"presentation\"><a role=\"menuitem\" href=\"{{ url }}\"><i class=\"{{ iconClass }}\"></i> {{ label }}</li>',\n                    actions: function actions($node) {\n                        return jQuery.ui.fancytree.getNode($node).data.actions;\n                    }\n                });\n            }\n\n            this.tree = this.$tree.fancytree('getTree');\n\n            this.tree.getNodeByRefPath = function (refPath) {\n                return this.findFirst(function (node) {\n                    return node.data.refPath == refPath;\n                });\n            };\n\n            // We do not want to do anything on activation atm.\n            this.$tree.fancytree('option', 'activate', function (event, data) {\n                if (!_this.boundToInput) {\n                    data.node.setActive(false);\n                    data.node.setFocus(false);\n                }\n            });\n        }\n    }, {\n        key: 'bindToInput',\n        value: function bindToInput($input) {\n            var _this2 = this;\n\n            this.boundToInput = true;\n\n            // output active node to input field\n            this.$tree.fancytree('option', 'activate', function (event, data) {\n                $input.val(data.node.data.refPath);\n            });\n\n            var showPath = function showPath(path) {\n                if (!_this2.pathKeyMap.hasOwnProperty(path)) {\n                    var parts = path.split('/');\n\n                    while (!_this2.pathKeyMap.hasOwnProperty(parts.join('/')) && parts.pop()) {}\n\n                    if (parts.length === 0) {\n                        return;\n                    }\n\n                    var loadedPath = parts.join('/');\n                    var pathsToLoad = path.substr(loadedPath.length + 1).split('/');\n\n                    pathsToLoad.forEach(function (pathToLoad) {\n                        _this2.pathKeyMap[loadedPath += '/' + pathToLoad] = \"\" + jQuery.ui.fancytree._nextNodeKey++;\n                    });\n                }\n\n                _this2.tree.loadKeyPath(generateKeyPath(path), function (node, status) {\n                    if ('ok' == status) {\n                        node.setExpanded();\n                        node.setActive();\n                    }\n                });\n            };\n            var generateKeyPath = function generateKeyPath(path) {\n                var keyPath = '';\n                var refPath = '';\n                var subPaths = path.split('/');\n\n                subPaths.forEach(function (subPath) {\n                    if (subPath == '' || !_this2.pathKeyMap.hasOwnProperty(refPath += '/' + subPath)) {\n                        return;\n                    }\n\n                    keyPath += '/' + _this2.pathKeyMap[refPath];\n                });\n\n                return keyPath;\n            };\n\n            // use initial input value as active node\n            this.$tree.bind('fancytreeinit', function (event, data) {\n                showPath($input.val());\n            });\n\n            // change active node when the value of the input field changed\n            $input.on('change', function (e) {\n                showPath($(this).val());\n            });\n        }\n    }, {\n        key: 'addAction',\n        value: function addAction(name, url, icon) {\n            this.actions[name] = { url: url, icon: icon };\n        }\n    }], [{\n        key: '_resetCache',\n        value: function _resetCache() {\n            cache.clear();\n        }\n    }]);\n\n    return FancytreeAdapter;\n}();\n\n//# sourceURL=webpack:///./js/adapter/fancytree.js?");

/***/ }),

/***/ "./js/jquery.cmf_context_menu.js":
/*!***************************************!*\
  !*** ./js/jquery.cmf_context_menu.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _jquery = __webpack_require__(/*! jquery */ \"jquery\");\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\n\n/**\n * A very flexible and simple jQuery context menu plugin.\n *\n * @author Wouter J <wouter@wouterj.nl>\n */\n_jquery2.default.fn.cmfContextMenu = function (options) {\n    var options = _jquery2.default.extend({\n        /**\n         * The selector used to delegate the contextmenu event too.\n         *\n         *     $('#tree').cmfContextMenu({ delegate: '.hasMenu' })\n         *\n         * Will delegate the contextmenu event to all `.hasMenu`\n         * childs in `#tree`.\n         *\n         * @var string|null\n         */\n        delegate: null,\n\n        /**\n         * A list of actions in the context menu or a callback.\n         *\n         * In case of a callback, it will be called with the target\n         * element. This means the action list can be build dynamically\n         * based on the target.\n         *\n         * The contextmenu will not be shown if this list is empty or if\n         * the callback returned `false`.\n         *\n         * @var object|function\n         */\n        actions: [],\n\n        /**\n         * A callback that's called when an action is selected.\n         *\n         * The callback will be provided with the element the contextmenu was\n         * bound to and the click event.\n         *\n         * @var function\n         */\n        select: function select($action, event) {},\n\n        /**\n         * The template to use for the wrapper element.\n         *\n         * @var string\n         */\n        wrapperTemplate: '<ul id=\"cmf-context-menu\"></ul>',\n\n        /**\n         * The template to use for each action element.\n         *\n         * You can include vars with the `{{ varName }}` syntax. The available\n         * vars are the properties of the action object set in `actions`.\n         *\n         * @var string\n         */\n        actionTemplate: '<li><i class=\"{{ iconClass }}\"></i> {{ label }}</li>'\n    }, options);\n\n    var $body = (0, _jquery2.default)('body');\n    var $menu;\n\n    // respond to right click\n    (0, _jquery2.default)(this).on('contextmenu', options.delegate, function (e) {\n        e.preventDefault();\n\n        var $target = (0, _jquery2.default)(this);\n\n        // remove already shown menu\n        $menu && $menu.remove();\n\n        // generate actions\n        var actions = options.actions;\n        if (typeof actions === 'function') {\n            actions = actions($target);\n        }\n\n        if (false === actions || _jquery2.default.isEmptyObject(actions)) {\n            return;\n        }\n\n        // generate the menu element\n        $menu = function () {\n            var $wrapper = (0, _jquery2.default)(options.wrapperTemplate);\n            var $menu = $wrapper.is('ul') ? $wrapper : $wrapper.find('ul');\n            for (var cmd in actions) {\n                var action = actions[cmd];\n                var $action = (0, _jquery2.default)(function () {\n                    var tmp = options.actionTemplate;\n                    for (var prop in action) {\n                        if (!action.hasOwnProperty(prop)) {\n                            continue;\n                        }\n\n                        tmp = tmp.replace('{{ ' + prop + ' }}', action[prop]);\n                    }\n\n                    return tmp;\n                }());\n\n                $action.data('cmd', cmd);\n\n                $menu.append($action);\n            }\n\n            return $wrapper;\n        }();\n\n        // align it on the page\n        $menu.css({\n            top: e.pageY,\n            left: e.pageX\n        });\n\n        $body.append($menu);\n\n        var select = options.select;\n        // respond to a click on an action\n        $menu.on('click', 'li', function (e) {\n            e.stopPropagation();\n\n            select($target, e);\n        });\n    });\n\n    // when clicked anywhere outside of the contextmenu, hide the menu\n    (0, _jquery2.default)('html').on('click', function (e) {\n        $menu && $menu.remove();\n    });\n}; /*\n    * This file is part of the Symfony CMF package.\n    *\n    * (c) 2011-2017 Symfony CMF\n    *\n    * For the full copyright and license information, please view the LICENSE\n    * file that was distributed with this source code.\n    */\n\n//# sourceURL=webpack:///./js/jquery.cmf_context_menu.js?");

/***/ }),

/***/ "./js/jquery.cmf_tree.js":
/*!*******************************!*\
  !*** ./js/jquery.cmf_tree.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _jquery = __webpack_require__(/*! jquery */ \"jquery\");\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _fancytree = __webpack_require__(/*! ./adapter/fancytree */ \"./js/adapter/fancytree.js\");\n\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\n\n/**\n * A simple layer between the jQuery front-end and the JS tree library used.\n *\n * By default, it uses the FancytreeAdapter. You can pass other adapters by\n * changing the `adapter` setting.\n *\n * @author Wouter J <wouter@wouterj.nl>\n */\n/*\n * This file is part of the Symfony CMF package.\n *\n * (c) 2011-2017 Symfony CMF\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\n_jquery2.default.fn.cmfTree = function (options) {\n    options = _jquery2.default.extend({\n        adapter: null,\n        request: {\n            load: null\n        },\n        actions: {}\n    }, options);\n\n    // configure options\n    var $treeOutput = (0, _jquery2.default)(this);\n    var selectElement = function selectElement(selector) {\n        if ('string' == typeof selector) {\n            return (0, _jquery2.default)(selector);\n        } else if (selector instanceof _jquery2.default) {\n            return selector;\n        }\n\n        throw 'Cannot handle selector ' + selector + '. You may want to pass a jQuery object or a jQuery selector.';\n    };\n\n    if (!options.request.load) {\n        throw 'cmfTree needs an AJAX URL to lazy load the tree, pass it using the `request.load` option.';\n    }\n\n    if (!options.adapter) {\n        options.adapter = new _fancytree.FancytreeAdapter(options);\n    }\n    var adapter = options.adapter;\n\n    if (!adapter.bindToElement) {\n        throw 'cmfTree adapters must have a bindToElement() method to specify the output element of the tree.';\n    }\n\n    for (var actionName in options.actions) {\n        if (!options.actions.hasOwnProperty(actionName)) {\n            continue;\n        }\n\n        if (!adapter.addAction) {\n            throw 'The configured cmfTree adapter does not support actions, implement the addAction() method or use another adapter.';\n        }\n        var action = options.actions[actionName];\n\n        if (!action.url) {\n            throw 'actions should have a url defined, \"' + actionName + '\" does not.';\n        }\n\n        adapter.addAction(actionName, action.url, action.icon);\n    }\n\n    // render tree\n    adapter.bindToElement($treeOutput);\n\n    // optionally bind the tree to an input element\n    if (options.path_output) {\n        if (!adapter.bindToInput) {\n            throw 'The configured cmfTree adapter does not support binding to an input field, implement the bindToInput() method or use another adapter.';\n        }\n\n        adapter.bindToInput(selectElement(options.path_output));\n    }\n\n    return adapter;\n};\n\n//# sourceURL=webpack:///./js/jquery.cmf_tree.js?");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = jQuery;\n\n//# sourceURL=webpack:///external_%22jQuery%22?");

/***/ })

/******/ });